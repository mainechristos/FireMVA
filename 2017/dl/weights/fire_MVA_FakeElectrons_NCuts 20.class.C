// Class: ReadNCuts 20
// Automatically generated by MethodBase::MakeClass
//

/* configuration options =====================================================

#GEN -*-*-*-*-*-*-*-*-*-*-*- general info -*-*-*-*-*-*-*-*-*-*-*-

Method         : BDT::NCuts 20
TMVA Release   : 4.2.1         [262657]
ROOT Release   : 6.14/07       [396807]
Creator        : mchristos
Date           : Thu Nov 15 23:53:49 2018
Host           : Linux cmsbuild02.cern.ch 2.6.32-754.3.5.el6.x86_64 #1 SMP Wed Aug 15 08:57:36 CEST 2018 x86_64 x86_64 x86_64 GNU/Linux
Dir            : /cms/mchristos/ANN/FireMVA/2017
Training events: 70707
Analysis type  : [Classification]


#OPT -*-*-*-*-*-*-*-*-*-*-*-*- options -*-*-*-*-*-*-*-*-*-*-*-*-

# Set by User:
V: "False" [Verbose output (short form of "VerbosityLevel" below - overrides the latter one)]
H: "False" [Print method-specific help message]
NTrees: "50" [Number of trees in the forest]
MaxDepth: "3" [Max depth of the decision tree allowed]
MinNodeSize: "2.5%" [Minimum percentage of training events required in a leaf node (default: Classification: 5%, Regression: 0.2%)]
nCuts: "20" [Number of grid points in variable range used in finding optimal cut in node splitting]
BoostType: "Grad" [Boosting type for the trees in the forest (note: AdaCost is still experimental)]
Shrinkage: "5.000000e-01" [Learning rate for GradBoost algorithm]
# Default:
VerbosityLevel: "Default" [Verbosity level]
VarTransform: "None" [List of variable transformations performed before training, e.g., "D_Background,P_Signal,G,N_AllClasses" for: "Decorrelation, PCA-transformation, Gaussianisation, Normalisation, each for the given class of events ('AllClasses' denotes all events of all classes, if no class indication is given, 'All' is assumed)"]
CreateMVAPdfs: "False" [Create PDFs for classifier outputs (signal and background)]
IgnoreNegWeightsInTraining: "False" [Events with negative weights are ignored in the training (but are included for testing and performance evaluation)]
AdaBoostR2Loss: "quadratic" [Type of Loss function in AdaBoostR2]
UseBaggedBoost: "False" [Use only a random subsample of all events for growing the trees in each boost iteration.]
AdaBoostBeta: "5.000000e-01" [Learning rate  for AdaBoost algorithm]
UseRandomisedTrees: "False" [Determine at each node splitting the cut variable only as the best out of a random subset of variables (like in RandomForests)]
UseNvars: "5" [Size of the subset of variables used with RandomisedTree option]
UsePoissonNvars: "True" [Interpret "UseNvars" not as fixed number but as mean of a Poisson distribution in each split with RandomisedTree option]
BaggedSampleFraction: "6.000000e-01" [Relative size of bagged event sample to original size of the data sample (used whenever bagging is used (i.e. UseBaggedBoost, Bagging,)]
UseYesNoLeaf: "True" [Use Sig or Bkg categories, or the purity=S/(S+B) as classification of the leaf node -> Real-AdaBoost]
NegWeightTreatment: "pray" [How to treat events with negative weights in the BDT training (particular the boosting) : IgnoreInTraining;  Boost With inverse boostweight; Pair events with negative and positive weights in training sample and *annihilate* them (experimental!)]
Css: "1.000000e+00" [AdaCost: cost of true signal selected signal]
Cts_sb: "1.000000e+00" [AdaCost: cost of true signal selected bkg]
Ctb_ss: "1.000000e+00" [AdaCost: cost of true bkg    selected signal]
Cbb: "1.000000e+00" [AdaCost: cost of true bkg    selected bkg ]
NodePurityLimit: "5.000000e-01" [In boosting/pruning, nodes with purity > NodePurityLimit are signal; background otherwise.]
SeparationType: "giniindex" [Separation criterion for node splitting]
RegressionLossFunctionBDTG: "huber" [Loss function for BDTG regression.]
HuberQuantile: "7.000000e-01" [In the Huber loss function this is the quantile that separates the core from the tails in the residuals distribution.]
DoBoostMonitor: "False" [Create control plot with ROC integral vs tree number]
UseFisherCuts: "False" [Use multivariate splits using the Fisher criterion]
MinLinCorrForFisher: "8.000000e-01" [The minimum linear correlation between two variables demanded for use in Fisher criterion in node splitting]
UseExclusiveVars: "False" [Variables already used in fisher criterion are not anymore analysed individually for node splitting]
DoPreselection: "False" [and and apply automatic pre-selection for 100% efficient signal (bkg) cuts prior to training]
SigToBkgFraction: "1.000000e+00" [Sig to Bkg ratio used in Training (similar to NodePurityLimit, which cannot be used in real adaboost]
PruneMethod: "nopruning" [Note: for BDTs use small trees (e.g.MaxDepth=3) and NoPruning:  Pruning: Method used for pruning (removal) of statistically insignificant branches ]
PruneStrength: "0.000000e+00" [Pruning strength]
PruningValFraction: "5.000000e-01" [Fraction of events to use for optimizing automatic pruning.]
SkipNormalization: "False" [Skip normalization at initialization, to keep expectation value of BDT output according to the fraction of events]
nEventsMin: "0" [deprecated: Use MinNodeSize (in % of training events) instead]
UseBaggedGrad: "False" [deprecated: Use *UseBaggedBoost* instead:  Use only a random subsample of all events for growing the trees in each iteration.]
GradBaggingFraction: "6.000000e-01" [deprecated: Use *BaggedSampleFraction* instead: Defines the fraction of events to be used in each iteration, e.g. when UseBaggedGrad=kTRUE. ]
UseNTrainEvents: "0" [deprecated: Use *BaggedSampleFraction* instead: Number of randomly picked training events used in randomised (and bagged) trees]
NNodesMax: "0" [deprecated: Use MaxDepth instead to limit the tree size]
##


#VAR -*-*-*-*-*-*-*-*-*-*-*-* variables *-*-*-*-*-*-*-*-*-*-*-*-

NVar 27
abs(ElectronEta)              abs_ElectronEta_              abs(ElectronEta)              abs(ElectronEta)                                                'F'    [1.69258073583e-05,2.49997067451]
ElectronDXY                   ElectronDXY                   ElectronDXY                   ElectronDXY                                                     'F'    [6.64379129489e-08,0.0999782606959]
ElectronDZ                    ElectronDZ                    ElectronDZ                    ElectronDZ                                                      'F'    [4.06895367178e-07,0.199958592653]
ElectronSIP3D                 ElectronSIP3D                 ElectronSIP3D                 ElectronSIP3D                                                   'F'    [0.00396113377064,82.4355926514]
ElectronPtRatio               ElectronPtRatio               ElectronPtRatio               ElectronPtRatio                                                 'F'    [-1,3.24139928818]
ElectronPtRel                 ElectronPtRel                 ElectronPtRel                 ElectronPtRel                                                   'F'    [-1,970.202941895]
ElectronJetLRM                ElectronJetLRM                ElectronJetLRM                ElectronJetLRM                                                  'F'    [-1,0.33393111825]
ElectronJetFD                 ElectronJetFD                 ElectronJetFD                 ElectronJetFD                                                   'F'    [-1,1]
ElectronJetInOutRatio         ElectronJetInOutRatio         ElectronJetInOutRatio         ElectronJetInOutRatio                                           'F'    [-9999,1]
ElectronJetZest               ElectronJetZest               ElectronJetZest               ElectronJetZest                                                 'F'    [-1,1]
ElectronJetNoOfConst          ElectronJetNoOfConst          ElectronJetNoOfConst          ElectronJetNoOfConst                                            'F'    [0,73]
ElectronJetCSV                ElectronJetCSV                ElectronJetCSV                ElectronJetCSV                                                  'F'    [0,0.999627411366]
ElectronRelPFIsoPUCorr        ElectronRelPFIsoPUCorr        ElectronRelPFIsoPUCorr        ElectronRelPFIsoPUCorr                                          'F'    [0,1.76498115063]
ElectronRelTrkIso             ElectronRelTrkIso             ElectronRelTrkIso             ElectronRelTrkIso                                               'F'    [0,61.5004081726]
ElectronPFChargedHadronIso    ElectronPFChargedHadronIso    ElectronPFChargedHadronIso    ElectronPFChargedHadronIso                                      'F'    [0,92.4835739136]
ElectronPFNeutralHadronIso    ElectronPFNeutralHadronIso    ElectronPFNeutralHadronIso    ElectronPFNeutralHadronIso                                      'F'    [0,36.2971611023]
ElectronPFPhotonIso           ElectronPFPhotonIso           ElectronPFPhotonIso           ElectronPFPhotonIso                                             'F'    [0,77.488067627]
ElectronJetMuonEnergyFraction ElectronJetMuonEnergyFraction ElectronJetMuonEnergyFraction ElectronJetMuonEnergyFraction                                   'F'    [0,1]
ElectronJetElectronEnergyFraction ElectronJetElectronEnergyFraction ElectronJetElectronEnergyFraction ElectronJetElectronEnergyFraction                                       'F'    [0,1]
ElectronMissingHits           ElectronMissingHits           ElectronMissingHits           ElectronMissingHits                                             'F'    [0,1]
ElectronPassConversionVeto    ElectronPassConversionVeto    ElectronPassConversionVeto    ElectronPassConversionVeto                                      'F'    [1,1]
ElectronEInverseMinusPInverse ElectronEInverseMinusPInverse ElectronEInverseMinusPInverse ElectronEInverseMinusPInverse                                   'F'    [1.45857645961e-08,0.192345529795]
ElectronHoE                   ElectronHoE                   ElectronHoE                   ElectronHoE                                                     'F'    [0,1.74987196922]
ElectronDeltaPhiTrkSC         ElectronDeltaPhiTrkSC         ElectronDeltaPhiTrkSC         ElectronDeltaPhiTrkSC                                           'F'    [-0.168498814106,0.168645858765]
ElectronDeltaEtaTrkSeedSC     ElectronDeltaEtaTrkSeedSC     ElectronDeltaEtaTrkSeedSC     ElectronDeltaEtaTrkSeedSC                                       'F'    [-0.00673997402191,0.00673961639404]
ElectronFull5x5SigmaIEtaIEta  ElectronFull5x5SigmaIEtaIEta  ElectronFull5x5SigmaIEtaIEta  ElectronFull5x5SigmaIEtaIEta                                    'F'    [0,0.0424999594688]
ElectronPt                    ElectronPt                    ElectronPt                    ElectronPt                                                      'F'    [10.0002174377,1108.92687988]
NSpec 0


============================================================================ */

#include <array>
#include <vector>
#include <cmath>
#include <string>
#include <iostream>

#define NN new NCuts 20Node
   
#ifndef NCuts 20Node__def
#define NCuts 20Node__def
   
class NCuts 20Node {
   
public:
   
   // constructor of an essentially "empty" node floating in space
   NCuts 20Node ( NCuts 20Node* left,NCuts 20Node* right,
                          int selector, double cutValue, bool cutType, 
                          int nodeType, double purity, double response ) :
   fLeft         ( left         ),
   fRight        ( right        ),
   fSelector     ( selector     ),
   fCutValue     ( cutValue     ),
   fCutType      ( cutType      ),
   fNodeType     ( nodeType     ),
   fPurity       ( purity       ),
   fResponse     ( response     ){
   }

   virtual ~NCuts 20Node();

   // test event if it descends the tree at this node to the right
   virtual bool GoesRight( const std::vector<double>& inputValues ) const;
   NCuts 20Node* GetRight( void )  {return fRight; };

   // test event if it descends the tree at this node to the left 
   virtual bool GoesLeft ( const std::vector<double>& inputValues ) const;
   NCuts 20Node* GetLeft( void ) { return fLeft; };   

   // return  S/(S+B) (purity) at this node (from  training)

   double GetPurity( void ) const { return fPurity; } 
   // return the node type
   int    GetNodeType( void ) const { return fNodeType; }
   double GetResponse(void) const {return fResponse;}

private:

   NCuts 20Node*   fLeft;     // pointer to the left daughter node
   NCuts 20Node*   fRight;    // pointer to the right daughter node
   int                     fSelector; // index of variable used in node selection (decision tree)   
   double                  fCutValue; // cut value applied on this node to discriminate bkg against sig
   bool                    fCutType;  // true: if event variable > cutValue ==> signal , false otherwise
   int                     fNodeType; // Type of node: -1 == Bkg-leaf, 1 == Signal-leaf, 0 = internal 
   double                  fPurity;   // Purity of node from training
   double                  fResponse; // Regression response value of node
}; 
   
//_______________________________________________________________________
   NCuts 20Node::~NCuts 20Node()
{
   if (fLeft  != NULL) delete fLeft;
   if (fRight != NULL) delete fRight;
}; 
   
//_______________________________________________________________________
bool NCuts 20Node::GoesRight( const std::vector<double>& inputValues ) const
{
   // test event if it descends the tree at this node to the right
   bool result;
     result = (inputValues[fSelector] > fCutValue );
   if (fCutType == true) return result; //the cuts are selecting Signal ;
   else return !result;
}
   
//_______________________________________________________________________
bool NCuts 20Node::GoesLeft( const std::vector<double>& inputValues ) const
{
   // test event if it descends the tree at this node to the left
   if (!this->GoesRight(inputValues)) return true;
   else return false;
}
   
#endif
   
#ifndef IClassifierReader__def
#define IClassifierReader__def

class IClassifierReader {

 public:

   // constructor
   IClassifierReader() : fStatusIsClean( true ) {}
   virtual ~IClassifierReader() {}

   // return classifier response
   virtual double GetMvaValue( const std::vector<double>& inputValues ) const = 0;

   // returns classifier status
   bool IsStatusClean() const { return fStatusIsClean; }

 protected:

   bool fStatusIsClean;
};

#endif

class ReadNCuts 20 : public IClassifierReader {

 public:

   // constructor
   ReadNCuts 20( std::vector<std::string>& theInputVars )
      : IClassifierReader(),
        fClassName( "ReadNCuts 20" ),
        fNvars( 27 ),
        fIsNormalised( false )
   {
      // the training input variables
      const char* inputVars[] = { "abs(ElectronEta)", "ElectronDXY", "ElectronDZ", "ElectronSIP3D", "ElectronPtRatio", "ElectronPtRel", "ElectronJetLRM", "ElectronJetFD", "ElectronJetInOutRatio", "ElectronJetZest", "ElectronJetNoOfConst", "ElectronJetCSV", "ElectronRelPFIsoPUCorr", "ElectronRelTrkIso", "ElectronPFChargedHadronIso", "ElectronPFNeutralHadronIso", "ElectronPFPhotonIso", "ElectronJetMuonEnergyFraction", "ElectronJetElectronEnergyFraction", "ElectronMissingHits", "ElectronPassConversionVeto", "ElectronEInverseMinusPInverse", "ElectronHoE", "ElectronDeltaPhiTrkSC", "ElectronDeltaEtaTrkSeedSC", "ElectronFull5x5SigmaIEtaIEta", "ElectronPt" };

      // sanity checks
      if (theInputVars.size() <= 0) {
         std::cout << "Problem in class \"" << fClassName << "\": empty input vector" << std::endl;
         fStatusIsClean = false;
      }

      if (theInputVars.size() != fNvars) {
         std::cout << "Problem in class \"" << fClassName << "\": mismatch in number of input values: "
                   << theInputVars.size() << " != " << fNvars << std::endl;
         fStatusIsClean = false;
      }

      // validate input variables
      for (size_t ivar = 0; ivar < theInputVars.size(); ivar++) {
         if (theInputVars[ivar] != inputVars[ivar]) {
            std::cout << "Problem in class \"" << fClassName << "\": mismatch in input variable names" << std::endl
                      << " for variable [" << ivar << "]: " << theInputVars[ivar].c_str() << " != " << inputVars[ivar] << std::endl;
            fStatusIsClean = false;
         }
      }

      // initialize min and max vectors (for normalisation)
      fVmin[0] = 0;
      fVmax[0] = 0;
      fVmin[1] = 0;
      fVmax[1] = 0;
      fVmin[2] = 0;
      fVmax[2] = 0;
      fVmin[3] = 0;
      fVmax[3] = 0;
      fVmin[4] = 0;
      fVmax[4] = 0;
      fVmin[5] = 0;
      fVmax[5] = 0;
      fVmin[6] = 0;
      fVmax[6] = 0;
      fVmin[7] = 0;
      fVmax[7] = 0;
      fVmin[8] = 0;
      fVmax[8] = 0;
      fVmin[9] = 0;
      fVmax[9] = 0;
      fVmin[10] = 0;
      fVmax[10] = 0;
      fVmin[11] = 0;
      fVmax[11] = 0;
      fVmin[12] = 0;
      fVmax[12] = 0;
      fVmin[13] = 0;
      fVmax[13] = 0;
      fVmin[14] = 0;
      fVmax[14] = 0;
      fVmin[15] = 0;
      fVmax[15] = 0;
      fVmin[16] = 0;
      fVmax[16] = 0;
      fVmin[17] = 0;
      fVmax[17] = 0;
      fVmin[18] = 0;
      fVmax[18] = 0;
      fVmin[19] = 0;
      fVmax[19] = 0;
      fVmin[20] = 0;
      fVmax[20] = 0;
      fVmin[21] = 0;
      fVmax[21] = 0;
      fVmin[22] = 0;
      fVmax[22] = 0;
      fVmin[23] = 0;
      fVmax[23] = 0;
      fVmin[24] = 0;
      fVmax[24] = 0;
      fVmin[25] = 0;
      fVmax[25] = 0;
      fVmin[26] = 0;
      fVmax[26] = 0;

      // initialize input variable types
      fType[0] = 'F';
      fType[1] = 'F';
      fType[2] = 'F';
      fType[3] = 'F';
      fType[4] = 'F';
      fType[5] = 'F';
      fType[6] = 'F';
      fType[7] = 'F';
      fType[8] = 'F';
      fType[9] = 'F';
      fType[10] = 'F';
      fType[11] = 'F';
      fType[12] = 'F';
      fType[13] = 'F';
      fType[14] = 'F';
      fType[15] = 'F';
      fType[16] = 'F';
      fType[17] = 'F';
      fType[18] = 'F';
      fType[19] = 'F';
      fType[20] = 'F';
      fType[21] = 'F';
      fType[22] = 'F';
      fType[23] = 'F';
      fType[24] = 'F';
      fType[25] = 'F';
      fType[26] = 'F';

      // initialize constants
      Initialize();

   }

   // destructor
   virtual ~ReadNCuts 20() {
      Clear(); // method-specific
   }

   // the classifier response
   // "inputValues" is a vector of input values in the same order as the
   // variables given to the constructor
   double GetMvaValue( const std::vector<double>& inputValues ) const override;

 private:

   // method-specific destructor
   void Clear();

   // common member variables
   const char* fClassName;

   const size_t fNvars;
   size_t GetNvar()           const { return fNvars; }
   char   GetType( int ivar ) const { return fType[ivar]; }

   // normalisation of input variables
   const bool fIsNormalised;
   bool IsNormalised() const { return fIsNormalised; }
   double fVmin[27];
   double fVmax[27];
   double NormVariable( double x, double xmin, double xmax ) const {
      // normalise to output range: [-1, 1]
      return 2*(x - xmin)/(xmax - xmin) - 1.0;
   }

   // type of input variable: 'F' or 'I'
   char   fType[27];

   // initialize internal variables
   void Initialize();
   double GetMvaValue__( const std::vector<double>& inputValues ) const;

   // private members (method specific)
   std::vector<NCuts 20Node*> fForest;       // i.e. root nodes of decision trees
   std::vector<double>                fBoostWeights; // the weights applied in the individual boosts
};

double ReadNCuts 20::GetMvaValue__( const std::vector<double>& inputValues ) const
{
   double myMVA = 0;
   for (unsigned int itree=0; itree<fForest.size(); itree++){
      NCuts 20Node *current = fForest[itree];
      while (current->GetNodeType() == 0) { //intermediate node
         if (current->GoesRight(inputValues)) current=(NCuts 20Node*)current->GetRight();
         else current=(NCuts 20Node*)current->GetLeft();
      }
      myMVA += current->GetResponse();
   }
   return 2.0/(1.0+exp(-2.0*myMVA))-1.0;
};

void ReadNCuts 20::Initialize()
{
  // itree = 0
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.119276,-0.380724) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.183056,-0.316944) , 
11, 0.206248, 1, 0, 0.147473,-0.352527) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.448616,-0.0513842) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.244828,-0.255172) , 
21, 0.00914059, 1, 0, 0.376342,-0.123658) , 
18, 0.142857, 1, 0, 0.275057,-0.224943) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.329746,-0.170254) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.664821,0.164821) , 
18, 0.188238, 1, 0, 0.587184,0.0871845) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.746132,0.246132) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.882889,0.382889) , 
26, 27.8466, 1, 0, 0.78713,0.28713) , 
11, 0.836436, 1, 0, 0.73519,0.23519) , 
11, 0.618817, 1, 0, 0.5,-4.0518e-16)    );
  // itree = 1
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.314735,-0.10135) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.182372,-0.207211) , 
25, 0.0101181, 1, 0, 0.226958,-0.159024) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.584162,0.157721) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.289033,-0.105296) , 
25, 0.012139, 1, 0, 0.415186,0.00898975) , 
3, 3.37438, 1, 0, 0.258705,-0.130686) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.68848,0.0885729) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.801646,0.201196) , 
10, 13.0476, 1, 0, 0.774923,0.162548) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.444952,-0.0714314) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.742474,0.116728) , 
11, 0.908944, 1, 0, 0.56744,0.00443167) , 
25, 0.0222619, 1, 0, 0.710784,0.113669) , 
11, 0.523614, 1, 0, 0.5,-0.000262542)    );
  // itree = 2
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.183778,-0.146894) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.281425,-0.0451376) , 
6, 0.134009, 1, 0, 0.199791,-0.108237) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.373442,-0.0168608) , 
3, 2.89004, 1, 0, 0.224608,-0.0949512) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.279585,-0.11767) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.761489,0.0689713) , 
11, 0.931581, 1, 0, 0.377925,-0.0694048) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.661057,0.0496142) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.78141,0.149119) , 
16, 3.68991, 1, 0, 0.715498,0.0811809) , 
18, 0.047619, 1, 0, 0.644639,0.0495722) , 
11, 0.285608, 1, 0, 0.5,-0.000194998)    );
  // itree = 3
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.476121,0.0538401) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.335815,-0.0505879) , 
21, 0.00261684, 1, 0, 0.40316,0.0004359) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.198276,-0.120594) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.264442,-0.0508216) , 
10, 20.8571, 1, 0, 0.215051,-0.0787152) , 
21, 0.00915932, 1, 0, 0.323399,-0.0331255) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.703902,-0.000588229) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.858311,0.13669) , 
26, 27.8488, 1, 0, 0.733377,0.0180464) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.784179,0.0798639) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.861477,0.146115) , 
11, 0.945237, 1, 0, 0.830415,0.0889986) , 
14, 6.6679, 1, 0, 0.779043,0.0514362) , 
11, 0.809222, 1, 0, 0.5,-0.000350572)    );
  // itree = 4
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.1951,-0.101915) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.291148,0.0117018) , 
26, 45.5775, 1, 0, 0.205647,-0.0604174) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.56414,0.0385305) , 
3, 7.55959, 1, 0, 0.243627,-0.0508205) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.208628,-0.113951) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.549167,-0.0357866) , 
11, 0.190369, 1, 0, 0.450019,-0.048597) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.604549,0.0206111) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.716634,0.0995066) , 
5, 2.47789, 1, 0, 0.649196,0.0398002) , 
10, 11.2857, 1, 0, 0.607234,0.0211772) , 
18, 0.047619, 1, 0, 0.5,-5.62269e-05)    );
  // itree = 5
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.235425,-0.0789633) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.49576,-0.0188458) , 
3, 1.49922, 1, 0, 0.372442,-0.0339237) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.59299,0.0475307) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.340936,-0.0244927) , 
21, 0.00915988, 1, 0, 0.492488,0.0145284) , 
10, 17.381, 1, 0, 0.42159,-0.0140869) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.690075,0.0144385) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.812619,0.140774) , 
26, 30.4599, 1, 0, 0.71168,0.0259713) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.784693,0.155535) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.880033,0.105494) , 
11, 0.904398, 1, 0, 0.845919,0.0837693) , 
16, 5.30602, 1, 0, 0.755416,0.0448025) , 
3, 7.85459, 1, 0, 0.5,-0.00025484)    );
  // itree = 6
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.715249,0.0681091) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.618042,0.00865247) , 
25, 0.00915508, 1, 0, 0.673392,0.0307335) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.332979,-0.0819863) , 
21, 0.0274221, 1, 0, 0.64196,0.0226292) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.269097,-0.0564172) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.517115,-0.00297289) , 
1, 0.00476093, 1, 0, 0.374724,-0.0228202) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.571424,0.0757638) , 
17, 0.047619, 1, 0, 0.386005,-0.018245) , 
25, 0.010119, 1, 0, 0.5,-4.07814e-05)    );
  // itree = 7
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.178079,-0.0641765) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.521099,-0.00757189) , 
11, 0.142804, 1, 0, 0.46036,-0.0116972) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.661725,0.0747416) , 
17, 0.047619, 1, 0, 0.471736,-0.0079585) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.444606,0.10343) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.873991,0.086149) , 
11, 0.618699, 1, 0, 0.717318,0.0593699) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.439141,0.0077472) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.727,0.0662384) , 
1, 0.00474446, 1, 0, 0.581955,0.0244351) , 
0, 0.832971, 1, 0, 0.647667,0.0413943) , 
16, 7.37982, 1, 0, 0.5,-2.96761e-05)    );
  // itree = 8
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.38109,-0.0420461) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.452614,0.0289156) , 
26, 41.0939, 1, 0, 0.389905,-0.0230017) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.54793,0.00785481) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.643404,0.0483956) , 
18, 0.52381, 1, 0, 0.588201,0.0179632) , 
24, -0.00160496, 1, 0, 0.532105,0.00637459) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.250355,-0.0611303) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.252676,0.00326784) , 
0, 1.66739, 1, 0, 0.251748,-0.0134839) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.392128,-0.0887889) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.519098,-0.0287126) , 
13, 0.312039, 1, 0, 0.446141,-0.0490609) , 
18, 0.333333, 1, 0, 0.346032,-0.0307393) , 
24, 0.00224642, 1, 0, 0.5,-2.89881e-05)    );
  // itree = 9
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.516761,-0.00579613) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.625912,0.0566835) , 
26, 40.1545, 1, 0, 0.52947,0.000668538) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.160983,-0.0330512) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.57871,-0.0675657) , 
11, 0.618799, 1, 0, 0.288236,-0.0289562) , 
21, 0.0182812, 1, 0, 0.483702,-0.00495203) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.352813,-0.00707872) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.771268,0.0598606) , 
18, 0.084656, 1, 0, 0.658793,0.0262463) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.471492,0.0946719) , 
25, 0.0222469, 1, 0, 0.616842,0.0353432) , 
10, 24.3333, 1, 0, 0.5,-1.94455e-05)    );
  // itree = 10
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.435737,-0.0183169) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.541838,0.0256683) , 
26, 30.4589, 1, 0, 0.456085,-0.00719292) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.716986,0.0092813) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.823071,0.0804655) , 
14, 4.40383, 1, 0, 0.767715,0.0273825) , 
3, 15.7052, 1, 0, 0.485446,-0.00393531) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.179282,-0.0634875) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.602138,0.0267652) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.726198,0.0810068) , 
24, -0.000966253, 1, 0, 0.691867,0.0402607) , 
11, 0.142804, 1, 0, 0.588958,0.024152) , 
14, 13.2119, 1, 0, 0.5,1.39001e-05)    );
  // itree = 11
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.235667,-0.0379145) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.464579,0.0746951) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.8119,0.0122162) , 
11, 0.618703, 1, 0, 0.698891,0.0252854) , 
18, 0.142857, 1, 0, 0.627941,0.0182401) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.715743,0.0519816) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.338643,-0.0220114) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.592235,0.00363704) , 
1, 0.00476096, 1, 0, 0.453603,-0.00679019) , 
25, 0.00809523, 1, 0, 0.467393,-0.00456298) , 
0, 0.476199, 1, 0, 0.5,6.83068e-05)    );
  // itree = 12
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.313668,-0.0550469) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.384649,-0.00894586) , 
10, 8.09524, 1, 0, 0.351262,-0.0214195) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.477173,-0.0155425) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.541206,0.0146566) , 
8, 0.619048, 1, 0, 0.516949,0.00182491) , 
10, 10.4286, 1, 0, 0.492332,-0.00162861) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.73459,0.0738049) , 
17, 0.0952381, 1, 0, 0.5,1.04506e-05)    );
  // itree = 13
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.286094,0.0687976) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.492965,0.0362123) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.511477,-0.00425727) , 
4, 0.353096, 1, 0, 0.509084,0.0005879) , 
11, 0.0476013, 1, 0, 0.502722,0.00181101) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.572955,-0.0180485) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.303196,-0.0745852) , 
0, 1.19037, 1, 0, 0.455453,-0.0294397) , 
19, 0.047619, 1, 0, 0.5,1.12676e-05)    );
  // itree = 14
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.503029,-0.0303972) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.349281,0.00645103) , 
25, 0.0161905, 1, 0, 0.418178,-0.00677905) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.623838,0.0196909) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.297763,-0.0605714) , 
21, 0.0365002, 1, 0, 0.606236,0.0104122) , 
24, -0.00117699, 1, 0, 0.535139,0.00391293) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.308985,-0.0579603) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.79703,-0.00201289) , 
11, 0.856824, 1, 0, 0.467103,-0.0276202) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.203001,0.00995602) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.573788,-0.0211705) , 
11, 0.618786, 1, 0, 0.32792,-0.00194439) , 
25, 0.0222571, 1, 0, 0.386431,-0.0127384) , 
24, 0.00160453, 1, 0, 0.5,-2.1721e-05)    );
  // itree = 15
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.27665,-0.0604243) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.715328,0.0381392) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.478662,-0.00589882) , 
25, 0.00809351, 1, 0, 0.491932,-0.00231753) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.60169,0.033064) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.369976,-0.0202619) , 
0, 1.90251, 1, 0, 0.563135,0.0149682) , 
8, 0.809524, 1, 0, 0.50576,0.00103933) , 
10, 6.95238, 1, 0, 0.5,-2.40488e-05)    );
  // itree = 16
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.178771,-0.0701311) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.237335,-0.00826584) , 
6, 0.0922772, 1, 0, 0.203984,-0.0268191) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.169118,0.0323398) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.178855,0.0340593) , 
0, 1.90419, 1, 0, 0.173988,0.0167454) , 
0, 1.66616, 1, 0, 0.195021,-0.0138018) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.431861,0.046739) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.265493,0.00712886) , 
0, 1.07143, 1, 0, 0.31657,0.0144533) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.698851,-0.0225857) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.81482,0.0262462) , 
14, 8.63049, 1, 0, 0.738187,-0.00565535) , 
11, 0.632419, 1, 0, 0.561456,0.00277368) , 
11, 0.142804, 1, 0, 0.5,-6.26416e-06)    );
  // itree = 17
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.390254,-0.00735249) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.413836,-0.0467058) , 
12, 0.50428, 1, 0, 0.39854,-0.0140347) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.535572,0.00128577) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.769124,0.0746275) , 
17, 0.0672604, 1, 0, 0.546227,0.00286128) , 
10, 14.7619, 1, 0, 0.496359,-0.0028438) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.531817,0.00448761) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.28947,-0.0453461) , 
21, 0.00826381, 1, 0, 0.454416,-0.00724031) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.622585,0.0502536) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.622242,0.0987079) , 
18, 0.714304, 1, 0, 0.622411,0.0537914) , 
13, 0.153958, 1, 0, 0.522923,0.0176479) , 
18, 0.666667, 1, 0, 0.5,-3.50338e-05)    );
  // itree = 18
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.212714,-0.00258247) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.618878,-0.0313862) , 
11, 0.618789, 1, 0, 0.376291,-0.010999) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.59572,-0.00512635) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.390831,0.0162064) , 
25, 0.0182143, 1, 0, 0.524718,0.00169758) , 
16, 1.05408, 1, 0, 0.486781,-0.00154755) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.501082,0.0580571) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.827886,0.0155954) , 
3, 3.36992, 1, 0, 0.686441,0.0218365) , 
16, 11.0697, 1, 0, 0.5,6.2357e-07)    );
  // itree = 19
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.189184,-0.0272698) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.29589,0.0359538) , 
1, 0.00471452, 1, 0, 0.207663,-0.00900442) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.599873,0.000289881) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.644654,0.0254242) , 
15, 1.72844, 1, 0, 0.611839,0.00471516) , 
11, 0.190405, 1, 0, 0.511297,0.0013023) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.288425,-0.0515399) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.307057,-0.0174772) , 
24, 0.000319919, 1, 0, 0.297253,-0.0232814) , 
25, 0.0384523, 1, 0, 0.5,4.79975e-06)    );
  // itree = 20
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.289585,-0.0353027) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.503552,-0.00310528) , 
6, 0.079849, 1, 0, 0.465524,-0.00520744) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.319884,0.0138969) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.890121,0.0811066) , 
11, 0.761485, 1, 0, 0.589617,0.0221958) , 
14, 17.261, 1, 0, 0.475244,-0.0030609) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.289483,0.0157891) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.622093,-0.0299041) , 
11, 0.285548, 1, 0, 0.479818,-0.00825029) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.696986,0.043663) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.427355,-0.0126451) , 
21, 0.00912628, 1, 0, 0.631308,0.0208284) , 
13, 0.154006, 1, 0, 0.562799,0.00767811) , 
18, 0.571429, 1, 0, 0.5,-2.45037e-05)    );
  // itree = 21
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.2821,0.0417479) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.159611,-0.0479833) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.284535,0.00835028) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.733465,-0.00639701) , 
11, 0.611067, 1, 0, 0.522084,0.000400749) , 
11, 0.0929792, 1, 0, 0.506368,-0.000760265) , 
11, 0.0476013, 1, 0, 0.5,2.03894e-05)    );
  // itree = 22
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.25578,-0.00551793) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.764706,0.0332427) , 
11, 0.19037, 1, 0, 0.656464,0.0157533) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.489813,-0.0407708) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.622715,0.00603485) , 
10, 18.2857, 1, 0, 0.542337,-0.0149853) , 
24, 0.00089641, 1, 0, 0.626305,0.00763048) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.669575,0.0060541) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.472533,-0.0349728) , 
25, 0.00922562, 1, 0, 0.56757,-0.00999723) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.433659,0.0246113) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.324878,-0.00802395) , 
25, 0.0283333, 1, 0, 0.366865,0.00344651) , 
0, 1.50228, 1, 0, 0.457167,-0.00260214) , 
0, 0.595244, 1, 0, 0.5,-1.07928e-05)    );
  // itree = 23
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.457072,-0.000420388) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.734073,0.0177996) , 
1, 0.0142827, 1, 0, 0.511291,0.00206632) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.48462,-0.0410494) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.440929,-0.0113583) , 
22, 0.0257529, 1, 0, 0.462545,-0.0174522) , 
19, 0.047619, 1, 0, 0.508469,0.000936496) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.314032,-0.0282913) , 
0, 2.26188, 1, 0, 0.5,1.32992e-05)    );
  // itree = 24
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.44643,0.00130864) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.499339,-0.0249946) , 
2, 0.0317369, 1, 0, 0.451035,-0.000879047) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.677442,0.0672227) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.828048,0.00105837) , 
11, 0.809222, 1, 0, 0.798654,0.0109829) , 
3, 11.3364, 1, 0, 0.497557,0.000708454) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.576769,-0.0280774) , 
2, 0.0952186, 1, 0, 0.5,1.02331e-05)    );
  // itree = 25
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.500238,0.0316071) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.414607,-0.0222151) , 
4, 0.313955, 1, 0, 0.446679,-0.000931827) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.21274,0.0131736) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.770671,0.0769638) , 
11, 0.666285, 1, 0, 0.426842,0.0231392) , 
26, 19.7143, 1, 0, 0.439369,0.00793878) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.280849,-0.03999) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.524598,0.0016165) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.576409,-0.0359533) , 
6, 0.169202, 1, 0, 0.527125,-0.000312386) , 
24, -0.00417243, 1, 0, 0.513433,-0.00173855) , 
7, 0.428571, 1, 0, 0.5,1.65993e-05)    );
  // itree = 26
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.277104,0.00248903) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.38395,0.0457784) , 
6, 0.14337, 1, 0, 0.292612,0.0064596) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.757262,0.00498646) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.722737,-0.0360491) , 
6, 0.141857, 1, 0, 0.749292,-0.00326375) , 
11, 0.618817, 1, 0, 0.526176,0.00148669) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.333648,-0.041957) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.310417,0.00954946) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.301153,-0.0215657) , 
12, 0.519288, 1, 0, 0.307405,-0.000172406) , 
25, 0.0262999, 1, 0, 0.317254,-0.010227) , 
24, 0.0028883, 1, 0, 0.5,1.90554e-05)    );
  // itree = 27
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.468732,-0.00996329) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.293093,0.00540224) , 
0, 1.66665, 1, 0, 0.408415,-0.003198) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.60436,0.0273097) , 
17, 0.047619, 1, 0, 0.417407,-0.00216937) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.823604,0.0228317) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.860965,0.0791751) , 
13, 0.759032, 1, 0, 0.833371,0.0216366) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.825811,0.00730533) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.737723,-0.0370296) , 
6, 0.138193, 1, 0, 0.802634,-0.00379502) , 
9, 0.349355, 1, 0, 0.81737,0.00839777) , 
11, 0.952026, 1, 0, 0.5,1.27512e-05)    );
  // itree = 28
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.444909,0.0176062) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.545337,0.0757068) , 
26, 15.995, 1, 0, 0.480888,0.0252976) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.482426,0.00190979) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.578692,-0.0325711) , 
2, 0.0571313, 1, 0, 0.490078,-0.000793852) , 
4, 0.39533, 1, 0, 0.488944,0.0024257) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.344345,-0.0615026) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.452984,-0.026654) , 
26, 14.7784, 1, 0, 0.406839,-0.0262686) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.582032,-0.00833325) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.707029,0.0538691) , 
26, 17.022, 1, 0, 0.667102,0.0183946) , 
5, 1.7385, 1, 0, 0.526698,-0.00569993) , 
12, 0.588327, 1, 0, 0.5,4.61442e-05)    );
  // itree = 29
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.253884,-0.0181218) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.300281,0.0173704) , 
6, 0.0710089, 1, 0, 0.28803,0.00556219) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.539476,-0.0400036) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.763928,-0.000436114) , 
11, 0.727642, 1, 0, 0.742757,-0.00323876) , 
11, 0.618817, 1, 0, 0.516988,0.00113086) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.149383,-0.0765897) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.171735,-0.000826769) , 
25, 0.0262932, 1, 0, 0.160393,-0.0218025) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.579585,0.00643016) , 
11, 0.571189, 1, 0, 0.307754,-0.0123976) , 
23, 0.0402098, 1, 0, 0.5,3.24984e-05)    );
  // itree = 30
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.267191,-0.0462599) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.493539,-0.00193567) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.80332,0.0330402) , 
3, 22.6694, 1, 0, 0.50663,-0.000388759) , 
10, 8.85714, 1, 0, 0.496359,-0.00158484) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.631953,0.0469888) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.411867,-0.0263418) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.512289,0.0140249) , 
24, -0.000964217, 1, 0, 0.481476,0.00115359) , 
7, 0.705534, 1, 0, 0.522923,0.00984072) , 
18, 0.666667, 1, 0, 0.5,-1.87481e-05)    );
  // itree = 31
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.63208,0.0248148) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.612436,0.00344363) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.472859,-0.0155659) , 
0, 1.02609, 1, 0, 0.552446,-0.00319538) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.430179,0.0301056) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.336015,3.72093e-05) , 
25, 0.0263095, 1, 0, 0.356448,0.00464912) , 
0, 1.70634, 1, 0, 0.493138,-0.000821649) , 
0, 0.119062, 1, 0, 0.5,-7.27396e-06)    );
  // itree = 32
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.28725,-0.00269056) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.516725,0.0183422) , 
3, 1.87313, 1, 0, 0.355308,0.00274394) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.62195,-0.0199556) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.745594,-0.00233871) , 
3, 7.6677, 1, 0, 0.693936,-0.00679298) , 
3, 3.92928, 1, 0, 0.493857,-0.00115807) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.333018,-0.0631983) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.477932,0.0208028) , 
2, 0.00180748, 1, 0, 0.42368,-0.00669029) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.65685,0.0197978) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.725816,0.0608334) , 
9, 0.31743, 1, 0, 0.692002,0.026453) , 
2, 0.00949278, 1, 0, 0.542601,0.00799895) , 
15, 3.45687, 1, 0, 0.5,-4.08651e-06)    );
  // itree = 33
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.335937,-0.00910648) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.820271,0.0141879) , 
11, 0.951998, 1, 0, 0.436183,-0.00273252) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.713333,0.0513242) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.592938,0.00345896) , 
7, 0.517653, 1, 0, 0.601613,0.00470511) , 
18, 0.47619, 1, 0, 0.514943,0.00080847) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.245438,0.0261685) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.39841,-0.0403579) , 
18, 0.0952381, 1, 0, 0.32403,-0.00945666) , 
0, 2.14283, 1, 0, 0.5,5.00538e-06)    );
  // itree = 34
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.2821,0.0243603) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.571338,0.0612948) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.465641,-0.00375062) , 
4, 0.280704, 1, 0, 0.493429,0.00890566) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.502456,-0.000931219) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.56953,-0.0195073) , 
6, 0.159039, 1, 0, 0.508266,-0.00182655) , 
4, 0.353096, 1, 0, 0.506368,-0.000453768) , 
11, 0.0476013, 1, 0, 0.5,4.77573e-06)    );
  // itree = 35
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.23143,0.00746233) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.190372,-0.0288193) , 
14, 4.00192, 1, 0, 0.212487,-0.00523589) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.351242,0.0210339) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.710899,-0.00245785) , 
11, 0.614246, 1, 0, 0.577521,0.0046239) , 
11, 0.190391, 1, 0, 0.485556,0.00213986) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.38026,-0.0306024) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.515875,0.00297436) , 
5, 1.44674, 1, 0, 0.414818,-0.0135915) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.477492,0.0330057) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.847678,-0.00573995) , 
11, 0.856824, 1, 0, 0.667914,0.00974829) , 
5, 1.85465, 1, 0, 0.52391,-0.00353134) , 
12, 0.50428, 1, 0, 0.5,4.11611e-06)    );
  // itree = 36
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.27665,-0.0273192) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.429241,-0.0125607) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.522391,0.00571827) , 
6, 0.11428, 1, 0, 0.463962,-0.00363905) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.527194,0.00278326) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.604478,0.0380222) , 
18, 0.718149, 1, 0, 0.530767,0.00287793) , 
8, 0.619048, 1, 0, 0.50576,0.000438437) , 
10, 6.95238, 1, 0, 0.5,-2.05329e-05)    );
  // itree = 37
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.609632,0.000636118) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.77242,0.0521641) , 
26, 30.9125, 1, 0, 0.653635,0.00785571) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.447135,-0.00242482) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.395466,-0.0355218) , 
19, 0.047619, 1, 0, 0.444033,-0.00287191) , 
21, 0.00218064, 1, 0, 0.512274,0.000620732) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.285084,-0.0455598) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.266914,0.00406415) , 
0, 0.949617, 1, 0, 0.275929,-0.0115521) , 
21, 0.0457966, 1, 0, 0.5,-1.14272e-05)    );
  // itree = 38
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.449902,0.0028382) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.475737,0.0323467) , 
14, 4.15271, 1, 0, 0.458575,0.00803398) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.438502,-0.0108379) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.587777,0.00982995) , 
26, 20.6543, 1, 0, 0.502244,-0.00170441) , 
12, 0.336187, 1, 0, 0.487618,0.00155735) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.297062,0.000939775) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.342495,0.0443315) , 
12, 0.340509, 1, 0, 0.308199,0.00788055) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.723144,0.00313973) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.68824,-0.0308811) , 
6, 0.0860234, 1, 0, 0.701264,-0.0129887) , 
11, 0.523614, 1, 0, 0.532079,-0.0040061) , 
9, 0.428571, 1, 0, 0.5,7.94789e-06)    );
  // itree = 39
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.458265,-0.00295709) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.591957,0.0161947) , 
26, 20.6483, 1, 0, 0.511959,0.00246756) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.370317,-0.0242379) , 
4, 0.615771, 1, 0, 0.505799,0.00166329) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.494538,-0.00997105) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.54463,0.0208949) , 
23, 0.00386336, 1, 0, 0.506995,-0.00148765) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.318391,-0.0402858) , 
23, 0.0220109, 1, 0, 0.483885,-0.00458919) , 
7, 0.619048, 1, 0, 0.5,8.64715e-06)    );
  // itree = 40
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.358992,-0.0319917) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.621566,0.0144799) , 
1, 0.00942904, 1, 0, 0.447616,-0.0111407) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.411225,0.00173325) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.761727,0.0171829) , 
3, 7.85523, 1, 0, 0.491874,0.00340383) , 
14, 0.629119, 1, 0, 0.485446,0.00129133) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.678338,-0.00569456) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.475123,-0.0425808) , 
0, 0.946005, 1, 0, 0.582089,-0.0134747) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.614538,0.0244618) , 
13, 0.76833, 1, 0, 0.588958,-0.00788065) , 
14, 13.2119, 1, 0, 0.5,1.70642e-06)    );
  // itree = 41
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.342508,-0.00543958) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.288765,-0.0556174) , 
7, 0.714286, 1, 0, 0.33642,-0.00707273) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.548415,0.00321731) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.54456,0.0303727) , 
18, 0.714286, 1, 0, 0.548083,0.0037628) , 
1, 0.00158702, 1, 0, 0.489138,0.000745231) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.637735,0.00785599) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.707165,-0.0461722) , 
12, 0.350215, 1, 0, 0.67418,-0.0119172) , 
1, 0.0333261, 1, 0, 0.5,1.9172e-06)    );
  // itree = 42
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.439532,-0.002579) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.556418,0.0330501) , 
26, 15.9914, 1, 0, 0.48692,0.00682526) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.302969,-0.0308713) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.528329,-0.000531121) , 
7, 0.40719, 1, 0, 0.516725,-0.0012638) , 
4, 0.39533, 1, 0, 0.51022,0.000501696) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.285783,-0.0165259) , 
24, 0.00481396, 1, 0, 0.5,4.58985e-08)    );
  // itree = 43
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.468061,-0.0197906) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.634284,0.00636561) , 
24, -0.00161578, 1, 0, 0.611053,0.00162286) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.582298,-0.0378104) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.374839,0.00549657) , 
21, 0.00915969, 1, 0, 0.518752,-0.016755) , 
0, 1.15028, 1, 0, 0.59264,-0.00204326) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.46548,0.0255283) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.371485,-0.0114725) , 
4, 0.613627, 1, 0, 0.44266,0.0114172) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.237286,0.0166509) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.431788,-0.0168893) , 
18, 0.047619, 1, 0, 0.328119,-0.00127428) , 
25, 0.027485, 1, 0, 0.366185,0.00294353) , 
25, 0.0182143, 1, 0, 0.5,-3.22283e-06)    );
  // itree = 44
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.360912,0.0258024) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.391477,-0.0422209) , 
14, 3.24331, 1, 0, 0.379568,-0.00833888) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.248328,0.0207545) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.655181,-0.00324583) , 
11, 0.523614, 1, 0, 0.463849,0.00467943) , 
6, 0.0640535, 1, 0, 0.446286,0.00196669) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.458782,0.0177376) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.615676,-0.00458079) , 
7, 0.377729, 1, 0, 0.592695,-0.000760886) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.438078,-0.0366611) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.524787,-0.00144375) , 
8, 0.642466, 1, 0, 0.484405,-0.0120581) , 
22, 0.0833272, 1, 0, 0.573976,-0.00271374) , 
10, 17.381, 1, 0, 0.5,-2.16998e-06)    );
  // itree = 45
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.181926,-0.0325078) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.652842,-0.000964211) , 
11, 0.523588, 1, 0, 0.390694,-0.0104104) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.25289,-0.00657178) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.293939,0.0265775) , 
8, 0.714286, 1, 0, 0.271072,0.0042727) , 
21, 0.00915998, 1, 0, 0.330752,-0.00305282) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.384358,-0.0268483) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.648335,0.0106111) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.546792,-0.0075941) , 
24, 0.000871541, 1, 0, 0.615283,0.00307051) , 
24, -0.00353044, 1, 0, 0.603,0.00182481) , 
18, 0.380952, 1, 0, 0.5,-2.05492e-05)    );
  // itree = 46
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.36863,0.00269344) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.70859,-0.0103184) , 
3, 3.79909, 1, 0, 0.515178,-0.00188395) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.362674,-0.000734367) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.640327,0.0151304) , 
1, 0.00475626, 1, 0, 0.49397,0.00455513) , 
23, 0.00350337, 1, 0, 0.50778,0.000362347) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.255524,-0.0211051) , 
23, 0.0723188, 1, 0, 0.5,-2.98748e-05)    );
  // itree = 47
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.595768,0.00189666) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.78914,-0.0375417) , 
2, 0.0475449, 1, 0, 0.606825,-5.69826e-05) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.597255,-0.00477057) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.373286,-0.0390774) , 
25, 0.00941912, 1, 0, 0.503098,-0.0125787) , 
0, 1.25878, 1, 0, 0.593035,-0.00172171) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.377468,0.0035511) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.516599,0.0363607) , 
16, 5.09069, 1, 0, 0.398498,0.00585791) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.237371,0.0126156) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.406037,-0.0238481) , 
18, 0.047619, 1, 0, 0.308597,-0.00377588) , 
25, 0.0331049, 1, 0, 0.366615,0.00244133) , 
25, 0.0141667, 1, 0, 0.5,-1.11321e-05)    );
  // itree = 48
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.494179,0.0221982) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.323865,-0.0235074) , 
0, 2.14285, 1, 0, 0.465918,0.009914) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.451849,0.00895384) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.498395,-0.0162794) , 
6, 0.0795161, 1, 0, 0.473933,-0.00263806) , 
4, 0.550367, 1, 0, 0.470823,0.00223237) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.429467,0.00856266) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.414045,-0.0155115) , 
8, 0.52381, 1, 0, 0.417303,-0.00632626) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.433248,0.0151162) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.832032,-0.00436064) , 
11, 0.809222, 1, 0, 0.646041,0.00382868) , 
5, 1.85465, 1, 0, 0.52188,-0.0016835) , 
12, 0.336187, 1, 0, 0.5,-5.36536e-06)    );
  // itree = 49
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.213636,-0.010232) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.202745,0.0175455) , 
0, 1.78572, 1, 0, 0.20953,0.000329088) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.665906,-0.049646) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.81278,0.0119005) , 
11, 0.965598, 1, 0, 0.747099,-0.012527) , 
11, 0.856798, 1, 0, 0.330752,-0.00256998) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.59372,0.00151111) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.773319,0.0484304) , 
26, 16.5532, 1, 0, 0.68646,0.0151367) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.450566,-0.0316726) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.599799,0.00129351) , 
6, 0.0435429, 1, 0, 0.591412,-0.000331697) , 
7, 0.477065, 1, 0, 0.603,0.00155408) , 
18, 0.380952, 1, 0, 0.5,-6.17819e-06)    );
   return;
};
 
// Clean up
inline void ReadNCuts 20::Clear() 
{
   for (unsigned int itree=0; itree<fForest.size(); itree++) { 
      delete fForest[itree]; 
   }
}
   inline double ReadNCuts 20::GetMvaValue( const std::vector<double>& inputValues ) const
   {
      // classifier response value
      double retval = 0;

      // classifier response, sanity check first
      if (!IsStatusClean()) {
         std::cout << "Problem in class \"" << fClassName << "\": cannot return classifier response"
                   << " because status is dirty" << std::endl;
         retval = 0;
      }
      else {
         if (IsNormalised()) {
            // normalise variables
            std::vector<double> iV;
            iV.reserve(inputValues.size());
            int ivar = 0;
            for (std::vector<double>::const_iterator varIt = inputValues.begin();
                 varIt != inputValues.end(); varIt++, ivar++) {
               iV.push_back(NormVariable( *varIt, fVmin[ivar], fVmax[ivar] ));
            }
            retval = GetMvaValue__( iV );
         }
         else {
            retval = GetMvaValue__( inputValues );
         }
      }

      return retval;
   }
