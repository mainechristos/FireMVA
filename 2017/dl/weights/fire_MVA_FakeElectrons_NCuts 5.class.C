// Class: ReadNCuts 5
// Automatically generated by MethodBase::MakeClass
//

/* configuration options =====================================================

#GEN -*-*-*-*-*-*-*-*-*-*-*- general info -*-*-*-*-*-*-*-*-*-*-*-

Method         : BDT::NCuts 5
TMVA Release   : 4.2.1         [262657]
ROOT Release   : 6.14/07       [396807]
Creator        : mchristos
Date           : Thu Nov 15 23:53:12 2018
Host           : Linux cmsbuild02.cern.ch 2.6.32-754.3.5.el6.x86_64 #1 SMP Wed Aug 15 08:57:36 CEST 2018 x86_64 x86_64 x86_64 GNU/Linux
Dir            : /cms/mchristos/ANN/FireMVA/2017
Training events: 70707
Analysis type  : [Classification]


#OPT -*-*-*-*-*-*-*-*-*-*-*-*- options -*-*-*-*-*-*-*-*-*-*-*-*-

# Set by User:
V: "False" [Verbose output (short form of "VerbosityLevel" below - overrides the latter one)]
H: "False" [Print method-specific help message]
NTrees: "50" [Number of trees in the forest]
MaxDepth: "3" [Max depth of the decision tree allowed]
MinNodeSize: "2.5%" [Minimum percentage of training events required in a leaf node (default: Classification: 5%, Regression: 0.2%)]
nCuts: "5" [Number of grid points in variable range used in finding optimal cut in node splitting]
BoostType: "Grad" [Boosting type for the trees in the forest (note: AdaCost is still experimental)]
Shrinkage: "5.000000e-01" [Learning rate for GradBoost algorithm]
# Default:
VerbosityLevel: "Default" [Verbosity level]
VarTransform: "None" [List of variable transformations performed before training, e.g., "D_Background,P_Signal,G,N_AllClasses" for: "Decorrelation, PCA-transformation, Gaussianisation, Normalisation, each for the given class of events ('AllClasses' denotes all events of all classes, if no class indication is given, 'All' is assumed)"]
CreateMVAPdfs: "False" [Create PDFs for classifier outputs (signal and background)]
IgnoreNegWeightsInTraining: "False" [Events with negative weights are ignored in the training (but are included for testing and performance evaluation)]
AdaBoostR2Loss: "quadratic" [Type of Loss function in AdaBoostR2]
UseBaggedBoost: "False" [Use only a random subsample of all events for growing the trees in each boost iteration.]
AdaBoostBeta: "5.000000e-01" [Learning rate  for AdaBoost algorithm]
UseRandomisedTrees: "False" [Determine at each node splitting the cut variable only as the best out of a random subset of variables (like in RandomForests)]
UseNvars: "5" [Size of the subset of variables used with RandomisedTree option]
UsePoissonNvars: "True" [Interpret "UseNvars" not as fixed number but as mean of a Poisson distribution in each split with RandomisedTree option]
BaggedSampleFraction: "6.000000e-01" [Relative size of bagged event sample to original size of the data sample (used whenever bagging is used (i.e. UseBaggedBoost, Bagging,)]
UseYesNoLeaf: "True" [Use Sig or Bkg categories, or the purity=S/(S+B) as classification of the leaf node -> Real-AdaBoost]
NegWeightTreatment: "pray" [How to treat events with negative weights in the BDT training (particular the boosting) : IgnoreInTraining;  Boost With inverse boostweight; Pair events with negative and positive weights in training sample and *annihilate* them (experimental!)]
Css: "1.000000e+00" [AdaCost: cost of true signal selected signal]
Cts_sb: "1.000000e+00" [AdaCost: cost of true signal selected bkg]
Ctb_ss: "1.000000e+00" [AdaCost: cost of true bkg    selected signal]
Cbb: "1.000000e+00" [AdaCost: cost of true bkg    selected bkg ]
NodePurityLimit: "5.000000e-01" [In boosting/pruning, nodes with purity > NodePurityLimit are signal; background otherwise.]
SeparationType: "giniindex" [Separation criterion for node splitting]
RegressionLossFunctionBDTG: "huber" [Loss function for BDTG regression.]
HuberQuantile: "7.000000e-01" [In the Huber loss function this is the quantile that separates the core from the tails in the residuals distribution.]
DoBoostMonitor: "False" [Create control plot with ROC integral vs tree number]
UseFisherCuts: "False" [Use multivariate splits using the Fisher criterion]
MinLinCorrForFisher: "8.000000e-01" [The minimum linear correlation between two variables demanded for use in Fisher criterion in node splitting]
UseExclusiveVars: "False" [Variables already used in fisher criterion are not anymore analysed individually for node splitting]
DoPreselection: "False" [and and apply automatic pre-selection for 100% efficient signal (bkg) cuts prior to training]
SigToBkgFraction: "1.000000e+00" [Sig to Bkg ratio used in Training (similar to NodePurityLimit, which cannot be used in real adaboost]
PruneMethod: "nopruning" [Note: for BDTs use small trees (e.g.MaxDepth=3) and NoPruning:  Pruning: Method used for pruning (removal) of statistically insignificant branches ]
PruneStrength: "0.000000e+00" [Pruning strength]
PruningValFraction: "5.000000e-01" [Fraction of events to use for optimizing automatic pruning.]
SkipNormalization: "False" [Skip normalization at initialization, to keep expectation value of BDT output according to the fraction of events]
nEventsMin: "0" [deprecated: Use MinNodeSize (in % of training events) instead]
UseBaggedGrad: "False" [deprecated: Use *UseBaggedBoost* instead:  Use only a random subsample of all events for growing the trees in each iteration.]
GradBaggingFraction: "6.000000e-01" [deprecated: Use *BaggedSampleFraction* instead: Defines the fraction of events to be used in each iteration, e.g. when UseBaggedGrad=kTRUE. ]
UseNTrainEvents: "0" [deprecated: Use *BaggedSampleFraction* instead: Number of randomly picked training events used in randomised (and bagged) trees]
NNodesMax: "0" [deprecated: Use MaxDepth instead to limit the tree size]
##


#VAR -*-*-*-*-*-*-*-*-*-*-*-* variables *-*-*-*-*-*-*-*-*-*-*-*-

NVar 27
abs(ElectronEta)              abs_ElectronEta_              abs(ElectronEta)              abs(ElectronEta)                                                'F'    [1.69258073583e-05,2.49997067451]
ElectronDXY                   ElectronDXY                   ElectronDXY                   ElectronDXY                                                     'F'    [6.64379129489e-08,0.0999782606959]
ElectronDZ                    ElectronDZ                    ElectronDZ                    ElectronDZ                                                      'F'    [4.06895367178e-07,0.199958592653]
ElectronSIP3D                 ElectronSIP3D                 ElectronSIP3D                 ElectronSIP3D                                                   'F'    [0.00396113377064,82.4355926514]
ElectronPtRatio               ElectronPtRatio               ElectronPtRatio               ElectronPtRatio                                                 'F'    [-1,3.24139928818]
ElectronPtRel                 ElectronPtRel                 ElectronPtRel                 ElectronPtRel                                                   'F'    [-1,970.202941895]
ElectronJetLRM                ElectronJetLRM                ElectronJetLRM                ElectronJetLRM                                                  'F'    [-1,0.33393111825]
ElectronJetFD                 ElectronJetFD                 ElectronJetFD                 ElectronJetFD                                                   'F'    [-1,1]
ElectronJetInOutRatio         ElectronJetInOutRatio         ElectronJetInOutRatio         ElectronJetInOutRatio                                           'F'    [-9999,1]
ElectronJetZest               ElectronJetZest               ElectronJetZest               ElectronJetZest                                                 'F'    [-1,1]
ElectronJetNoOfConst          ElectronJetNoOfConst          ElectronJetNoOfConst          ElectronJetNoOfConst                                            'F'    [0,73]
ElectronJetCSV                ElectronJetCSV                ElectronJetCSV                ElectronJetCSV                                                  'F'    [0,0.999627411366]
ElectronRelPFIsoPUCorr        ElectronRelPFIsoPUCorr        ElectronRelPFIsoPUCorr        ElectronRelPFIsoPUCorr                                          'F'    [0,1.76498115063]
ElectronRelTrkIso             ElectronRelTrkIso             ElectronRelTrkIso             ElectronRelTrkIso                                               'F'    [0,61.5004081726]
ElectronPFChargedHadronIso    ElectronPFChargedHadronIso    ElectronPFChargedHadronIso    ElectronPFChargedHadronIso                                      'F'    [0,92.4835739136]
ElectronPFNeutralHadronIso    ElectronPFNeutralHadronIso    ElectronPFNeutralHadronIso    ElectronPFNeutralHadronIso                                      'F'    [0,36.2971611023]
ElectronPFPhotonIso           ElectronPFPhotonIso           ElectronPFPhotonIso           ElectronPFPhotonIso                                             'F'    [0,77.488067627]
ElectronJetMuonEnergyFraction ElectronJetMuonEnergyFraction ElectronJetMuonEnergyFraction ElectronJetMuonEnergyFraction                                   'F'    [0,1]
ElectronJetElectronEnergyFraction ElectronJetElectronEnergyFraction ElectronJetElectronEnergyFraction ElectronJetElectronEnergyFraction                                       'F'    [0,1]
ElectronMissingHits           ElectronMissingHits           ElectronMissingHits           ElectronMissingHits                                             'F'    [0,1]
ElectronPassConversionVeto    ElectronPassConversionVeto    ElectronPassConversionVeto    ElectronPassConversionVeto                                      'F'    [1,1]
ElectronEInverseMinusPInverse ElectronEInverseMinusPInverse ElectronEInverseMinusPInverse ElectronEInverseMinusPInverse                                   'F'    [1.45857645961e-08,0.192345529795]
ElectronHoE                   ElectronHoE                   ElectronHoE                   ElectronHoE                                                     'F'    [0,1.74987196922]
ElectronDeltaPhiTrkSC         ElectronDeltaPhiTrkSC         ElectronDeltaPhiTrkSC         ElectronDeltaPhiTrkSC                                           'F'    [-0.168498814106,0.168645858765]
ElectronDeltaEtaTrkSeedSC     ElectronDeltaEtaTrkSeedSC     ElectronDeltaEtaTrkSeedSC     ElectronDeltaEtaTrkSeedSC                                       'F'    [-0.00673997402191,0.00673961639404]
ElectronFull5x5SigmaIEtaIEta  ElectronFull5x5SigmaIEtaIEta  ElectronFull5x5SigmaIEtaIEta  ElectronFull5x5SigmaIEtaIEta                                    'F'    [0,0.0424999594688]
ElectronPt                    ElectronPt                    ElectronPt                    ElectronPt                                                      'F'    [10.0002174377,1108.92687988]
NSpec 0


============================================================================ */

#include <array>
#include <vector>
#include <cmath>
#include <string>
#include <iostream>

#define NN new NCuts 5Node
   
#ifndef NCuts 5Node__def
#define NCuts 5Node__def
   
class NCuts 5Node {
   
public:
   
   // constructor of an essentially "empty" node floating in space
   NCuts 5Node ( NCuts 5Node* left,NCuts 5Node* right,
                          int selector, double cutValue, bool cutType, 
                          int nodeType, double purity, double response ) :
   fLeft         ( left         ),
   fRight        ( right        ),
   fSelector     ( selector     ),
   fCutValue     ( cutValue     ),
   fCutType      ( cutType      ),
   fNodeType     ( nodeType     ),
   fPurity       ( purity       ),
   fResponse     ( response     ){
   }

   virtual ~NCuts 5Node();

   // test event if it descends the tree at this node to the right
   virtual bool GoesRight( const std::vector<double>& inputValues ) const;
   NCuts 5Node* GetRight( void )  {return fRight; };

   // test event if it descends the tree at this node to the left 
   virtual bool GoesLeft ( const std::vector<double>& inputValues ) const;
   NCuts 5Node* GetLeft( void ) { return fLeft; };   

   // return  S/(S+B) (purity) at this node (from  training)

   double GetPurity( void ) const { return fPurity; } 
   // return the node type
   int    GetNodeType( void ) const { return fNodeType; }
   double GetResponse(void) const {return fResponse;}

private:

   NCuts 5Node*   fLeft;     // pointer to the left daughter node
   NCuts 5Node*   fRight;    // pointer to the right daughter node
   int                     fSelector; // index of variable used in node selection (decision tree)   
   double                  fCutValue; // cut value applied on this node to discriminate bkg against sig
   bool                    fCutType;  // true: if event variable > cutValue ==> signal , false otherwise
   int                     fNodeType; // Type of node: -1 == Bkg-leaf, 1 == Signal-leaf, 0 = internal 
   double                  fPurity;   // Purity of node from training
   double                  fResponse; // Regression response value of node
}; 
   
//_______________________________________________________________________
   NCuts 5Node::~NCuts 5Node()
{
   if (fLeft  != NULL) delete fLeft;
   if (fRight != NULL) delete fRight;
}; 
   
//_______________________________________________________________________
bool NCuts 5Node::GoesRight( const std::vector<double>& inputValues ) const
{
   // test event if it descends the tree at this node to the right
   bool result;
     result = (inputValues[fSelector] > fCutValue );
   if (fCutType == true) return result; //the cuts are selecting Signal ;
   else return !result;
}
   
//_______________________________________________________________________
bool NCuts 5Node::GoesLeft( const std::vector<double>& inputValues ) const
{
   // test event if it descends the tree at this node to the left
   if (!this->GoesRight(inputValues)) return true;
   else return false;
}
   
#endif
   
#ifndef IClassifierReader__def
#define IClassifierReader__def

class IClassifierReader {

 public:

   // constructor
   IClassifierReader() : fStatusIsClean( true ) {}
   virtual ~IClassifierReader() {}

   // return classifier response
   virtual double GetMvaValue( const std::vector<double>& inputValues ) const = 0;

   // returns classifier status
   bool IsStatusClean() const { return fStatusIsClean; }

 protected:

   bool fStatusIsClean;
};

#endif

class ReadNCuts 5 : public IClassifierReader {

 public:

   // constructor
   ReadNCuts 5( std::vector<std::string>& theInputVars )
      : IClassifierReader(),
        fClassName( "ReadNCuts 5" ),
        fNvars( 27 ),
        fIsNormalised( false )
   {
      // the training input variables
      const char* inputVars[] = { "abs(ElectronEta)", "ElectronDXY", "ElectronDZ", "ElectronSIP3D", "ElectronPtRatio", "ElectronPtRel", "ElectronJetLRM", "ElectronJetFD", "ElectronJetInOutRatio", "ElectronJetZest", "ElectronJetNoOfConst", "ElectronJetCSV", "ElectronRelPFIsoPUCorr", "ElectronRelTrkIso", "ElectronPFChargedHadronIso", "ElectronPFNeutralHadronIso", "ElectronPFPhotonIso", "ElectronJetMuonEnergyFraction", "ElectronJetElectronEnergyFraction", "ElectronMissingHits", "ElectronPassConversionVeto", "ElectronEInverseMinusPInverse", "ElectronHoE", "ElectronDeltaPhiTrkSC", "ElectronDeltaEtaTrkSeedSC", "ElectronFull5x5SigmaIEtaIEta", "ElectronPt" };

      // sanity checks
      if (theInputVars.size() <= 0) {
         std::cout << "Problem in class \"" << fClassName << "\": empty input vector" << std::endl;
         fStatusIsClean = false;
      }

      if (theInputVars.size() != fNvars) {
         std::cout << "Problem in class \"" << fClassName << "\": mismatch in number of input values: "
                   << theInputVars.size() << " != " << fNvars << std::endl;
         fStatusIsClean = false;
      }

      // validate input variables
      for (size_t ivar = 0; ivar < theInputVars.size(); ivar++) {
         if (theInputVars[ivar] != inputVars[ivar]) {
            std::cout << "Problem in class \"" << fClassName << "\": mismatch in input variable names" << std::endl
                      << " for variable [" << ivar << "]: " << theInputVars[ivar].c_str() << " != " << inputVars[ivar] << std::endl;
            fStatusIsClean = false;
         }
      }

      // initialize min and max vectors (for normalisation)
      fVmin[0] = 0;
      fVmax[0] = 0;
      fVmin[1] = 0;
      fVmax[1] = 0;
      fVmin[2] = 0;
      fVmax[2] = 0;
      fVmin[3] = 0;
      fVmax[3] = 0;
      fVmin[4] = 0;
      fVmax[4] = 0;
      fVmin[5] = 0;
      fVmax[5] = 0;
      fVmin[6] = 0;
      fVmax[6] = 0;
      fVmin[7] = 0;
      fVmax[7] = 0;
      fVmin[8] = 0;
      fVmax[8] = 0;
      fVmin[9] = 0;
      fVmax[9] = 0;
      fVmin[10] = 0;
      fVmax[10] = 0;
      fVmin[11] = 0;
      fVmax[11] = 0;
      fVmin[12] = 0;
      fVmax[12] = 0;
      fVmin[13] = 0;
      fVmax[13] = 0;
      fVmin[14] = 0;
      fVmax[14] = 0;
      fVmin[15] = 0;
      fVmax[15] = 0;
      fVmin[16] = 0;
      fVmax[16] = 0;
      fVmin[17] = 0;
      fVmax[17] = 0;
      fVmin[18] = 0;
      fVmax[18] = 0;
      fVmin[19] = 0;
      fVmax[19] = 0;
      fVmin[20] = 0;
      fVmax[20] = 0;
      fVmin[21] = 0;
      fVmax[21] = 0;
      fVmin[22] = 0;
      fVmax[22] = 0;
      fVmin[23] = 0;
      fVmax[23] = 0;
      fVmin[24] = 0;
      fVmax[24] = 0;
      fVmin[25] = 0;
      fVmax[25] = 0;
      fVmin[26] = 0;
      fVmax[26] = 0;

      // initialize input variable types
      fType[0] = 'F';
      fType[1] = 'F';
      fType[2] = 'F';
      fType[3] = 'F';
      fType[4] = 'F';
      fType[5] = 'F';
      fType[6] = 'F';
      fType[7] = 'F';
      fType[8] = 'F';
      fType[9] = 'F';
      fType[10] = 'F';
      fType[11] = 'F';
      fType[12] = 'F';
      fType[13] = 'F';
      fType[14] = 'F';
      fType[15] = 'F';
      fType[16] = 'F';
      fType[17] = 'F';
      fType[18] = 'F';
      fType[19] = 'F';
      fType[20] = 'F';
      fType[21] = 'F';
      fType[22] = 'F';
      fType[23] = 'F';
      fType[24] = 'F';
      fType[25] = 'F';
      fType[26] = 'F';

      // initialize constants
      Initialize();

   }

   // destructor
   virtual ~ReadNCuts 5() {
      Clear(); // method-specific
   }

   // the classifier response
   // "inputValues" is a vector of input values in the same order as the
   // variables given to the constructor
   double GetMvaValue( const std::vector<double>& inputValues ) const override;

 private:

   // method-specific destructor
   void Clear();

   // common member variables
   const char* fClassName;

   const size_t fNvars;
   size_t GetNvar()           const { return fNvars; }
   char   GetType( int ivar ) const { return fType[ivar]; }

   // normalisation of input variables
   const bool fIsNormalised;
   bool IsNormalised() const { return fIsNormalised; }
   double fVmin[27];
   double fVmax[27];
   double NormVariable( double x, double xmin, double xmax ) const {
      // normalise to output range: [-1, 1]
      return 2*(x - xmin)/(xmax - xmin) - 1.0;
   }

   // type of input variable: 'F' or 'I'
   char   fType[27];

   // initialize internal variables
   void Initialize();
   double GetMvaValue__( const std::vector<double>& inputValues ) const;

   // private members (method specific)
   std::vector<NCuts 5Node*> fForest;       // i.e. root nodes of decision trees
   std::vector<double>                fBoostWeights; // the weights applied in the individual boosts
};

double ReadNCuts 5::GetMvaValue__( const std::vector<double>& inputValues ) const
{
   double myMVA = 0;
   for (unsigned int itree=0; itree<fForest.size(); itree++){
      NCuts 5Node *current = fForest[itree];
      while (current->GetNodeType() == 0) { //intermediate node
         if (current->GoesRight(inputValues)) current=(NCuts 5Node*)current->GetRight();
         else current=(NCuts 5Node*)current->GetLeft();
      }
      myMVA += current->GetResponse();
   }
   return 2.0/(1.0+exp(-2.0*myMVA))-1.0;
};

void ReadNCuts 5::Initialize()
{
  // itree = 0
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.121979,-0.378021) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.193783,-0.306217) , 
11, 0.222131, 1, 0, 0.152138,-0.347862) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.292236,-0.207764) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.488737,-0.0112633) , 
11, 0.222119, 1, 0, 0.38776,-0.11224) , 
18, 0.166667, 1, 0, 0.2842,-0.2158) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.377589,-0.122411) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.671423,0.171423) , 
18, 0.324958, 1, 0, 0.59846,0.09846) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.817468,0.317468) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.699431,0.199431) , 
25, 0.0212357, 1, 0, 0.785951,0.285951) , 
11, 0.833038, 1, 0, 0.744845,0.244845) , 
11, 0.666418, 1, 0, 0.5,-2.44394e-16)    );
  // itree = 1
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.118712,-0.237914) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.16257,-0.192109) , 
0, 1.66669, 1, 0, 0.140272,-0.190432) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.401862,-0.0300434) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.274025,-0.170827) , 
25, 0.0141654, 1, 0, 0.353241,-0.0815675) , 
18, 0.166667, 1, 0, 0.256148,-0.131199) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.343595,-0.110231) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.751091,0.138557) , 
11, 0.916293, 1, 0, 0.48483,-0.0230054) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.656105,0.0536714) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.792949,0.187614) , 
10, 13.8333, 1, 0, 0.752834,0.138611) , 
18, 0.166667, 1, 0, 0.705389,0.11) , 
11, 0.499814, 1, 0, 0.5,-0.000273802)    );
  // itree = 2
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.255496,-0.109335) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.462262,0.0111294) , 
3, 2.293, 1, 0, 0.321337,-0.0602748) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.636739,0.16589) , 
3, 13.7426, 1, 0, 0.335092,-0.0510022) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.74053,0.0577994) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.856805,0.176594) , 
16, 7.2162, 1, 0, 0.76232,0.0665494) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.834678,0.16607) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.887674,0.211206) , 
18, 0.432067, 1, 0, 0.869611,0.159827) , 
14, 11.6688, 1, 0, 0.785951,0.0870944) , 
11, 0.833023, 1, 0, 0.5,-0.000491575)    );
  // itree = 3
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.316237,0.00824233) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.175108,-0.129027) , 
25, 0.00933324, 1, 0, 0.2259,-0.0614687) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.733484,0.0975833) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.438242,-0.0823367) , 
21, 0.0316773, 1, 0, 0.711526,0.0671618) , 
11, 0.166605, 1, 0, 0.60738,0.0395761) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.259514,-0.0883878) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.366479,0.0510253) , 
10, 24.3333, 1, 0, 0.268314,-0.0625135) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.648021,-0.0473744) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.77726,0.0790829) , 
11, 0.944117, 1, 0, 0.722214,0.0198297) , 
11, 0.832998, 1, 0, 0.389261,-0.0405722) , 
0, 1.24999, 1, 0, 0.5,0.000119043)    );
  // itree = 4
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.151396,-0.149543) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.168281,-0.115788) , 
25, 0.0291208, 1, 0, 0.160308,-0.0878678) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.389727,-0.0934858) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.50291,-0.025005) , 
10, 8.33333, 1, 0, 0.471578,-0.037638) , 
18, 0.166667, 1, 0, 0.389818,-0.0508316) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.239169,-0.0670877) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.348173,0.00660706) , 
10, 21.1667, 1, 0, 0.274374,-0.0292655) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.678684,0.0613847) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.392768,-0.0998518) , 
21, 0.0319925, 1, 0, 0.661545,0.0395942) , 
18, 0.162479, 1, 0, 0.538152,0.0176484) , 
10, 12.1667, 1, 0, 0.5,3.4976e-05)    );
  // itree = 5
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.468141,-0.0194731) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.25077,-0.0971678) , 
21, 0.0319373, 1, 0, 0.446569,-0.0202269) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.541156,0.0264899) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.850721,0.134178) , 
3, 13.2729, 1, 0, 0.586092,0.029884) , 
16, 4.30488, 1, 0, 0.490617,-0.00440671) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.708373,0.132127) , 
16, 12.9147, 1, 0, 0.5,-0.000131902)    );
  // itree = 6
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.262337,-0.0279564) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.45257,-0.0676135) , 
18, 0.333333, 1, 0, 0.35469,-0.0363121) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.264452,-0.0229223) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.661995,0.0386878) , 
18, 0.166667, 1, 0, 0.5782,0.0201282) , 
24, -0.00224684, 1, 0, 0.532105,0.00848834) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.250355,-0.0644077) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.252676,-0.0181746) , 
0, 1.66739, 1, 0, 0.251748,-0.0235327) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.312297,-0.0939915) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.736408,-0.0130165) , 
11, 0.832873, 1, 0, 0.446141,-0.058399) , 
18, 0.333333, 1, 0, 0.346032,-0.0404434) , 
24, 0.00224642, 1, 0, 0.5,4.57263e-05)    );
  // itree = 7
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.279479,0.0513625) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.180993,-0.0623317) , 
11, 0.0277667, 1, 0, 0.195198,-0.0299523) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.551704,-0.00547802) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.720082,0.0900263) , 
14, 14.5345, 1, 0, 0.566387,0.00137193) , 
11, 0.166605, 1, 0, 0.483702,-0.00560574) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.295499,0.0066024) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.72584,0.0488036) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.791273,0.114279) , 
8, 0.647366, 1, 0, 0.759736,0.0558452) , 
11, 0.333167, 1, 0, 0.616842,0.0401999) , 
10, 24.3333, 1, 0, 0.5,1.36723e-06)    );
  // itree = 8
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.511635,0.0537655) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.827843,0.0178326) , 
11, 0.833023, 1, 0, 0.673037,0.0273742) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.499045,-0.0354611) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.432985,0.0268977) , 
25, 0.01574, 1, 0, 0.474738,-0.00814124) , 
25, 0.009444, 1, 0, 0.559134,0.00697408) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.21479,-0.0286794) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.339064,0.0127358) , 
10, 18.3333, 1, 0, 0.255527,-0.0087026) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.40388,-0.0134661) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.43757,-0.0643545) , 
6, 0.0851251, 1, 0, 0.425225,-0.0378923) , 
18, 0.333333, 1, 0, 0.324935,-0.0206415) , 
25, 0.0283333, 1, 0, 0.5,1.3335e-06)    );
  // itree = 9
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.255854,-0.0448513) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.496911,-0.00118387) , 
3, 1.14874, 1, 0, 0.409502,-0.0115059) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.724221,0.0783833) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.725889,0.00751122) , 
6, 0.111609, 1, 0, 0.724995,0.0327358) , 
3, 6.87266, 1, 0, 0.463932,-0.00387302) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.72877,0.0845644) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.817318,0.0625851) , 
12, 0.343275, 1, 0, 0.77637,0.0501806) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.794857,0.048366) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.754682,-0.0156437) , 
18, 0.42893, 1, 0, 0.77409,0.0094208) , 
6, 0.109114, 1, 0, 0.77521,0.0294492) , 
3, 13.7426, 1, 0, 0.5,-1.199e-05)    );
  // itree = 10
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.301854,-0.0699541) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.400068,-0.0177524) , 
18, 0.666667, 1, 0, 0.342457,-0.0341945) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.387181,-0.0200103) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.511613,0.024612) , 
18, 0.635921, 1, 0, 0.422031,-0.00451956) , 
10, 10, 1, 0, 0.389818,-0.0165326) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.421267,-0.0170153) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.555246,0.0217628) , 
10, 21.1667, 1, 0, 0.468008,-0.00208052) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.475521,-0.0367345) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.676257,0.0346351) , 
24, -0.00224727, 1, 0, 0.653698,0.0186927) , 
18, 0.487438, 1, 0, 0.538152,0.00576652) , 
10, 12.1667, 1, 0, 0.5,3.10595e-05)    );
  // itree = 11
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.459875,-0.0101412) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.519739,0.0223677) , 
18, 0.666667, 1, 0, 0.46989,-0.00274774) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.33765,-0.00592345) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.735366,0.0409243) , 
18, 0.159156, 1, 0, 0.596285,0.0161273) , 
10, 20.6667, 1, 0, 0.502722,0.00215523) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.583929,-0.0186714) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.352071,-0.072133) , 
0, 0.83341, 1, 0, 0.455453,-0.0350147) , 
19, 0.166667, 1, 0, 0.5,1.45917e-05)    );
  // itree = 12
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.419179,-0.015875) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.562653,0.0154907) , 
23, -0.0124149, 1, 0, 0.524827,0.00489437) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.39062,-0.0134462) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.475317,-0.052937) , 
18, 0.5, 1, 0, 0.421286,-0.0207592) , 
23, 0.0188024, 1, 0, 0.511802,0.00166733) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.276746,-0.0464132) , 
23, 0.0562643, 1, 0, 0.5,2.43836e-05)    );
  // itree = 13
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.267633,0.00640294) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.644023,-0.0316032) , 
11, 0.499777, 1, 0, 0.469003,-0.0105046) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.519616,0.0589096) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.50877,-0.000271792) , 
12, 0.312878, 1, 0, 0.510617,0.00675114) , 
14, 5.13773, 1, 0, 0.489282,-0.00209578) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.2759,-0.00305949) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.807661,0.0706682) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.862563,0.06319) , 
9, 0.308656, 1, 0, 0.836387,0.0359429) , 
11, 0.499814, 1, 0, 0.602275,0.0200336) , 
14, 15.4139, 1, 0, 0.5,3.3442e-06)    );
  // itree = 14
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.410052,-0.00883707) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.191799,-0.0638782) , 
21, 0.0320579, 1, 0, 0.387798,-0.00940078) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.618931,0.0101432) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.626141,0.0554292) , 
18, 0.666667, 1, 0, 0.619992,0.012283) , 
1, 0.00555425, 1, 0, 0.458345,-0.00281261) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.541274,0.0752753) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.770394,0.0329352) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.716044,0.000488708) , 
4, 0.414936, 1, 0, 0.730707,0.00603815) , 
18, 0.166667, 1, 0, 0.701098,0.0139142) , 
1, 0.0166631, 1, 0, 0.5,5.76124e-05)    );
  // itree = 15
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.319941,-0.0395681) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.432665,-0.00816518) , 
10, 9.5, 1, 0, 0.410596,-0.0101251) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.519581,-0.0086793) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.578573,0.0230367) , 
8, 0.666667, 1, 0, 0.551373,0.00533889) , 
16, 2.15244, 1, 0, 0.490617,-0.001335) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.708373,0.0485798) , 
16, 12.9147, 1, 0, 0.5,8.44079e-06)    );
  // itree = 16
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.631062,0.0165637) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.485132,-0.0354859) , 
24, 0.00125574, 1, 0, 0.603304,0.00448639) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.732762,0.0793996) , 
16, 8.22557, 1, 0, 0.627304,0.0123599) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.663696,0.00309543) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.474227,-0.037127) , 
25, 0.00941912, 1, 0, 0.578137,-0.0101163) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.395858,0.0165992) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.267008,-0.0292247) , 
21, 0.0184785, 1, 0, 0.366615,0.00475664) , 
25, 0.0141667, 1, 0, 0.472338,-0.00267714) , 
0, 0.416676, 1, 0, 0.5,7.02228e-06)    );
  // itree = 17
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.48873,0.00493486) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.427996,-0.0335538) , 
19, 0.166667, 1, 0, 0.48516,0.00182587) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.541772,0.0377342) , 
15, 4.55643, 1, 0, 0.488944,0.00349686) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.259089,-0.0595789) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.832659,-0.00329061) , 
11, 0.832949, 1, 0, 0.461385,-0.0255477) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.525468,-0.0114788) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.712294,0.0599317) , 
26, 23.8263, 1, 0, 0.559912,0.000301414) , 
6, 0.0953491, 1, 0, 0.526698,-0.00841249) , 
12, 0.588327, 1, 0, 0.5,9.26176e-06)    );
  // itree = 18
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.412143,-0.0134636) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.76352,0.0352273) , 
3, 13.2252, 1, 0, 0.451784,-0.00555812) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.419398,0.0227706) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.810946,-0.00459405) , 
11, 0.833023, 1, 0, 0.59287,0.00841183) , 
24, -0.000749128, 1, 0, 0.532105,0.00239505) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.327743,-0.0250395) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.379988,0.00658849) , 
8, 0.666667, 1, 0, 0.356619,-0.00512652) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.2939,-0.0605003) , 
7, 0.666667, 1, 0, 0.346032,-0.0115463) , 
24, 0.00224642, 1, 0, 0.5,-1.03816e-05)    );
  // itree = 19
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.21039,-0.026391) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.664737,0.00295888) , 
11, 0.166605, 1, 0, 0.564726,-0.0021793) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.350701,0.0184793) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.301907,-0.021271) , 
0, 2.22215, 1, 0, 0.342408,0.00788253) , 
0, 1.66661, 1, 0, 0.498148,0.000833956) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.566696,-0.0384394) , 
2, 0.0999795, 1, 0, 0.5,-1.99761e-05)    );
  // itree = 20
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.446551,-0.00878708) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.438925,0.0162649) , 
8, 0.666667, 1, 0, 0.443507,0.00052437) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.392884,-0.0454973) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.583345,0.0082431) , 
10, 20.6667, 1, 0, 0.476487,-0.0135355) , 
12, 0.646935, 1, 0, 0.454432,-0.00413312) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.348646,0.042758) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.30907,-0.00673125) , 
7, 0.640398, 1, 0, 0.329954,0.0139813) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.773781,0.0295881) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.722706,-0.0416805) , 
6, 0.104837, 1, 0, 0.747588,-0.0052246) , 
11, 0.666418, 1, 0, 0.545534,0.0040673) , 
9, 0.333333, 1, 0, 0.5,-3.13948e-05)    );
  // itree = 21
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.575067,0.0321146) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.374059,-0.00275363) , 
0, 0.833485, 1, 0, 0.422563,0.00346686) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.800436,0.0491089) , 
3, 13.2729, 1, 0, 0.473501,0.00700393) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.241934,-0.014277) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.670277,0.00729431) , 
11, 0.333209, 1, 0, 0.507918,-0.000491654) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.550912,-0.0591221) , 
6, 0.166971, 1, 0, 0.510037,-0.00264786) , 
4, 0.4138, 1, 0, 0.5,3.65893e-06)    );
  // itree = 22
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.630022,0.0201068) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.558992,-0.00612251) , 
0, 0.277788, 1, 0, 0.571458,-0.00107196) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.392544,0.0194139) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.34087,-0.00792586) , 
0, 2.08333, 1, 0, 0.377396,0.00797223) , 
0, 1.66665, 1, 0, 0.522137,0.00122661) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.232548,-0.0120003) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.239104,0.0199135) , 
0, 1.92824, 1, 0, 0.235591,0.00172301) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.410422,-0.0369464) , 
18, 0.166667, 1, 0, 0.305328,-0.0106004) , 
25, 0.0354166, 1, 0, 0.5,1.90352e-05)    );
  // itree = 23
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.345863,0.00994511) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.46755,-0.00873276) , 
12, 0.294164, 1, 0, 0.436695,-0.00246436) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.562304,0.00241501) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.737461,0.0426613) , 
16, 8.22557, 1, 0, 0.582973,0.00470178) , 
18, 0.5, 1, 0, 0.498148,0.000546205) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.566696,-0.0241836) , 
2, 0.0999795, 1, 0, 0.5,4.99053e-06)    );
  // itree = 24
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.442539,0.00782358) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.499885,0.036744) , 
8, 0.658839, 1, 0, 0.472828,0.0155483) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.172842,0.0347953) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.557681,-0.00912159) , 
11, 0.1666, 1, 0, 0.473959,-0.000930574) , 
12, 0.588327, 1, 0, 0.473501,0.00574483) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.540101,0.00458377) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.549694,-0.0158472) , 
24, 0.000748732, 1, 0, 0.542314,-0.000134044) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.394263,-0.0474897) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.316076,-0.00909862) , 
0, 1.25031, 1, 0, 0.337319,-0.0130185) , 
24, 0.00224648, 1, 0, 0.510037,-0.00216271) , 
4, 0.4138, 1, 0, 0.5,9.62897e-06)    );
  // itree = 25
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.27913,0.0026184) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.735855,-0.0105569) , 
11, 0.666418, 1, 0, 0.492866,-0.00234902) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.29878,-0.00670386) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.790752,0.0488608) , 
11, 0.666313, 1, 0, 0.530003,0.0121196) , 
15, 3.02428, 1, 0, 0.49705,-0.000719079) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.563556,0.0225799) , 
15, 6.04953, 1, 0, 0.5,-3.2692e-06)    );
  // itree = 26
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.229541,-0.0385333) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.382588,-0.0061555) , 
24, -0.00224631, 1, 0, 0.354022,-0.00778083) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.539522,0.0117737) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.613857,-0.016284) , 
2, 0.0333179, 1, 0, 0.552434,0.00462046) , 
1, 0.00277716, 1, 0, 0.458345,-0.00126034) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.407173,0.0445466) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.707783,0.0349015) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.769215,-0.00792147) , 
18, 0.324941, 1, 0, 0.757592,0.000552694) , 
11, 0.499814, 1, 0, 0.701098,0.00620735) , 
1, 0.0166631, 1, 0, 0.5,2.10724e-05)    );
  // itree = 27
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.441878,-0.030859) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.299152,0.00393531) , 
25, 0.02125, 1, 0, 0.363468,-0.00917977) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.516107,0.000856994) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.598556,0.0235315) , 
8, 0.833333, 1, 0, 0.526961,0.00243138) , 
10, 10.3333, 1, 0, 0.502722,0.000709979) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.421458,-0.00425761) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.489183,-0.0283064) , 
6, 0.102509, 1, 0, 0.455453,-0.0116396) , 
19, 0.166667, 1, 0, 0.5,-1.23667e-06)    );
  // itree = 28
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.468153,-0.011598) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.5168,0.0142578) , 
14, 7.70659, 1, 0, 0.484136,-0.00239514) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.518506,-0.015941) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.645184,0.0315468) , 
23, -0.0044288, 1, 0, 0.601594,0.00797687) , 
14, 15.4139, 1, 0, 0.496359,-0.00131583) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.613214,0.0276739) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.609812,0.0355257) , 
24, 1.06867e-05, 1, 0, 0.611512,0.0234214) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.231104,-0.035242) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.590542,0.0145632) , 
11, 0.166567, 1, 0, 0.469878,-0.000759447) , 
7, 0.718919, 1, 0, 0.522923,0.00829673) , 
18, 0.666667, 1, 0, 0.5,1.75267e-06)    );
  // itree = 29
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.573881,0.0200627) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.372099,-0.0385912) , 
21, 0.00534159, 1, 0, 0.477111,-0.00519687) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.135814,-0.0142556) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.466809,0.0452621) , 
11, 0.333139, 1, 0, 0.289439,0.0121506) , 
21, 0.0320579, 1, 0, 0.454432,-0.00310057) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.645287,0.0373632) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.432577,-0.0440655) , 
21, 0.00533152, 1, 0, 0.566683,0.00497227) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.279104,-0.0306109) , 
21, 0.031992, 1, 0, 0.545534,0.00309867) , 
9, 0.333333, 1, 0, 0.5,1.94841e-07)    );
  // itree = 30
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.417857,0.00490536) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.79823,0.0359316) , 
3, 13.2828, 1, 0, 0.469673,0.00566084) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.481689,0.00256069) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.563407,-0.0103559) , 
12, 0.441204, 1, 0, 0.507382,-0.000813906) , 
4, 0.4138, 1, 0, 0.498325,0.000741286) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.46314,-0.0457065) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.576418,0.00590395) , 
6, 0.109616, 1, 0, 0.523275,-0.0102881) , 
12, 0.882491, 1, 0, 0.5,6.84138e-07)    );
  // itree = 31
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.237127,-0.0163714) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.505955,0.0447072) , 
11, 0.555326, 1, 0, 0.258858,-0.00671607) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.266489,0.0617992) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.391388,0.00648791) , 
11, 0.222124, 1, 0, 0.333069,0.0210972) , 
6, 0.111609, 1, 0, 0.2842,0.0027819) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.684537,-0.0124426) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.823963,0.0219037) , 
11, 0.944097, 1, 0, 0.748857,0.00104393) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.710692,-0.0600815) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.715116,-0.047697) , 
24, 1.59279e-06, 1, 0, 0.712927,-0.036469) , 
6, 0.165492, 1, 0, 0.744845,-0.00314459) , 
11, 0.666418, 1, 0, 0.5,5.49701e-06)    );
  // itree = 32
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.431014,0.0322253) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.453157,-0.00112218) , 
7, 0.666667, 1, 0, 0.443206,0.00892489) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.304362,0.0304962) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.592319,-0.027206) , 
11, 0.333185, 1, 0, 0.510343,-0.00877389) , 
6, 0.111609, 1, 0, 0.465969,0.00292402) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.384969,-0.026926) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.488692,-0.00294306) , 
6, 0.080853, 1, 0, 0.465147,-0.00500577) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.412629,0.0168008) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.803446,-0.0120971) , 
11, 0.833023, 1, 0, 0.602592,0.00300259) , 
9, 0.333333, 1, 0, 0.520466,-0.00178258) , 
12, 0.294164, 1, 0, 0.5,-1.5053e-05)    );
  // itree = 33
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.261924,0.00427507) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.65872,-0.0134356) , 
11, 0.499799, 1, 0, 0.473979,-0.00393189) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.210245,-0.0217303) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.715991,0.0285219) , 
11, 0.333194, 1, 0, 0.524776,0.0064141) , 
14, 7.70659, 1, 0, 0.489282,-0.000815169) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.515112,-0.00174556) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.352587,0.0348681) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.873327,0.00701965) , 
11, 0.666418, 1, 0, 0.647301,0.012115) , 
23, -0.0044288, 1, 0, 0.602275,0.00764328) , 
14, 15.4139, 1, 0, 0.5,-1.2826e-05)    );
  // itree = 34
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.478169,0.00618845) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.573415,-0.0140207) , 
2, 0.0666531, 1, 0, 0.48497,0.0031834) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.605353,-0.00463613) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.347748,-0.0263376) , 
25, 0.0212455, 1, 0, 0.513542,-0.00814768) , 
12, 0.490271, 1, 0, 0.488944,0.00160747) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.402587,-0.0363402) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.557332,0.00319765) , 
26, 14.0922, 1, 0, 0.508873,-0.00623648) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.69671,0.0356433) , 
26, 34.5622, 1, 0, 0.526698,-0.00386782) , 
12, 0.588327, 1, 0, 0.5,4.05476e-06)    );
  // itree = 35
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.378765,-0.0456292) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.736129,0.0158961) , 
1, 0.00850637, 1, 0, 0.481447,-0.0185237) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.636984,0.00734758) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.544407,-0.0156924) , 
0, 1.10144, 1, 0, 0.617431,0.00141395) , 
24, -0.00141762, 1, 0, 0.593035,-0.00216298) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.262122,0.00289359) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.712408,0.0199652) , 
11, 0.832998, 1, 0, 0.37909,0.00547868) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.165415,-0.000127077) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.422911,-0.0250614) , 
11, 0.33318, 1, 0, 0.297469,-0.0100763) , 
25, 0.0378024, 1, 0, 0.366615,0.0031012) , 
25, 0.0141667, 1, 0, 0.5,5.12461e-08)    );
  // itree = 36
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.395563,0.0405947) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.495218,0.00721675) , 
24, -0.00224976, 1, 0, 0.472828,0.00995922) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.301476,0.0122639) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.644081,-0.00957869) , 
18, 0.278388, 1, 0, 0.473959,0.000144256) , 
12, 0.588327, 1, 0, 0.473501,0.00412019) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.536679,0.000777794) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.41283,-0.0150764) , 
23, 0.0188024, 1, 0, 0.521916,-0.000802862) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.25123,-0.0289691) , 
23, 0.0562643, 1, 0, 0.510037,-0.00155978) , 
4, 0.4138, 1, 0, 0.5,6.0742e-07)    );
  // itree = 37
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.192613,0.0202679) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.706391,-0.0200629) , 
11, 0.832998, 1, 0, 0.2974,0.00573554) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.557867,-0.0135384) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.791946,0.0104846) , 
3, 11.6413, 1, 0, 0.601256,-0.00693539) , 
18, 0.333333, 1, 0, 0.498863,-0.00266556) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.198277,-0.0100175) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.67595,0.00541328) , 
11, 0.499791, 1, 0, 0.439224,-0.000991371) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.62589,0.0199255) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.39834,-0.0317207) , 
23, 0.0275442, 1, 0, 0.587566,0.00775677) , 
18, 0.5, 1, 0, 0.50114,0.00265998) , 
23, 7.35223e-05, 1, 0, 0.5,-6.31081e-06)    );
  // itree = 38
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.469627,-0.00108216) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.626166,0.0109165) , 
24, -0.000499791, 1, 0, 0.52804,0.00222715) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.554438,-0.0161602) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.399998,0.00652135) , 
0, 1.24967, 1, 0, 0.479272,-0.00320365) , 
24, 0.000748323, 1, 0, 0.512225,0.000466018) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.284684,-0.020901) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.289587,-0.00342503) , 
12, 0.363502, 1, 0, 0.287078,-0.0082438) , 
24, 0.00449302, 1, 0, 0.5,-6.8998e-06)    );
  // itree = 39
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.456937,-0.00639368) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.581617,0.00730125) , 
10, 19.6667, 1, 0, 0.491125,-0.0018861) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.234654,-0.0097456) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.691426,0.0191419) , 
11, 0.333194, 1, 0, 0.521099,0.00561032) , 
15, 2.01619, 1, 0, 0.49705,-0.000404422) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.563556,0.0129217) , 
15, 6.04953, 1, 0, 0.5,-1.9298e-06)    );
  // itree = 40
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.286488,-0.0129639) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.430495,0.0217144) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.421125,-0.0104615) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.535256,0.0023802) , 
9, 0.227422, 1, 0, 0.512977,1.3764e-05) , 
7, 0.333333, 1, 0, 0.510694,0.000413345) , 
23, -0.0561173, 1, 0, 0.5,2.24649e-06)    );
  // itree = 41
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.389818,-0.000588601) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.479383,-0.0140163) , 
10, 12.5, 1, 0, 0.4284,-0.00430067) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.360628,0.0409672) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.557327,0.00657413) , 
7, 0.369018, 1, 0, 0.542396,0.00583773) , 
10, 16, 1, 0, 0.483702,0.000617733) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.678844,0.0217291) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.679011,-0.00871111) , 
4, 0.437039, 1, 0, 0.678929,0.00364212) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.502586,-0.0264939) , 
0, 1.24751, 1, 0, 0.616842,-0.00443584) , 
10, 24.3333, 1, 0, 0.5,-8.80049e-07)    );
  // itree = 42
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.277979,-0.00795699) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.384707,0.013814) , 
6, 0.111609, 1, 0, 0.321981,0.00132691) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.701004,-0.0412874) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.800202,0.0013284) , 
11, 0.888575, 1, 0, 0.783745,-0.00411551) , 
11, 0.833023, 1, 0, 0.496359,-0.00072833) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.2333,-0.0180032) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.645404,0.0275803) , 
11, 0.16657, 1, 0, 0.514655,0.0100764) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.541933,-0.0105453) , 
6, 0.0772799, 1, 0, 0.522923,0.00456502) , 
18, 0.666667, 1, 0, 0.5,-2.77586e-06)    );
  // itree = 43
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.488196,-0.0259703) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.614096,-0.00158753) , 
24, -0.00125742, 1, 0, 0.58898,-0.00422908) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.643449,0.00265687) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.792335,0.0494045) , 
9, 0.31836, 1, 0, 0.716713,0.0135071) , 
16, 9.28554, 1, 0, 0.60738,-0.00167418) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.252817,-0.0259984) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.386957,0.00615798) , 
10, 8, 1, 0, 0.378402,0.00287643) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.502731,-0.013883) , 
10, 24.3333, 1, 0, 0.389261,0.00174106) , 
0, 1.24999, 1, 0, 0.5,7.14412e-06)    );
  // itree = 44
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.387089,-0.00334092) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.651895,0.00851704) , 
1, 0.00555441, 1, 0, 0.48795,0.000794238) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.687038,-0.0133298) , 
1, 0.0333261, 1, 0, 0.498148,0.000303426) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.566696,-0.013257) , 
2, 0.0999795, 1, 0, 0.5,9.91038e-06)    );
  // itree = 45
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.351088,0.038712) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.204845,-0.0283992) , 
21, 0.0053423, 1, 0, 0.273619,0.0043233) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.131011,-0.0679042) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.164074,0.031752) , 
25, 0.0212455, 1, 0, 0.144697,-0.0138964) , 
21, 0.0320576, 1, 0, 0.256148,0.00185422) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.733945,-0.00164503) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.564232,-0.0407036) , 
21, 0.0159845, 1, 0, 0.717347,-0.0039707) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.533219,0.0412618) , 
21, 0.03197, 1, 0, 0.705389,-0.00154777) , 
11, 0.499814, 1, 0, 0.5,7.59236e-06)    );
  // itree = 46
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.118712,-0.0267896) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.16257,0.015489) , 
0, 1.66669, 1, 0, 0.140272,-0.00206694) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.289534,0.0385373) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.674891,-0.000772154) , 
11, 0.833008, 1, 0, 0.48483,0.0134358) , 
11, 0.499789, 1, 0, 0.248997,0.00282495) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.701165,0.0532797) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.598716,-0.00891664) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.775286,0.107902) , 
17, 0.0716375, 1, 0, 0.606201,-0.00288535) , 
4, 0.307653, 1, 0, 0.609907,-0.00134033) , 
18, 0.166667, 1, 0, 0.5,-7.18847e-05)    );
  // itree = 47
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.162018,-0.0356112) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.19648,0.0111116) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.282022,0.0526106) , 
6, 0.132737, 1, 0, 0.212029,0.0114989) , 
6, 0.0619362, 1, 0, 0.200259,0.00419785) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.374243,-0.00620229) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.768184,0.00505232) , 
11, 0.72196, 1, 0, 0.609137,3.47518e-05) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.270515,0.00997561) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.442106,-0.0346053) , 
18, 0.162471, 1, 0, 0.358287,-0.0116596) , 
0, 2.08331, 1, 0, 0.583023,-0.00118266) , 
11, 0.166605, 1, 0, 0.5,-1.56089e-05)    );
  // itree = 48
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.251942,0.0143183) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.60857,-0.0125383) , 
18, 0.16666, 1, 0, 0.351059,0.00335332) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.195137,-0.000390529) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.655214,-0.0105696) , 
11, 0.333199, 1, 0, 0.471503,-0.00424941) , 
12, 0.294164, 1, 0, 0.440522,-0.0022938) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.366099,0.00904976) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.751814,-0.013467) , 
11, 0.499814, 1, 0, 0.621939,-0.003297) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.533746,0.0055748) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.710387,0.0392665) , 
16, 6.70083, 1, 0, 0.55844,0.00695909) , 
18, 0.583345, 1, 0, 0.582346,0.00309792) , 
18, 0.5, 1, 0, 0.5,-3.26317e-05)    );
  // itree = 49
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.173122,0.0150502) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.408609,-0.030528) , 
11, 0.333131, 1, 0, 0.292104,-0.00815274) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.583795,0.00487284) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.341367,-0.0103058) , 
25, 0.0283333, 1, 0, 0.539247,0.00130704) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.328262,-0.0301841) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.304025,0.00887859) , 
25, 0.0283229, 1, 0, 0.314983,-0.00570593) , 
24, 0.0029953, 1, 0, 0.511364,0.000435108) , 
24, -0.00449338, 1, 0, 0.5,-9.98528e-06)    );
   return;
};
 
// Clean up
inline void ReadNCuts 5::Clear() 
{
   for (unsigned int itree=0; itree<fForest.size(); itree++) { 
      delete fForest[itree]; 
   }
}
   inline double ReadNCuts 5::GetMvaValue( const std::vector<double>& inputValues ) const
   {
      // classifier response value
      double retval = 0;

      // classifier response, sanity check first
      if (!IsStatusClean()) {
         std::cout << "Problem in class \"" << fClassName << "\": cannot return classifier response"
                   << " because status is dirty" << std::endl;
         retval = 0;
      }
      else {
         if (IsNormalised()) {
            // normalise variables
            std::vector<double> iV;
            iV.reserve(inputValues.size());
            int ivar = 0;
            for (std::vector<double>::const_iterator varIt = inputValues.begin();
                 varIt != inputValues.end(); varIt++, ivar++) {
               iV.push_back(NormVariable( *varIt, fVmin[ivar], fVmax[ivar] ));
            }
            retval = GetMvaValue__( iV );
         }
         else {
            retval = GetMvaValue__( inputValues );
         }
      }

      return retval;
   }
