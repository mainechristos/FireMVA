// Class: Read50 Trees
// Automatically generated by MethodBase::MakeClass
//

/* configuration options =====================================================

#GEN -*-*-*-*-*-*-*-*-*-*-*- general info -*-*-*-*-*-*-*-*-*-*-*-

Method         : BDT::50 Trees
TMVA Release   : 4.2.1         [262657]
ROOT Release   : 6.14/07       [396807]
Creator        : mchristos
Date           : Thu Nov 15 23:05:13 2018
Host           : Linux cmsbuild02.cern.ch 2.6.32-754.3.5.el6.x86_64 #1 SMP Wed Aug 15 08:57:36 CEST 2018 x86_64 x86_64 x86_64 GNU/Linux
Dir            : /cms/mchristos/ANN/FireMVA/2017
Training events: 70707
Analysis type  : [Classification]


#OPT -*-*-*-*-*-*-*-*-*-*-*-*- options -*-*-*-*-*-*-*-*-*-*-*-*-

# Set by User:
V: "False" [Verbose output (short form of "VerbosityLevel" below - overrides the latter one)]
H: "False" [Print method-specific help message]
NTrees: "50" [Number of trees in the forest]
MaxDepth: "3" [Max depth of the decision tree allowed]
MinNodeSize: "2.5%" [Minimum percentage of training events required in a leaf node (default: Classification: 5%, Regression: 0.2%)]
nCuts: "20" [Number of grid points in variable range used in finding optimal cut in node splitting]
BoostType: "Grad" [Boosting type for the trees in the forest (note: AdaCost is still experimental)]
Shrinkage: "1.000000e+00" [Learning rate for GradBoost algorithm]
# Default:
VerbosityLevel: "Default" [Verbosity level]
VarTransform: "None" [List of variable transformations performed before training, e.g., "D_Background,P_Signal,G,N_AllClasses" for: "Decorrelation, PCA-transformation, Gaussianisation, Normalisation, each for the given class of events ('AllClasses' denotes all events of all classes, if no class indication is given, 'All' is assumed)"]
CreateMVAPdfs: "False" [Create PDFs for classifier outputs (signal and background)]
IgnoreNegWeightsInTraining: "False" [Events with negative weights are ignored in the training (but are included for testing and performance evaluation)]
AdaBoostR2Loss: "quadratic" [Type of Loss function in AdaBoostR2]
UseBaggedBoost: "False" [Use only a random subsample of all events for growing the trees in each boost iteration.]
AdaBoostBeta: "5.000000e-01" [Learning rate  for AdaBoost algorithm]
UseRandomisedTrees: "False" [Determine at each node splitting the cut variable only as the best out of a random subset of variables (like in RandomForests)]
UseNvars: "5" [Size of the subset of variables used with RandomisedTree option]
UsePoissonNvars: "True" [Interpret "UseNvars" not as fixed number but as mean of a Poisson distribution in each split with RandomisedTree option]
BaggedSampleFraction: "6.000000e-01" [Relative size of bagged event sample to original size of the data sample (used whenever bagging is used (i.e. UseBaggedBoost, Bagging,)]
UseYesNoLeaf: "True" [Use Sig or Bkg categories, or the purity=S/(S+B) as classification of the leaf node -> Real-AdaBoost]
NegWeightTreatment: "pray" [How to treat events with negative weights in the BDT training (particular the boosting) : IgnoreInTraining;  Boost With inverse boostweight; Pair events with negative and positive weights in training sample and *annihilate* them (experimental!)]
Css: "1.000000e+00" [AdaCost: cost of true signal selected signal]
Cts_sb: "1.000000e+00" [AdaCost: cost of true signal selected bkg]
Ctb_ss: "1.000000e+00" [AdaCost: cost of true bkg    selected signal]
Cbb: "1.000000e+00" [AdaCost: cost of true bkg    selected bkg ]
NodePurityLimit: "5.000000e-01" [In boosting/pruning, nodes with purity > NodePurityLimit are signal; background otherwise.]
SeparationType: "giniindex" [Separation criterion for node splitting]
RegressionLossFunctionBDTG: "huber" [Loss function for BDTG regression.]
HuberQuantile: "7.000000e-01" [In the Huber loss function this is the quantile that separates the core from the tails in the residuals distribution.]
DoBoostMonitor: "False" [Create control plot with ROC integral vs tree number]
UseFisherCuts: "False" [Use multivariate splits using the Fisher criterion]
MinLinCorrForFisher: "8.000000e-01" [The minimum linear correlation between two variables demanded for use in Fisher criterion in node splitting]
UseExclusiveVars: "False" [Variables already used in fisher criterion are not anymore analysed individually for node splitting]
DoPreselection: "False" [and and apply automatic pre-selection for 100% efficient signal (bkg) cuts prior to training]
SigToBkgFraction: "1.000000e+00" [Sig to Bkg ratio used in Training (similar to NodePurityLimit, which cannot be used in real adaboost]
PruneMethod: "nopruning" [Note: for BDTs use small trees (e.g.MaxDepth=3) and NoPruning:  Pruning: Method used for pruning (removal) of statistically insignificant branches ]
PruneStrength: "0.000000e+00" [Pruning strength]
PruningValFraction: "5.000000e-01" [Fraction of events to use for optimizing automatic pruning.]
SkipNormalization: "False" [Skip normalization at initialization, to keep expectation value of BDT output according to the fraction of events]
nEventsMin: "0" [deprecated: Use MinNodeSize (in % of training events) instead]
UseBaggedGrad: "False" [deprecated: Use *UseBaggedBoost* instead:  Use only a random subsample of all events for growing the trees in each iteration.]
GradBaggingFraction: "6.000000e-01" [deprecated: Use *BaggedSampleFraction* instead: Defines the fraction of events to be used in each iteration, e.g. when UseBaggedGrad=kTRUE. ]
UseNTrainEvents: "0" [deprecated: Use *BaggedSampleFraction* instead: Number of randomly picked training events used in randomised (and bagged) trees]
NNodesMax: "0" [deprecated: Use MaxDepth instead to limit the tree size]
##


#VAR -*-*-*-*-*-*-*-*-*-*-*-* variables *-*-*-*-*-*-*-*-*-*-*-*-

NVar 27
abs(ElectronEta)              abs_ElectronEta_              abs(ElectronEta)              abs(ElectronEta)                                                'F'    [1.69258073583e-05,2.49997067451]
ElectronDXY                   ElectronDXY                   ElectronDXY                   ElectronDXY                                                     'F'    [6.64379129489e-08,0.0999782606959]
ElectronDZ                    ElectronDZ                    ElectronDZ                    ElectronDZ                                                      'F'    [4.06895367178e-07,0.199958592653]
ElectronSIP3D                 ElectronSIP3D                 ElectronSIP3D                 ElectronSIP3D                                                   'F'    [0.00396113377064,82.4355926514]
ElectronPtRatio               ElectronPtRatio               ElectronPtRatio               ElectronPtRatio                                                 'F'    [-1,3.24139928818]
ElectronPtRel                 ElectronPtRel                 ElectronPtRel                 ElectronPtRel                                                   'F'    [-1,970.202941895]
ElectronJetLRM                ElectronJetLRM                ElectronJetLRM                ElectronJetLRM                                                  'F'    [-1,0.33393111825]
ElectronJetFD                 ElectronJetFD                 ElectronJetFD                 ElectronJetFD                                                   'F'    [-1,1]
ElectronJetInOutRatio         ElectronJetInOutRatio         ElectronJetInOutRatio         ElectronJetInOutRatio                                           'F'    [-9999,1]
ElectronJetZest               ElectronJetZest               ElectronJetZest               ElectronJetZest                                                 'F'    [-1,1]
ElectronJetNoOfConst          ElectronJetNoOfConst          ElectronJetNoOfConst          ElectronJetNoOfConst                                            'F'    [0,73]
ElectronJetCSV                ElectronJetCSV                ElectronJetCSV                ElectronJetCSV                                                  'F'    [0,0.999627411366]
ElectronRelPFIsoPUCorr        ElectronRelPFIsoPUCorr        ElectronRelPFIsoPUCorr        ElectronRelPFIsoPUCorr                                          'F'    [0,1.76498115063]
ElectronRelTrkIso             ElectronRelTrkIso             ElectronRelTrkIso             ElectronRelTrkIso                                               'F'    [0,61.5004081726]
ElectronPFChargedHadronIso    ElectronPFChargedHadronIso    ElectronPFChargedHadronIso    ElectronPFChargedHadronIso                                      'F'    [0,92.4835739136]
ElectronPFNeutralHadronIso    ElectronPFNeutralHadronIso    ElectronPFNeutralHadronIso    ElectronPFNeutralHadronIso                                      'F'    [0,36.2971611023]
ElectronPFPhotonIso           ElectronPFPhotonIso           ElectronPFPhotonIso           ElectronPFPhotonIso                                             'F'    [0,77.488067627]
ElectronJetMuonEnergyFraction ElectronJetMuonEnergyFraction ElectronJetMuonEnergyFraction ElectronJetMuonEnergyFraction                                   'F'    [0,1]
ElectronJetElectronEnergyFraction ElectronJetElectronEnergyFraction ElectronJetElectronEnergyFraction ElectronJetElectronEnergyFraction                                       'F'    [0,1]
ElectronMissingHits           ElectronMissingHits           ElectronMissingHits           ElectronMissingHits                                             'F'    [0,1]
ElectronPassConversionVeto    ElectronPassConversionVeto    ElectronPassConversionVeto    ElectronPassConversionVeto                                      'F'    [1,1]
ElectronEInverseMinusPInverse ElectronEInverseMinusPInverse ElectronEInverseMinusPInverse ElectronEInverseMinusPInverse                                   'F'    [1.45857645961e-08,0.192345529795]
ElectronHoE                   ElectronHoE                   ElectronHoE                   ElectronHoE                                                     'F'    [0,1.74987196922]
ElectronDeltaPhiTrkSC         ElectronDeltaPhiTrkSC         ElectronDeltaPhiTrkSC         ElectronDeltaPhiTrkSC                                           'F'    [-0.168498814106,0.168645858765]
ElectronDeltaEtaTrkSeedSC     ElectronDeltaEtaTrkSeedSC     ElectronDeltaEtaTrkSeedSC     ElectronDeltaEtaTrkSeedSC                                       'F'    [-0.00673997402191,0.00673961639404]
ElectronFull5x5SigmaIEtaIEta  ElectronFull5x5SigmaIEtaIEta  ElectronFull5x5SigmaIEtaIEta  ElectronFull5x5SigmaIEtaIEta                                    'F'    [0,0.0424999594688]
ElectronPt                    ElectronPt                    ElectronPt                    ElectronPt                                                      'F'    [10.0002174377,1108.92687988]
NSpec 0


============================================================================ */

#include <array>
#include <vector>
#include <cmath>
#include <string>
#include <iostream>

#define NN new 50 TreesNode
   
#ifndef 50 TreesNode__def
#define 50 TreesNode__def
   
class 50 TreesNode {
   
public:
   
   // constructor of an essentially "empty" node floating in space
   50 TreesNode ( 50 TreesNode* left,50 TreesNode* right,
                          int selector, double cutValue, bool cutType, 
                          int nodeType, double purity, double response ) :
   fLeft         ( left         ),
   fRight        ( right        ),
   fSelector     ( selector     ),
   fCutValue     ( cutValue     ),
   fCutType      ( cutType      ),
   fNodeType     ( nodeType     ),
   fPurity       ( purity       ),
   fResponse     ( response     ){
   }

   virtual ~50 TreesNode();

   // test event if it descends the tree at this node to the right
   virtual bool GoesRight( const std::vector<double>& inputValues ) const;
   50 TreesNode* GetRight( void )  {return fRight; };

   // test event if it descends the tree at this node to the left 
   virtual bool GoesLeft ( const std::vector<double>& inputValues ) const;
   50 TreesNode* GetLeft( void ) { return fLeft; };   

   // return  S/(S+B) (purity) at this node (from  training)

   double GetPurity( void ) const { return fPurity; } 
   // return the node type
   int    GetNodeType( void ) const { return fNodeType; }
   double GetResponse(void) const {return fResponse;}

private:

   50 TreesNode*   fLeft;     // pointer to the left daughter node
   50 TreesNode*   fRight;    // pointer to the right daughter node
   int                     fSelector; // index of variable used in node selection (decision tree)   
   double                  fCutValue; // cut value applied on this node to discriminate bkg against sig
   bool                    fCutType;  // true: if event variable > cutValue ==> signal , false otherwise
   int                     fNodeType; // Type of node: -1 == Bkg-leaf, 1 == Signal-leaf, 0 = internal 
   double                  fPurity;   // Purity of node from training
   double                  fResponse; // Regression response value of node
}; 
   
//_______________________________________________________________________
   50 TreesNode::~50 TreesNode()
{
   if (fLeft  != NULL) delete fLeft;
   if (fRight != NULL) delete fRight;
}; 
   
//_______________________________________________________________________
bool 50 TreesNode::GoesRight( const std::vector<double>& inputValues ) const
{
   // test event if it descends the tree at this node to the right
   bool result;
     result = (inputValues[fSelector] > fCutValue );
   if (fCutType == true) return result; //the cuts are selecting Signal ;
   else return !result;
}
   
//_______________________________________________________________________
bool 50 TreesNode::GoesLeft( const std::vector<double>& inputValues ) const
{
   // test event if it descends the tree at this node to the left
   if (!this->GoesRight(inputValues)) return true;
   else return false;
}
   
#endif
   
#ifndef IClassifierReader__def
#define IClassifierReader__def

class IClassifierReader {

 public:

   // constructor
   IClassifierReader() : fStatusIsClean( true ) {}
   virtual ~IClassifierReader() {}

   // return classifier response
   virtual double GetMvaValue( const std::vector<double>& inputValues ) const = 0;

   // returns classifier status
   bool IsStatusClean() const { return fStatusIsClean; }

 protected:

   bool fStatusIsClean;
};

#endif

class Read50 Trees : public IClassifierReader {

 public:

   // constructor
   Read50 Trees( std::vector<std::string>& theInputVars )
      : IClassifierReader(),
        fClassName( "Read50 Trees" ),
        fNvars( 27 ),
        fIsNormalised( false )
   {
      // the training input variables
      const char* inputVars[] = { "abs(ElectronEta)", "ElectronDXY", "ElectronDZ", "ElectronSIP3D", "ElectronPtRatio", "ElectronPtRel", "ElectronJetLRM", "ElectronJetFD", "ElectronJetInOutRatio", "ElectronJetZest", "ElectronJetNoOfConst", "ElectronJetCSV", "ElectronRelPFIsoPUCorr", "ElectronRelTrkIso", "ElectronPFChargedHadronIso", "ElectronPFNeutralHadronIso", "ElectronPFPhotonIso", "ElectronJetMuonEnergyFraction", "ElectronJetElectronEnergyFraction", "ElectronMissingHits", "ElectronPassConversionVeto", "ElectronEInverseMinusPInverse", "ElectronHoE", "ElectronDeltaPhiTrkSC", "ElectronDeltaEtaTrkSeedSC", "ElectronFull5x5SigmaIEtaIEta", "ElectronPt" };

      // sanity checks
      if (theInputVars.size() <= 0) {
         std::cout << "Problem in class \"" << fClassName << "\": empty input vector" << std::endl;
         fStatusIsClean = false;
      }

      if (theInputVars.size() != fNvars) {
         std::cout << "Problem in class \"" << fClassName << "\": mismatch in number of input values: "
                   << theInputVars.size() << " != " << fNvars << std::endl;
         fStatusIsClean = false;
      }

      // validate input variables
      for (size_t ivar = 0; ivar < theInputVars.size(); ivar++) {
         if (theInputVars[ivar] != inputVars[ivar]) {
            std::cout << "Problem in class \"" << fClassName << "\": mismatch in input variable names" << std::endl
                      << " for variable [" << ivar << "]: " << theInputVars[ivar].c_str() << " != " << inputVars[ivar] << std::endl;
            fStatusIsClean = false;
         }
      }

      // initialize min and max vectors (for normalisation)
      fVmin[0] = 0;
      fVmax[0] = 0;
      fVmin[1] = 0;
      fVmax[1] = 0;
      fVmin[2] = 0;
      fVmax[2] = 0;
      fVmin[3] = 0;
      fVmax[3] = 0;
      fVmin[4] = 0;
      fVmax[4] = 0;
      fVmin[5] = 0;
      fVmax[5] = 0;
      fVmin[6] = 0;
      fVmax[6] = 0;
      fVmin[7] = 0;
      fVmax[7] = 0;
      fVmin[8] = 0;
      fVmax[8] = 0;
      fVmin[9] = 0;
      fVmax[9] = 0;
      fVmin[10] = 0;
      fVmax[10] = 0;
      fVmin[11] = 0;
      fVmax[11] = 0;
      fVmin[12] = 0;
      fVmax[12] = 0;
      fVmin[13] = 0;
      fVmax[13] = 0;
      fVmin[14] = 0;
      fVmax[14] = 0;
      fVmin[15] = 0;
      fVmax[15] = 0;
      fVmin[16] = 0;
      fVmax[16] = 0;
      fVmin[17] = 0;
      fVmax[17] = 0;
      fVmin[18] = 0;
      fVmax[18] = 0;
      fVmin[19] = 0;
      fVmax[19] = 0;
      fVmin[20] = 0;
      fVmax[20] = 0;
      fVmin[21] = 0;
      fVmax[21] = 0;
      fVmin[22] = 0;
      fVmax[22] = 0;
      fVmin[23] = 0;
      fVmax[23] = 0;
      fVmin[24] = 0;
      fVmax[24] = 0;
      fVmin[25] = 0;
      fVmax[25] = 0;
      fVmin[26] = 0;
      fVmax[26] = 0;

      // initialize input variable types
      fType[0] = 'F';
      fType[1] = 'F';
      fType[2] = 'F';
      fType[3] = 'F';
      fType[4] = 'F';
      fType[5] = 'F';
      fType[6] = 'F';
      fType[7] = 'F';
      fType[8] = 'F';
      fType[9] = 'F';
      fType[10] = 'F';
      fType[11] = 'F';
      fType[12] = 'F';
      fType[13] = 'F';
      fType[14] = 'F';
      fType[15] = 'F';
      fType[16] = 'F';
      fType[17] = 'F';
      fType[18] = 'F';
      fType[19] = 'F';
      fType[20] = 'F';
      fType[21] = 'F';
      fType[22] = 'F';
      fType[23] = 'F';
      fType[24] = 'F';
      fType[25] = 'F';
      fType[26] = 'F';

      // initialize constants
      Initialize();

   }

   // destructor
   virtual ~Read50 Trees() {
      Clear(); // method-specific
   }

   // the classifier response
   // "inputValues" is a vector of input values in the same order as the
   // variables given to the constructor
   double GetMvaValue( const std::vector<double>& inputValues ) const override;

 private:

   // method-specific destructor
   void Clear();

   // common member variables
   const char* fClassName;

   const size_t fNvars;
   size_t GetNvar()           const { return fNvars; }
   char   GetType( int ivar ) const { return fType[ivar]; }

   // normalisation of input variables
   const bool fIsNormalised;
   bool IsNormalised() const { return fIsNormalised; }
   double fVmin[27];
   double fVmax[27];
   double NormVariable( double x, double xmin, double xmax ) const {
      // normalise to output range: [-1, 1]
      return 2*(x - xmin)/(xmax - xmin) - 1.0;
   }

   // type of input variable: 'F' or 'I'
   char   fType[27];

   // initialize internal variables
   void Initialize();
   double GetMvaValue__( const std::vector<double>& inputValues ) const;

   // private members (method specific)
   std::vector<50 TreesNode*> fForest;       // i.e. root nodes of decision trees
   std::vector<double>                fBoostWeights; // the weights applied in the individual boosts
};

double Read50 Trees::GetMvaValue__( const std::vector<double>& inputValues ) const
{
   double myMVA = 0;
   for (unsigned int itree=0; itree<fForest.size(); itree++){
      50 TreesNode *current = fForest[itree];
      while (current->GetNodeType() == 0) { //intermediate node
         if (current->GoesRight(inputValues)) current=(50 TreesNode*)current->GetRight();
         else current=(50 TreesNode*)current->GetLeft();
      }
      myMVA += current->GetResponse();
   }
   return 2.0/(1.0+exp(-2.0*myMVA))-1.0;
};

void Read50 Trees::Initialize()
{
  // itree = 0
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.119276,-0.761448) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.183056,-0.633887) , 
11, 0.206248, 1, 0, 0.147473,-0.352527) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.448616,-0.102768) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.244828,-0.510344) , 
21, 0.00914059, 1, 0, 0.376342,-0.123658) , 
18, 0.142857, 1, 0, 0.275057,-0.224943) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.329746,-0.340509) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.664821,0.329641) , 
18, 0.188238, 1, 0, 0.587184,0.0871845) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.746132,0.492263) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.882889,0.765778) , 
26, 27.8466, 1, 0, 0.78713,0.28713) , 
11, 0.836436, 1, 0, 0.73519,0.23519) , 
11, 0.618817, 1, 0, 0.5,-4.0518e-16)    );
  // itree = 1
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.224465,-0.234763) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.346232,0.0116427) , 
5, 2.12402, 1, 0, 0.273263,-0.0550754) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.638415,0.00525118) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.759865,0.268853) , 
10, 12.1429, 1, 0, 0.737974,0.0867093) , 
11, 0.190405, 1, 0, 0.64196,0.057415) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.238405,-0.283161) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.312446,-0.103876) , 
10, 16.2857, 1, 0, 0.268937,-0.0802768) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.563561,-0.0450111) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.728087,0.242721) , 
16, 5.30602, 1, 0, 0.602201,0.00820401) , 
3, 3.92928, 1, 0, 0.386005,-0.0491956) , 
25, 0.010119, 1, 0, 0.5,-0.0017143)    );
  // itree = 2
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.507036,-0.0134075) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.273548,-0.158712) , 
21, 0.0183186, 1, 0, 0.46036,-0.0140378) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.661725,0.204676) , 
17, 0.047619, 1, 0, 0.471736,-0.00910676) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.333777,0.000981352) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.503189,0.232804) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.859473,0.143244) , 
11, 0.618739, 1, 0, 0.733456,0.0630435) , 
18, 0.0443624, 1, 0, 0.647667,0.049575) , 
16, 7.37982, 1, 0, 0.5,0.000320811)    );
  // itree = 3
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.122817,-0.0930481) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.238799,-0.191723) , 
18, 0.428571, 1, 0, 0.174431,-0.046762) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.428449,-0.0403094) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.599651,0.1377) , 
14, 13.2119, 1, 0, 0.452548,-0.00578706) , 
11, 0.142793, 1, 0, 0.380118,-0.0164581) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.303423,0.111514) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.553146,0.397716) , 
3, 6.82455, 1, 0, 0.361405,0.0681522) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.722608,-0.0652929) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.834483,0.139025) , 
14, 8.63049, 1, 0, 0.758375,-0.00207375) , 
11, 0.618817, 1, 0, 0.639388,0.0189756) , 
1, 0.00476093, 1, 0, 0.5,-7.42253e-05)    );
  // itree = 4
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.260019,-0.205304) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.402632,-0.0827332) , 
5, 1.7385, 1, 0, 0.321557,-0.0539534) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.514525,0.0505837) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.336871,-0.0902364) , 
0, 0.952449, 1, 0, 0.394941,-0.0149771) , 
10, 8.09524, 1, 0, 0.360475,-0.0332831) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.330963,-0.0826364) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.806833,0.0922151) , 
11, 0.951998, 1, 0, 0.410313,-0.0179612) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.615559,0.0689788) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.383724,-0.0584724) , 
24, 0.00197033, 1, 0, 0.558022,0.0123401) , 
24, -0.00160551, 1, 0, 0.524332,0.00542899) , 
10, 10.4286, 1, 0, 0.5,-0.000319655)    );
  // itree = 5
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.247015,0.000964487) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.712352,-0.0639457) , 
11, 0.618817, 1, 0, 0.473437,-0.0102121) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.603513,0.189893) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.613355,0.051699) , 
4, 0.329882, 1, 0, 0.611492,0.0244007) , 
10, 23.619, 1, 0, 0.496359,-0.00446523) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.376784,-0.0344063) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.531231,0.0500013) , 
16, 1.80644, 1, 0, 0.454416,0.00285302) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.622585,0.118978) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.622242,0.228005) , 
18, 0.714304, 1, 0, 0.622411,0.0629519) , 
13, 0.153958, 1, 0, 0.522923,0.0273608) , 
18, 0.666667, 1, 0, 0.5,-0.000102872)    );
  // itree = 6
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.336758,-0.0609134) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.502907,0.0198114) , 
2, 0.00226462, 1, 0, 0.452697,-0.0013065) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.47787,-0.134234) , 
2, 0.047552, 1, 0, 0.45388,-0.00368172) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.681808,-0.0232732) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.797256,0.0864878) , 
14, 2.75477, 1, 0, 0.75873,0.0150105) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.814053,0.164451) , 
15, 2.08795, 1, 0, 0.772023,0.0236888) , 
3, 11.7799, 1, 0, 0.5,0.000286091)    );
  // itree = 7
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.454414,0.110246) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.808468,-0.0473207) , 
11, 0.618817, 1, 0, 0.686327,0.00650859) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.611086,-0.0615565) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.465246,-0.226078) , 
0, 1.11366, 1, 0, 0.584916,-0.0297559) , 
25, 0.00915508, 1, 0, 0.64196,-0.00935712) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.24813,0.0364242) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.503608,-0.059941) , 
3, 3.92928, 1, 0, 0.317228,0.0016284) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.722135,0.0642107) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.823823,0.162613) , 
10, 14.619, 1, 0, 0.786616,0.0437632) , 
11, 0.951998, 1, 0, 0.386005,0.00780221) , 
25, 0.010119, 1, 0, 0.5,0.000159937)    );
  // itree = 8
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.235667,-0.0898337) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.533498,0.107993) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.826688,0.0397708) , 
11, 0.809073, 1, 0, 0.698891,0.0253237) , 
18, 0.142857, 1, 0, 0.627941,0.0179697) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.464376,0.0129191) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.488336,-0.0581804) , 
12, 0.588327, 1, 0, 0.471081,-0.0019608) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.400378,-0.132274) , 
19, 0.047619, 1, 0, 0.467393,-0.0042504) , 
0, 0.476199, 1, 0, 0.5,0.000262467)    );
  // itree = 9
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.224043,-0.0246967) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.18092,-0.172152) , 
12, 0.198089, 1, 0, 0.198723,-0.0327324) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.220718,-0.0481929) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.289846,0.0340431) , 
6, 0.107013, 1, 0, 0.255226,-0.00168459) , 
6, 0.0710089, 1, 0, 0.239796,-0.010163) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.374613,0.049182) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.479527,0.217511) , 
11, 0.549202, 1, 0, 0.403024,0.035371) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.739425,0.0199631) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.706753,-0.106314) , 
6, 0.157613, 1, 0, 0.734723,0.000361941) , 
11, 0.616579, 1, 0, 0.674013,0.00676955) , 
11, 0.38081, 1, 0, 0.5,-1.61917e-05)    );
  // itree = 10
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.2821,0.139165) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.398241,-0.00477909) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.620358,0.127247) , 
5, 1.77988, 1, 0, 0.493429,0.0174581) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.475753,-0.0362273) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.530589,0.00563368) , 
14, 4.40398, 1, 0, 0.508266,-0.00422958) , 
4, 0.353096, 1, 0, 0.506368,-0.00145547) , 
11, 0.0476013, 1, 0, 0.5,-0.000236749)    );
  // itree = 11
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.609632,0.0294687) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.77242,0.196398) , 
26, 30.9125, 1, 0, 0.653635,0.0223097) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.365014,-0.0362312) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.812558,0.0254614) , 
11, 0.952026, 1, 0, 0.444033,-0.00849454) , 
21, 0.00218064, 1, 0, 0.512274,0.00153455) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.285084,-0.177342) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.266914,-0.0181821) , 
0, 0.949617, 1, 0, 0.275929,-0.0283251) , 
21, 0.0457966, 1, 0, 0.5,-1.61175e-05)    );
  // itree = 12
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.618644,0.00345025) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.52735,-0.05801) , 
0, 1.15389, 1, 0, 0.600843,-0.00289406) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.424412,0.0543148) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.327152,-0.0124109) , 
25, 0.0292967, 1, 0, 0.37948,0.00791468) , 
25, 0.0109863, 1, 0, 0.511297,0.00147832) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.16646,-0.0195203) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.438059,-0.113911) , 
11, 0.38075, 1, 0, 0.297253,-0.0228093) , 
25, 0.0384523, 1, 0, 0.5,0.000196438)    );
  // itree = 13
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.46428,0.00709244) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.472942,-0.05724) , 
12, 0.336187, 1, 0, 0.46889,-0.00853038) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.500014,0.0578973) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.540853,0.00964146) , 
12, 0.31369, 1, 0, 0.529292,0.00752668) , 
8, 0.619048, 1, 0, 0.508151,0.00190673) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.347684,-0.08351) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.535034,0.0179181) , 
24, -0.00118093, 1, 0, 0.462656,-0.00699769) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.330031,-0.134199) , 
24, 0.00159841, 1, 0, 0.429921,-0.0165923) , 
7, 0.714286, 1, 0, 0.5,-2.07965e-05)    );
  // itree = 14
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.341241,0.0110838) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.788814,-0.0344144) , 
11, 0.856824, 1, 0, 0.49156,-0.00100974) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.370272,-0.0345135) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.654219,0.101052) , 
2, 0.00452596, 1, 0, 0.539005,0.0146112) , 
15, 3.45687, 1, 0, 0.497557,0.000964979) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.576769,-0.0862869) , 
2, 0.0952186, 1, 0, 0.5,-4.01513e-05)    );
  // itree = 15
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.669664,0.110926) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.774853,0.00304568) , 
1, 0.00713862, 1, 0, 0.717252,0.0216726) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.466111,-0.0289319) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.302739,0.016352) , 
0, 1.66662, 1, 0, 0.408271,-0.00421386) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.814628,0.056014) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.62554,-0.0132711) , 
25, 0.0211903, 1, 0, 0.750917,0.00893803) , 
3, 7.85459, 1, 0, 0.487018,-0.0011913) , 
25, 0.00809523, 1, 0, 0.5,9.7927e-05)    );
  // itree = 16
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.509211,-0.0324291) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.296301,0.0125658) , 
21, 0.00912495, 1, 0, 0.433359,-0.00613225) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.626532,0.0966697) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.303109,0.00576528) , 
21, 0.00860461, 1, 0, 0.486794,0.0170665) , 
26, 38.5845, 1, 0, 0.438905,-0.00372469) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.468873,0.0505135) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.836332,-0.000335132) , 
11, 0.951978, 1, 0, 0.55154,0.0130729) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.712001,0.0298648) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.56431,-0.0631849) , 
0, 0.951964, 1, 0, 0.645674,-0.00444266) , 
16, 7.20415, 1, 0, 0.590851,0.00575817) , 
16, 3.68991, 1, 0, 0.5,8.82149e-05)    );
  // itree = 17
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.448001,0.0207205) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.487154,-0.012147) , 
4, 0.39533, 1, 0, 0.478641,-0.00166896) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.497181,0.097884) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.827493,-0.00621976) , 
3, 3.36992, 1, 0, 0.683417,0.0130173) , 
16, 11.0697, 1, 0, 0.492332,-0.000687047) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.73459,0.070164) , 
17, 0.0952381, 1, 0, 0.5,2.27068e-05)    );
  // itree = 18
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.514505,0.00868257) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.247324,-0.0735445) , 
23, 0.0723188, 1, 0, 0.506487,0.00205165) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.434188,-0.114057) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.633952,0.0410993) , 
26, 17.2207, 1, 0, 0.530854,-0.0131077) , 
12, 0.86258, 1, 0, 0.508469,0.000818218) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.314032,-0.0506088) , 
0, 2.26188, 1, 0, 0.5,1.08082e-05)    );
  // itree = 19
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.461925,0.00241173) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.672169,-0.0862082) , 
1, 0.0332013, 1, 0, 0.468897,-0.000148246) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.612983,-0.0832837) , 
2, 0.0308258, 1, 0, 0.475704,-0.00139948) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.489324,-0.0793054) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.640445,0.0347746) , 
12, 0.351356, 1, 0, 0.558887,-0.0103143) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.530765,0.126978) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.783944,0.0129434) , 
11, 0.856824, 1, 0, 0.694843,0.0197312) , 
1, 0.00952237, 1, 0, 0.641888,0.00802837) , 
2, 0.0380877, 1, 0, 0.5,-2.11408e-05)    );
  // itree = 20
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.251858,-0.00203534) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.540238,-0.0488957) , 
3, 3.57126, 1, 0, 0.359537,-0.00728138) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.391929,0.0511463) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.515869,0.00676003) , 
10, 10.4286, 1, 0, 0.501899,0.00390427) , 
16, 0.702782, 1, 0, 0.471736,0.00153424) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.338034,0.0586028) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.475214,-0.104771) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.852219,-0.00818876) , 
11, 0.523549, 1, 0, 0.734963,-0.0145043) , 
18, 0.133087, 1, 0, 0.647667,-0.00776411) , 
16, 7.37982, 1, 0, 0.5,4.04059e-05)    );
  // itree = 21
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.160288,0.0973767) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.176525,0.00867452) , 
10, 19.6667, 1, 0, 0.168189,0.0120433) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.28521,-0.0791209) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.727523,-0.00346944) , 
11, 0.691341, 1, 0, 0.516203,-0.0134087) , 
11, 0.190396, 1, 0, 0.409659,-0.00561658) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.19026,0.00606303) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.270926,-0.095349) , 
18, 0.571429, 1, 0, 0.229617,-0.0157794) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.305779,-0.0480953) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.566732,0.0129326) , 
24, -0.00417243, 1, 0, 0.552584,0.00317496) , 
11, 0.0952026, 1, 0, 0.529877,0.00184233) , 
9, 0.238095, 1, 0, 0.5,-1.13968e-05)    );
  // itree = 22
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.237748,0.000699661) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.34565,0.122594) , 
1, 0.00235189, 1, 0, 0.273263,0.0138294) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.551982,-0.126368) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.765465,-0.0124386) , 
18, 0.333333, 1, 0, 0.737974,-0.00855951) , 
11, 0.190405, 1, 0, 0.64196,-0.00393371) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.122394,0.0352026) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.222058,-0.103383) , 
18, 0.142857, 1, 0, 0.165132,-0.0111812) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.586642,0.0634602) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.415714,0.00473882) , 
25, 0.0239967, 1, 0, 0.474169,0.00853958) , 
11, 0.1904, 1, 0, 0.386005,0.00291351) , 
25, 0.010119, 1, 0, 0.5,-0.000136048)    );
  // itree = 23
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.273377,0.0199758) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.689061,-0.0181124) , 
11, 0.618772, 1, 0, 0.461433,0.000541453) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.37612,-0.068197) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.640895,0.041529) , 
5, 1.85465, 1, 0, 0.476993,-0.008009) , 
12, 0.50428, 1, 0, 0.466618,-0.00230765) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.320677,-0.0519873) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.341161,0.0445873) , 
25, 0.0264394, 1, 0, 0.328693,-0.003607) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.733533,0.0896372) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.716665,-0.010282) , 
4, 0.439166, 1, 0, 0.724125,0.0108318) , 
18, 0.0454732, 1, 0, 0.594339,0.00609281) , 
10, 20.8571, 1, 0, 0.5,-0.000112057)    );
  // itree = 24
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.552475,-0.0155395) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.677953,0.0253433) , 
18, 0.47619, 1, 0, 0.624271,0.0028784) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.35816,-0.0331003) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.724898,0.00973864) , 
3, 7.55895, 1, 0, 0.438992,-0.007627) , 
21, 0.00436136, 1, 0, 0.546881,-0.00150964) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.16967,-0.0588077) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.717356,0.0832505) , 
11, 0.713869, 1, 0, 0.33265,-0.00182206) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.179131,0.143889) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.457125,-0.0429312) , 
11, 0.571199, 1, 0, 0.26719,0.0178335) , 
25, 0.0242857, 1, 0, 0.305223,0.00641359) , 
21, 0.0183186, 1, 0, 0.5,2.74456e-05)    );
  // itree = 25
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.433671,0.0434487) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.494446,-0.00652765) , 
8, 0.292511, 1, 0, 0.490045,-0.000829714) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.483432,0.0593868) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.793333,-0.0743402) , 
3, 10.0949, 1, 0, 0.55328,0.00924327) , 
8, 0.809524, 1, 0, 0.501564,0.00100523) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.414783,0.0391563) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.559973,-0.040756) , 
14, 4.31524, 1, 0, 0.468671,0.00377148) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.581126,-0.0273308) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.443873,-0.107003) , 
7, 0.654635, 1, 0, 0.514841,-0.0244326) , 
6, 0.0870744, 1, 0, 0.488966,-0.00862641) , 
9, 0.52381, 1, 0, 0.5,-0.000190467)    );
  // itree = 26
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.27665,-0.0616447) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.559448,0.108663) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.459534,0.00138534) , 
4, 0.289248, 1, 0, 0.486015,0.00955956) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.525626,0.00846367) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.488294,-0.0184914) , 
24, 0.000320845, 1, 0, 0.509279,-0.00108377) , 
4, 0.364308, 1, 0, 0.50576,0.000526042) , 
10, 6.95238, 1, 0, 0.5,1.92684e-05)    );
  // itree = 27
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.580944,-0.0530291) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.393812,-5.69951e-05) , 
0, 1.07182, 1, 0, 0.456278,-0.00549782) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.550752,0.0214679) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.612292,-0.0223922) , 
6, 0.14337, 1, 0, 0.562263,0.00395379) , 
24, -0.000962909, 1, 0, 0.529015,0.000988787) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.284594,0.0483218) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.291452,-0.0298027) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.291021,-0.0946252) , 
9, 0.333333, 1, 0, 0.291287,-0.0161428) , 
24, -0.00160492, 1, 0, 0.289264,-0.00719174) , 
21, 0.0274779, 1, 0, 0.5,-1.22397e-06)    );
  // itree = 28
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.373611,-0.0454296) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.60906,0.0174933) , 
24, -0.00261037, 1, 0, 0.588311,0.00378353) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.333452,-0.0756318) , 
24, 0.00288862, 1, 0, 0.57113,0.00196334) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.190328,0.0538415) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.395637,-0.0110715) , 
18, 0.0952381, 1, 0, 0.299306,0.00382912) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.374871,0.00800705) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.382376,-0.071643) , 
24, -0.0016054, 1, 0, 0.379633,-0.0147377) , 
10, 15.7143, 1, 0, 0.335674,-0.00457715) , 
25, 0.0263095, 1, 0, 0.5,-1.25048e-05)    );
  // itree = 29
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.352073,-0.0360728) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.345392,0.0859569) , 
26, 45.5773, 1, 0, 0.351478,-0.00703095) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.70239,0.043416) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.615354,-0.00301257) , 
7, 0.478958, 1, 0, 0.626635,0.000971927) , 
18, 0.380952, 1, 0, 0.532105,-0.00177746) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.183151,0.0101387) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.591077,0.0828755) , 
11, 0.523588, 1, 0, 0.344575,0.0139228) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.350847,-0.0332107) , 
9, 0.428571, 1, 0, 0.346032,0.00814693) , 
24, 0.00224642, 1, 0, 0.5,-6.51204e-05)    );
  // itree = 30
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.176577,0.0496169) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.388618,-0.0336062) , 
18, 0.0952381, 1, 0, 0.283991,-0.000545445) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.429874,0.058438) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.787019,-0.0352858) , 
11, 0.951982, 1, 0, 0.524757,0.0128008) , 
2, 0.0095201, 1, 0, 0.389905,0.00532559) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.305201,-0.040599) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.726705,-0.00135328) , 
11, 0.285608, 1, 0, 0.614514,-0.00409629) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.194667,0.0422364) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.660228,-0.0291949) , 
11, 0.618768, 1, 0, 0.362539,0.00354364) , 
21, 0.00913416, 1, 0, 0.533647,-0.0016444) , 
24, -0.00160489, 1, 0, 0.5,-1.2855e-05)    );
  // itree = 31
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.39689,0.0612326) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.34073,-0.0440092) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.865282,0.0309448) , 
11, 0.904254, 1, 0, 0.447161,-0.00904992) , 
12, 0.0840467, 1, 0, 0.439432,-0.00464355) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.444111,-0.0580423) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.468058,-0.000600176) , 
14, 0.929594, 1, 0, 0.463715,-0.00408076) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.516321,-0.0556165) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.627473,0.0471362) , 
8, 0.380952, 1, 0, 0.616151,0.0105422) , 
26, 19.7143, 1, 0, 0.524976,0.00179597) , 
6, 0.079849, 1, 0, 0.5,-8.41677e-05)    );
  // itree = 32
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.350616,-0.0256042) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.835012,0.017588) , 
11, 0.952026, 1, 0, 0.445337,-0.00525658) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.546855,0.0547062) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.585133,-0.00182071) , 
8, 0.593158, 1, 0, 0.571598,0.00663141) , 
6, 0.14337, 1, 0, 0.475244,-0.00244072) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.538211,0.0158727) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.611434,-0.0511459) , 
2, 0.0380775, 1, 0, 0.548377,0.00201697) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.682975,0.126969) , 
13, 0.462017, 1, 0, 0.562799,0.00618214) , 
18, 0.571429, 1, 0, 0.5,-2.64981e-06)    );
  // itree = 33
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.322916,-0.0284985) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.224931,0.0188258) , 
0, 1.66662, 1, 0, 0.287564,-0.003539) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.438559,0.0252798) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.601782,0.0790949) , 
18, 0.47619, 1, 0, 0.521563,0.0184893) , 
3, 1.87313, 1, 0, 0.357435,0.00303861) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.396609,0.0676961) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.669226,-0.0503255) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.772364,-0.000755608) , 
3, 7.6677, 1, 0, 0.730868,-0.00686158) , 
11, 0.285608, 1, 0, 0.702684,-0.0042432) , 
3, 3.92928, 1, 0, 0.5,3.17062e-05)    );
  // itree = 34
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.281718,0.0249306) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.755504,-0.034512) , 
11, 0.809158, 1, 0, 0.383781,0.00357768) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.323166,-0.0634997) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.729534,0.00760243) , 
11, 0.428412, 1, 0, 0.643889,-0.00285051) , 
1, 0.00476093, 1, 0, 0.504459,0.000595301) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.355369,-0.0557659) , 
7, 0.809524, 1, 0, 0.5,2.11789e-05)    );
  // itree = 35
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.323042,-0.0219823) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.655333,0.013867) , 
3, 3.79374, 1, 0, 0.469986,-0.00180374) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.384854,0.0396214) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.662369,-0.00986128) , 
1, 0.00474311, 1, 0, 0.507155,0.0053179) , 
14, 5.66207, 1, 0, 0.485446,0.00115835) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.574837,-0.0788854) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.602517,0.0211315) , 
14, 20.7625, 1, 0, 0.582089,-0.0135414) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.614538,0.0588179) , 
13, 0.76833, 1, 0, 0.588958,-0.00740102) , 
14, 13.2119, 1, 0, 0.5,-4.51409e-05)    );
  // itree = 36
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.2821,0.0637982) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.334676,0.042998) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.515691,-0.00152314) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.45105,-0.0430708) , 
7, 0.752985, 1, 0, 0.512743,-0.00110589) , 
10, 7.85714, 1, 0, 0.506368,-0.000569827) , 
11, 0.0476013, 1, 0, 0.5,-5.67937e-06)    );
  // itree = 37
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.217367,0.0404957) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.539119,-0.0486012) , 
11, 0.333185, 1, 0, 0.407238,-0.00649393) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.227088,-0.0287708) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.690808,0.0224752) , 
11, 0.285608, 1, 0, 0.53954,0.0019029) , 
26, 14.984, 1, 0, 0.499334,-0.00064885) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.512815,0.0415704) , 
26, 62.3301, 1, 0, 0.5,-1.77785e-05)    );
  // itree = 38
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.548871,-0.00759884) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.395152,0.0157822) , 
24, 0.0016046, 1, 0, 0.514038,-0.00071928) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.650123,-0.0499715) , 
10, 27.8095, 1, 0, 0.522344,-0.00149096) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.356433,0.0413908) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.236156,-0.0261917) , 
23, 0.0157485, 1, 0, 0.26792,-0.00212834) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.752212,0.0902967) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.732846,-0.0141152) , 
4, 0.479837, 1, 0, 0.743232,0.0141888) , 
11, 0.761586, 1, 0, 0.441776,0.00384003) , 
23, 0.00810078, 1, 0, 0.5,-1.25284e-05)    );
  // itree = 39
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.166301,-0.0270926) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.201,0.0669024) , 
15, 2.27266, 1, 0, 0.173453,-0.00183954) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.258728,0.0926158) , 
16, 5.30602, 1, 0, 0.195021,0.00538782) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.368746,-0.00176537) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.665356,0.125418) , 
11, 0.80334, 1, 0, 0.387835,0.00246876) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.673319,-0.151711) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.803316,0.00412705) , 
18, 0.047619, 1, 0, 0.787139,-0.00559077) , 
11, 0.836424, 1, 0, 0.561456,-0.00103561) , 
11, 0.142804, 1, 0, 0.5,4.1692e-05)    );
  // itree = 40
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.133972,-0.0245011) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.183683,0.0860068) , 
0, 2.02378, 1, 0, 0.143847,-1.67193e-05) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.319034,0.172196) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.678014,0.0066376) , 
11, 0.836461, 1, 0, 0.524739,0.027439) , 
11, 0.571187, 1, 0, 0.247825,0.00747829) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.657395,0.00488927) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.577741,-0.0250807) , 
24, 0.000961678, 1, 0, 0.635274,-0.00121376) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.296305,-0.102067) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.492546,-0.0153444) , 
2, 0.00952006, 1, 0, 0.427885,-0.0163987) , 
0, 1.90474, 1, 0, 0.609379,-0.00310972) , 
18, 0.142857, 1, 0, 0.5,9.34191e-05)    );
  // itree = 41
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.228492,-0.0122279) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.307377,0.0294457) , 
9, 0.333333, 1, 0, 0.264025,0.0023732) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.686671,-0.00937501) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.473318,-0.0916242) , 
21, 0.00913469, 1, 0, 0.624338,-0.0130843) , 
11, 0.559882, 1, 0, 0.37991,-0.00259829) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.788324,0.133515) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.768274,0.0247839) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.898125,-0.0963363) , 
26, 27.8466, 1, 0, 0.807481,0.00135765) , 
23, -0.0212067, 1, 0, 0.805554,0.00574918) , 
11, 0.904425, 1, 0, 0.5,-0.000243159)    );
  // itree = 42
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.550625,-0.00124524) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.75121,0.0735078) , 
18, 0.468679, 1, 0, 0.578688,0.00285628) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.579414,-0.00483567) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.602646,-0.0427002) , 
6, 0.10033, 1, 0, 0.587613,-0.00647543) , 
7, 0.52381, 1, 0, 0.583807,-0.00249587) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.245398,0.0142311) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.613921,0.0621816) , 
1, 0.00438593, 1, 0, 0.397186,0.010618) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.234758,-0.0188113) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.466574,0.0458568) , 
1, 0.0142831, 1, 0, 0.28219,-0.000982422) , 
0, 1.5472, 1, 0, 0.342526,0.00510413) , 
21, 0.00915932, 1, 0, 0.5,0.000143937)    );
  // itree = 43
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.332149,0.0149067) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.731421,0.0678926) , 
11, 0.856711, 1, 0, 0.443081,0.0105834) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.450622,-0.0294726) , 
15, 1.30184, 1, 0, 0.444772,0.00597298) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.284646,-0.0808597) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.368971,0.00739383) , 
6, 0.0506217, 1, 0, 0.364028,0.000920611) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.710237,-0.0313065) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.758021,0.020199) , 
15, 1.72844, 1, 0, 0.724693,-0.00500305) , 
3, 3.79909, 1, 0, 0.514867,-0.00155681) , 
12, 0.168093, 1, 0, 0.5,4.02352e-05)    );
  // itree = 44
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.45895,-0.0111022) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.594057,0.0180007) , 
26, 24.9495, 1, 0, 0.500248,-0.00108165) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.510053,0.0462837) , 
26, 62.3301, 1, 0, 0.500585,-0.000586416) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.623767,0.0180075) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.450751,-0.0335946) , 
7, 0.770281, 1, 0, 0.532944,-0.00332034) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.409312,0.0790484) , 
25, 0.0245895, 1, 0, 0.493793,0.00663973) , 
18, 0.714286, 1, 0, 0.5,3.5905e-05)    );
  // itree = 45
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.39907,0.00934008) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.588265,0.0346752) , 
2, 0.0285659, 1, 0, 0.439604,0.00495426) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.550865,0.0175417) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.603794,-0.0234826) , 
4, 0.384906, 1, 0, 0.590483,-0.00381432) , 
16, 3.68991, 1, 0, 0.503886,0.00121845) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.31696,-0.0145731) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.721764,-0.115866) , 
11, 0.666292, 1, 0, 0.471959,-0.0159758) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.447899,0.0432346) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.589912,-0.0371898) , 
10, 13.6667, 1, 0, 0.496554,0.00581595) , 
9, 0.478782, 1, 0, 0.484422,-0.0049329) , 
4, 0.615771, 1, 0, 0.5,-9.55525e-06)    );
  // itree = 46
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.27665,-0.0688546) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.525337,0.0068771) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.407048,-0.0398614) , 
4, 0.754717, 1, 0, 0.520867,0.00154399) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.32809,-0.000250958) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.326124,-0.0762383) , 
8, 0.714286, 1, 0, 0.327355,-0.0101717) , 
0, 2.14283, 1, 0, 0.50576,0.000629343) , 
10, 6.95238, 1, 0, 0.5,6.35924e-05)    );
  // itree = 47
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.277766,-0.0166333) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.156411,-0.0581049) , 
11, 0.0453226, 1, 0, 0.217114,-0.00976671) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.441228,0.0142349) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.798503,-0.0216054) , 
11, 0.95649, 1, 0, 0.509311,0.00275511) , 
11, 0.0951957, 1, 0, 0.485556,0.0017371) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.371417,0.0250958) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.649567,-0.0302862) , 
1, 0.00475624, 1, 0, 0.497383,-0.000173628) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.70362,3.18792e-05) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.515037,-0.103918) , 
0, 1.06908, 1, 0, 0.6246,-0.0134536) , 
10, 23.619, 1, 0, 0.52391,-0.00294269) , 
12, 0.50428, 1, 0, 0.5,-2.52879e-05)    );
  // itree = 48
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.264667,-0.00920438) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.496185,-0.0554544) , 
11, 0.612013, 1, 0, 0.282449,-0.00430727) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.423056,-0.0271463) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.350502,0.0686911) , 
0, 1.0693, 1, 0, 0.383898,0.00865444) , 
10, 24.3333, 1, 0, 0.29343,-0.00290433) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.735561,0.0391042) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.833477,-0.00694659) , 
10, 23.3333, 1, 0, 0.759818,0.00944574) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.74996,-0.0359996) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.743671,0.0354624) , 
23, 0.00410643, 1, 0, 0.74806,-0.00427996) , 
9, 0.378522, 1, 0, 0.754791,0.00357708) , 
11, 0.71402, 1, 0, 0.5,-2.33954e-06)    );
  // itree = 49
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.409267,0.00276316) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.517228,-0.0330272) , 
9, 0.292512, 1, 0, 0.450936,-0.00342223) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.659464,-0.00980801) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.351336,0.0576473) , 
25, 0.0101164, 1, 0, 0.478953,0.00891561) , 
9, 0.428571, 1, 0, 0.45473,-0.00175145) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.550349,-0.00279895) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.588518,0.0283973) , 
24, -0.000321072, 1, 0, 0.57253,0.00506907) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.62137,-0.0536098) , 
2, 0.0571161, 1, 0, 0.576502,0.00308913) , 
18, 0.52381, 1, 0, 0.5,4.80906e-05)    );
   return;
};
 
// Clean up
inline void Read50 Trees::Clear() 
{
   for (unsigned int itree=0; itree<fForest.size(); itree++) { 
      delete fForest[itree]; 
   }
}
   inline double Read50 Trees::GetMvaValue( const std::vector<double>& inputValues ) const
   {
      // classifier response value
      double retval = 0;

      // classifier response, sanity check first
      if (!IsStatusClean()) {
         std::cout << "Problem in class \"" << fClassName << "\": cannot return classifier response"
                   << " because status is dirty" << std::endl;
         retval = 0;
      }
      else {
         if (IsNormalised()) {
            // normalise variables
            std::vector<double> iV;
            iV.reserve(inputValues.size());
            int ivar = 0;
            for (std::vector<double>::const_iterator varIt = inputValues.begin();
                 varIt != inputValues.end(); varIt++, ivar++) {
               iV.push_back(NormVariable( *varIt, fVmin[ivar], fVmax[ivar] ));
            }
            retval = GetMvaValue__( iV );
         }
         else {
            retval = GetMvaValue__( inputValues );
         }
      }

      return retval;
   }
