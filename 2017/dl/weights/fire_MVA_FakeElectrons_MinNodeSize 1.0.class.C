// Class: ReadMinNodeSize 1.0
// Automatically generated by MethodBase::MakeClass
//

/* configuration options =====================================================

#GEN -*-*-*-*-*-*-*-*-*-*-*- general info -*-*-*-*-*-*-*-*-*-*-*-

Method         : BDT::MinNodeSize 1.0
TMVA Release   : 4.2.1         [262657]
ROOT Release   : 6.14/07       [396807]
Creator        : mchristos
Date           : Thu Nov 15 23:18:45 2018
Host           : Linux cmsbuild02.cern.ch 2.6.32-754.3.5.el6.x86_64 #1 SMP Wed Aug 15 08:57:36 CEST 2018 x86_64 x86_64 x86_64 GNU/Linux
Dir            : /cms/mchristos/ANN/FireMVA/2017
Training events: 70707
Analysis type  : [Classification]


#OPT -*-*-*-*-*-*-*-*-*-*-*-*- options -*-*-*-*-*-*-*-*-*-*-*-*-

# Set by User:
V: "False" [Verbose output (short form of "VerbosityLevel" below - overrides the latter one)]
H: "False" [Print method-specific help message]
NTrees: "50" [Number of trees in the forest]
MaxDepth: "3" [Max depth of the decision tree allowed]
MinNodeSize: "1.0%" [Minimum percentage of training events required in a leaf node (default: Classification: 5%, Regression: 0.2%)]
nCuts: "20" [Number of grid points in variable range used in finding optimal cut in node splitting]
BoostType: "Grad" [Boosting type for the trees in the forest (note: AdaCost is still experimental)]
Shrinkage: "1.000000e+00" [Learning rate for GradBoost algorithm]
# Default:
VerbosityLevel: "Default" [Verbosity level]
VarTransform: "None" [List of variable transformations performed before training, e.g., "D_Background,P_Signal,G,N_AllClasses" for: "Decorrelation, PCA-transformation, Gaussianisation, Normalisation, each for the given class of events ('AllClasses' denotes all events of all classes, if no class indication is given, 'All' is assumed)"]
CreateMVAPdfs: "False" [Create PDFs for classifier outputs (signal and background)]
IgnoreNegWeightsInTraining: "False" [Events with negative weights are ignored in the training (but are included for testing and performance evaluation)]
AdaBoostR2Loss: "quadratic" [Type of Loss function in AdaBoostR2]
UseBaggedBoost: "False" [Use only a random subsample of all events for growing the trees in each boost iteration.]
AdaBoostBeta: "5.000000e-01" [Learning rate  for AdaBoost algorithm]
UseRandomisedTrees: "False" [Determine at each node splitting the cut variable only as the best out of a random subset of variables (like in RandomForests)]
UseNvars: "5" [Size of the subset of variables used with RandomisedTree option]
UsePoissonNvars: "True" [Interpret "UseNvars" not as fixed number but as mean of a Poisson distribution in each split with RandomisedTree option]
BaggedSampleFraction: "6.000000e-01" [Relative size of bagged event sample to original size of the data sample (used whenever bagging is used (i.e. UseBaggedBoost, Bagging,)]
UseYesNoLeaf: "True" [Use Sig or Bkg categories, or the purity=S/(S+B) as classification of the leaf node -> Real-AdaBoost]
NegWeightTreatment: "pray" [How to treat events with negative weights in the BDT training (particular the boosting) : IgnoreInTraining;  Boost With inverse boostweight; Pair events with negative and positive weights in training sample and *annihilate* them (experimental!)]
Css: "1.000000e+00" [AdaCost: cost of true signal selected signal]
Cts_sb: "1.000000e+00" [AdaCost: cost of true signal selected bkg]
Ctb_ss: "1.000000e+00" [AdaCost: cost of true bkg    selected signal]
Cbb: "1.000000e+00" [AdaCost: cost of true bkg    selected bkg ]
NodePurityLimit: "5.000000e-01" [In boosting/pruning, nodes with purity > NodePurityLimit are signal; background otherwise.]
SeparationType: "giniindex" [Separation criterion for node splitting]
RegressionLossFunctionBDTG: "huber" [Loss function for BDTG regression.]
HuberQuantile: "7.000000e-01" [In the Huber loss function this is the quantile that separates the core from the tails in the residuals distribution.]
DoBoostMonitor: "False" [Create control plot with ROC integral vs tree number]
UseFisherCuts: "False" [Use multivariate splits using the Fisher criterion]
MinLinCorrForFisher: "8.000000e-01" [The minimum linear correlation between two variables demanded for use in Fisher criterion in node splitting]
UseExclusiveVars: "False" [Variables already used in fisher criterion are not anymore analysed individually for node splitting]
DoPreselection: "False" [and and apply automatic pre-selection for 100% efficient signal (bkg) cuts prior to training]
SigToBkgFraction: "1.000000e+00" [Sig to Bkg ratio used in Training (similar to NodePurityLimit, which cannot be used in real adaboost]
PruneMethod: "nopruning" [Note: for BDTs use small trees (e.g.MaxDepth=3) and NoPruning:  Pruning: Method used for pruning (removal) of statistically insignificant branches ]
PruneStrength: "0.000000e+00" [Pruning strength]
PruningValFraction: "5.000000e-01" [Fraction of events to use for optimizing automatic pruning.]
SkipNormalization: "False" [Skip normalization at initialization, to keep expectation value of BDT output according to the fraction of events]
nEventsMin: "0" [deprecated: Use MinNodeSize (in % of training events) instead]
UseBaggedGrad: "False" [deprecated: Use *UseBaggedBoost* instead:  Use only a random subsample of all events for growing the trees in each iteration.]
GradBaggingFraction: "6.000000e-01" [deprecated: Use *BaggedSampleFraction* instead: Defines the fraction of events to be used in each iteration, e.g. when UseBaggedGrad=kTRUE. ]
UseNTrainEvents: "0" [deprecated: Use *BaggedSampleFraction* instead: Number of randomly picked training events used in randomised (and bagged) trees]
NNodesMax: "0" [deprecated: Use MaxDepth instead to limit the tree size]
##


#VAR -*-*-*-*-*-*-*-*-*-*-*-* variables *-*-*-*-*-*-*-*-*-*-*-*-

NVar 27
abs(ElectronEta)              abs_ElectronEta_              abs(ElectronEta)              abs(ElectronEta)                                                'F'    [1.69258073583e-05,2.49997067451]
ElectronDXY                   ElectronDXY                   ElectronDXY                   ElectronDXY                                                     'F'    [6.64379129489e-08,0.0999782606959]
ElectronDZ                    ElectronDZ                    ElectronDZ                    ElectronDZ                                                      'F'    [4.06895367178e-07,0.199958592653]
ElectronSIP3D                 ElectronSIP3D                 ElectronSIP3D                 ElectronSIP3D                                                   'F'    [0.00396113377064,82.4355926514]
ElectronPtRatio               ElectronPtRatio               ElectronPtRatio               ElectronPtRatio                                                 'F'    [-1,3.24139928818]
ElectronPtRel                 ElectronPtRel                 ElectronPtRel                 ElectronPtRel                                                   'F'    [-1,970.202941895]
ElectronJetLRM                ElectronJetLRM                ElectronJetLRM                ElectronJetLRM                                                  'F'    [-1,0.33393111825]
ElectronJetFD                 ElectronJetFD                 ElectronJetFD                 ElectronJetFD                                                   'F'    [-1,1]
ElectronJetInOutRatio         ElectronJetInOutRatio         ElectronJetInOutRatio         ElectronJetInOutRatio                                           'F'    [-9999,1]
ElectronJetZest               ElectronJetZest               ElectronJetZest               ElectronJetZest                                                 'F'    [-1,1]
ElectronJetNoOfConst          ElectronJetNoOfConst          ElectronJetNoOfConst          ElectronJetNoOfConst                                            'F'    [0,73]
ElectronJetCSV                ElectronJetCSV                ElectronJetCSV                ElectronJetCSV                                                  'F'    [0,0.999627411366]
ElectronRelPFIsoPUCorr        ElectronRelPFIsoPUCorr        ElectronRelPFIsoPUCorr        ElectronRelPFIsoPUCorr                                          'F'    [0,1.76498115063]
ElectronRelTrkIso             ElectronRelTrkIso             ElectronRelTrkIso             ElectronRelTrkIso                                               'F'    [0,61.5004081726]
ElectronPFChargedHadronIso    ElectronPFChargedHadronIso    ElectronPFChargedHadronIso    ElectronPFChargedHadronIso                                      'F'    [0,92.4835739136]
ElectronPFNeutralHadronIso    ElectronPFNeutralHadronIso    ElectronPFNeutralHadronIso    ElectronPFNeutralHadronIso                                      'F'    [0,36.2971611023]
ElectronPFPhotonIso           ElectronPFPhotonIso           ElectronPFPhotonIso           ElectronPFPhotonIso                                             'F'    [0,77.488067627]
ElectronJetMuonEnergyFraction ElectronJetMuonEnergyFraction ElectronJetMuonEnergyFraction ElectronJetMuonEnergyFraction                                   'F'    [0,1]
ElectronJetElectronEnergyFraction ElectronJetElectronEnergyFraction ElectronJetElectronEnergyFraction ElectronJetElectronEnergyFraction                                       'F'    [0,1]
ElectronMissingHits           ElectronMissingHits           ElectronMissingHits           ElectronMissingHits                                             'F'    [0,1]
ElectronPassConversionVeto    ElectronPassConversionVeto    ElectronPassConversionVeto    ElectronPassConversionVeto                                      'F'    [1,1]
ElectronEInverseMinusPInverse ElectronEInverseMinusPInverse ElectronEInverseMinusPInverse ElectronEInverseMinusPInverse                                   'F'    [1.45857645961e-08,0.192345529795]
ElectronHoE                   ElectronHoE                   ElectronHoE                   ElectronHoE                                                     'F'    [0,1.74987196922]
ElectronDeltaPhiTrkSC         ElectronDeltaPhiTrkSC         ElectronDeltaPhiTrkSC         ElectronDeltaPhiTrkSC                                           'F'    [-0.168498814106,0.168645858765]
ElectronDeltaEtaTrkSeedSC     ElectronDeltaEtaTrkSeedSC     ElectronDeltaEtaTrkSeedSC     ElectronDeltaEtaTrkSeedSC                                       'F'    [-0.00673997402191,0.00673961639404]
ElectronFull5x5SigmaIEtaIEta  ElectronFull5x5SigmaIEtaIEta  ElectronFull5x5SigmaIEtaIEta  ElectronFull5x5SigmaIEtaIEta                                    'F'    [0,0.0424999594688]
ElectronPt                    ElectronPt                    ElectronPt                    ElectronPt                                                      'F'    [10.0002174377,1108.92687988]
NSpec 0


============================================================================ */

#include <array>
#include <vector>
#include <cmath>
#include <string>
#include <iostream>

#define NN new MinNodeSize 1.0Node
   
#ifndef MinNodeSize 1.0Node__def
#define MinNodeSize 1.0Node__def
   
class MinNodeSize 1.0Node {
   
public:
   
   // constructor of an essentially "empty" node floating in space
   MinNodeSize 1.0Node ( MinNodeSize 1.0Node* left,MinNodeSize 1.0Node* right,
                          int selector, double cutValue, bool cutType, 
                          int nodeType, double purity, double response ) :
   fLeft         ( left         ),
   fRight        ( right        ),
   fSelector     ( selector     ),
   fCutValue     ( cutValue     ),
   fCutType      ( cutType      ),
   fNodeType     ( nodeType     ),
   fPurity       ( purity       ),
   fResponse     ( response     ){
   }

   virtual ~MinNodeSize 1.0Node();

   // test event if it descends the tree at this node to the right
   virtual bool GoesRight( const std::vector<double>& inputValues ) const;
   MinNodeSize 1.0Node* GetRight( void )  {return fRight; };

   // test event if it descends the tree at this node to the left 
   virtual bool GoesLeft ( const std::vector<double>& inputValues ) const;
   MinNodeSize 1.0Node* GetLeft( void ) { return fLeft; };   

   // return  S/(S+B) (purity) at this node (from  training)

   double GetPurity( void ) const { return fPurity; } 
   // return the node type
   int    GetNodeType( void ) const { return fNodeType; }
   double GetResponse(void) const {return fResponse;}

private:

   MinNodeSize 1.0Node*   fLeft;     // pointer to the left daughter node
   MinNodeSize 1.0Node*   fRight;    // pointer to the right daughter node
   int                     fSelector; // index of variable used in node selection (decision tree)   
   double                  fCutValue; // cut value applied on this node to discriminate bkg against sig
   bool                    fCutType;  // true: if event variable > cutValue ==> signal , false otherwise
   int                     fNodeType; // Type of node: -1 == Bkg-leaf, 1 == Signal-leaf, 0 = internal 
   double                  fPurity;   // Purity of node from training
   double                  fResponse; // Regression response value of node
}; 
   
//_______________________________________________________________________
   MinNodeSize 1.0Node::~MinNodeSize 1.0Node()
{
   if (fLeft  != NULL) delete fLeft;
   if (fRight != NULL) delete fRight;
}; 
   
//_______________________________________________________________________
bool MinNodeSize 1.0Node::GoesRight( const std::vector<double>& inputValues ) const
{
   // test event if it descends the tree at this node to the right
   bool result;
     result = (inputValues[fSelector] > fCutValue );
   if (fCutType == true) return result; //the cuts are selecting Signal ;
   else return !result;
}
   
//_______________________________________________________________________
bool MinNodeSize 1.0Node::GoesLeft( const std::vector<double>& inputValues ) const
{
   // test event if it descends the tree at this node to the left
   if (!this->GoesRight(inputValues)) return true;
   else return false;
}
   
#endif
   
#ifndef IClassifierReader__def
#define IClassifierReader__def

class IClassifierReader {

 public:

   // constructor
   IClassifierReader() : fStatusIsClean( true ) {}
   virtual ~IClassifierReader() {}

   // return classifier response
   virtual double GetMvaValue( const std::vector<double>& inputValues ) const = 0;

   // returns classifier status
   bool IsStatusClean() const { return fStatusIsClean; }

 protected:

   bool fStatusIsClean;
};

#endif

class ReadMinNodeSize 1.0 : public IClassifierReader {

 public:

   // constructor
   ReadMinNodeSize 1.0( std::vector<std::string>& theInputVars )
      : IClassifierReader(),
        fClassName( "ReadMinNodeSize 1.0" ),
        fNvars( 27 ),
        fIsNormalised( false )
   {
      // the training input variables
      const char* inputVars[] = { "abs(ElectronEta)", "ElectronDXY", "ElectronDZ", "ElectronSIP3D", "ElectronPtRatio", "ElectronPtRel", "ElectronJetLRM", "ElectronJetFD", "ElectronJetInOutRatio", "ElectronJetZest", "ElectronJetNoOfConst", "ElectronJetCSV", "ElectronRelPFIsoPUCorr", "ElectronRelTrkIso", "ElectronPFChargedHadronIso", "ElectronPFNeutralHadronIso", "ElectronPFPhotonIso", "ElectronJetMuonEnergyFraction", "ElectronJetElectronEnergyFraction", "ElectronMissingHits", "ElectronPassConversionVeto", "ElectronEInverseMinusPInverse", "ElectronHoE", "ElectronDeltaPhiTrkSC", "ElectronDeltaEtaTrkSeedSC", "ElectronFull5x5SigmaIEtaIEta", "ElectronPt" };

      // sanity checks
      if (theInputVars.size() <= 0) {
         std::cout << "Problem in class \"" << fClassName << "\": empty input vector" << std::endl;
         fStatusIsClean = false;
      }

      if (theInputVars.size() != fNvars) {
         std::cout << "Problem in class \"" << fClassName << "\": mismatch in number of input values: "
                   << theInputVars.size() << " != " << fNvars << std::endl;
         fStatusIsClean = false;
      }

      // validate input variables
      for (size_t ivar = 0; ivar < theInputVars.size(); ivar++) {
         if (theInputVars[ivar] != inputVars[ivar]) {
            std::cout << "Problem in class \"" << fClassName << "\": mismatch in input variable names" << std::endl
                      << " for variable [" << ivar << "]: " << theInputVars[ivar].c_str() << " != " << inputVars[ivar] << std::endl;
            fStatusIsClean = false;
         }
      }

      // initialize min and max vectors (for normalisation)
      fVmin[0] = 0;
      fVmax[0] = 0;
      fVmin[1] = 0;
      fVmax[1] = 0;
      fVmin[2] = 0;
      fVmax[2] = 0;
      fVmin[3] = 0;
      fVmax[3] = 0;
      fVmin[4] = 0;
      fVmax[4] = 0;
      fVmin[5] = 0;
      fVmax[5] = 0;
      fVmin[6] = 0;
      fVmax[6] = 0;
      fVmin[7] = 0;
      fVmax[7] = 0;
      fVmin[8] = 0;
      fVmax[8] = 0;
      fVmin[9] = 0;
      fVmax[9] = 0;
      fVmin[10] = 0;
      fVmax[10] = 0;
      fVmin[11] = 0;
      fVmax[11] = 0;
      fVmin[12] = 0;
      fVmax[12] = 0;
      fVmin[13] = 0;
      fVmax[13] = 0;
      fVmin[14] = 0;
      fVmax[14] = 0;
      fVmin[15] = 0;
      fVmax[15] = 0;
      fVmin[16] = 0;
      fVmax[16] = 0;
      fVmin[17] = 0;
      fVmax[17] = 0;
      fVmin[18] = 0;
      fVmax[18] = 0;
      fVmin[19] = 0;
      fVmax[19] = 0;
      fVmin[20] = 0;
      fVmax[20] = 0;
      fVmin[21] = 0;
      fVmax[21] = 0;
      fVmin[22] = 0;
      fVmax[22] = 0;
      fVmin[23] = 0;
      fVmax[23] = 0;
      fVmin[24] = 0;
      fVmax[24] = 0;
      fVmin[25] = 0;
      fVmax[25] = 0;
      fVmin[26] = 0;
      fVmax[26] = 0;

      // initialize input variable types
      fType[0] = 'F';
      fType[1] = 'F';
      fType[2] = 'F';
      fType[3] = 'F';
      fType[4] = 'F';
      fType[5] = 'F';
      fType[6] = 'F';
      fType[7] = 'F';
      fType[8] = 'F';
      fType[9] = 'F';
      fType[10] = 'F';
      fType[11] = 'F';
      fType[12] = 'F';
      fType[13] = 'F';
      fType[14] = 'F';
      fType[15] = 'F';
      fType[16] = 'F';
      fType[17] = 'F';
      fType[18] = 'F';
      fType[19] = 'F';
      fType[20] = 'F';
      fType[21] = 'F';
      fType[22] = 'F';
      fType[23] = 'F';
      fType[24] = 'F';
      fType[25] = 'F';
      fType[26] = 'F';

      // initialize constants
      Initialize();

   }

   // destructor
   virtual ~ReadMinNodeSize 1.0() {
      Clear(); // method-specific
   }

   // the classifier response
   // "inputValues" is a vector of input values in the same order as the
   // variables given to the constructor
   double GetMvaValue( const std::vector<double>& inputValues ) const override;

 private:

   // method-specific destructor
   void Clear();

   // common member variables
   const char* fClassName;

   const size_t fNvars;
   size_t GetNvar()           const { return fNvars; }
   char   GetType( int ivar ) const { return fType[ivar]; }

   // normalisation of input variables
   const bool fIsNormalised;
   bool IsNormalised() const { return fIsNormalised; }
   double fVmin[27];
   double fVmax[27];
   double NormVariable( double x, double xmin, double xmax ) const {
      // normalise to output range: [-1, 1]
      return 2*(x - xmin)/(xmax - xmin) - 1.0;
   }

   // type of input variable: 'F' or 'I'
   char   fType[27];

   // initialize internal variables
   void Initialize();
   double GetMvaValue__( const std::vector<double>& inputValues ) const;

   // private members (method specific)
   std::vector<MinNodeSize 1.0Node*> fForest;       // i.e. root nodes of decision trees
   std::vector<double>                fBoostWeights; // the weights applied in the individual boosts
};

double ReadMinNodeSize 1.0::GetMvaValue__( const std::vector<double>& inputValues ) const
{
   double myMVA = 0;
   for (unsigned int itree=0; itree<fForest.size(); itree++){
      MinNodeSize 1.0Node *current = fForest[itree];
      while (current->GetNodeType() == 0) { //intermediate node
         if (current->GoesRight(inputValues)) current=(MinNodeSize 1.0Node*)current->GetRight();
         else current=(MinNodeSize 1.0Node*)current->GetLeft();
      }
      myMVA += current->GetResponse();
   }
   return 2.0/(1.0+exp(-2.0*myMVA))-1.0;
};

void ReadMinNodeSize 1.0::Initialize()
{
  // itree = 0
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.119276,-0.761448) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.183056,-0.633887) , 
11, 0.206248, 1, 0, 0.147473,-0.352527) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.448616,-0.102768) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.244828,-0.510344) , 
21, 0.00914059, 1, 0, 0.376342,-0.123658) , 
18, 0.142857, 1, 0, 0.275057,-0.224943) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.329746,-0.340509) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.664821,0.329641) , 
18, 0.188238, 1, 0, 0.587184,0.0871845) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.746132,0.492263) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.882889,0.765778) , 
26, 27.8466, 1, 0, 0.78713,0.28713) , 
11, 0.836436, 1, 0, 0.73519,0.23519) , 
11, 0.618817, 1, 0, 0.5,-4.0518e-16)    );
  // itree = 1
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.248945,-0.189443) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.421517,0.197967) , 
1, 0.00470369, 1, 0, 0.273263,-0.0550754) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.638415,0.00525118) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.759865,0.268853) , 
10, 12.1429, 1, 0, 0.737974,0.0867093) , 
11, 0.190405, 1, 0, 0.64196,0.057415) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.238405,-0.283161) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.312446,-0.103876) , 
10, 16.2857, 1, 0, 0.268937,-0.0802768) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.563561,-0.0450111) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.728087,0.242721) , 
16, 5.30602, 1, 0, 0.602201,0.00820401) , 
3, 3.92928, 1, 0, 0.386005,-0.0491956) , 
25, 0.010119, 1, 0, 0.5,-0.0017143)    );
  // itree = 2
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.507036,-0.0136244) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.273548,-0.15879) , 
21, 0.0183186, 1, 0, 0.46036,-0.0140923) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.598201,0.131523) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.826145,0.416979) , 
26, 24.2733, 1, 0, 0.661725,0.0731682) , 
17, 0.047619, 1, 0, 0.471736,-0.00916266) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.304658,-0.095407) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.379008,0.144546) , 
25, 0.0118397, 1, 0, 0.333777,0.000473366) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.65736,0.0666077) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.784356,0.271498) , 
5, 2.02505, 1, 0, 0.733456,0.063301) , 
18, 0.0443624, 1, 0, 0.647667,0.0498155) , 
16, 7.37982, 1, 0, 0.5,0.00031252)    );
  // itree = 3
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.260019,-0.215275) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.402632,-0.09714) , 
5, 1.7385, 1, 0, 0.321557,-0.0590531) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.267003,0.0306277) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.713123,-0.0557966) , 
11, 0.618817, 1, 0, 0.481743,-0.00395212) , 
10, 8.57143, 1, 0, 0.466618,-0.00915497) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.483661,0.00633222) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.541649,0.11717) , 
10, 25.9524, 1, 0, 0.505859,0.0162061) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.657602,0.430862) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.862293,0.132269) , 
11, 0.713984, 1, 0, 0.830684,0.0576637) , 
3, 7.56403, 1, 0, 0.594339,0.0274989) , 
10, 20.8571, 1, 0, 0.5,0.000425091)    );
  // itree = 4
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.157054,-0.156252) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.596752,0.0872158) , 
18, 0.0459516, 1, 0, 0.493439,0.0155662) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.646063,0.150643) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.329761,-0.0804581) , 
25, 0.00809523, 1, 0, 0.34293,-0.0236082) , 
0, 0.595261, 1, 0, 0.380118,-0.013929) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.303423,0.066713) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.553146,0.269269) , 
3, 6.82455, 1, 0, 0.361405,0.0441816) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.722608,-0.0343371) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.834483,0.136817) , 
14, 8.63049, 1, 0, 0.758375,0.00466163) , 
11, 0.618817, 1, 0, 0.639388,0.0165072) , 
1, 0.00476093, 1, 0, 0.5,0.000144164)    );
  // itree = 5
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.123834,-0.1008) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.144713,0.0798257) , 
0, 1.66461, 1, 0, 0.131299,-0.00869352) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.230764,-0.166004) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.493045,0.103609) , 
3, 2.82312, 1, 0, 0.267804,-0.0488224) , 
18, 0.428571, 1, 0, 0.195021,-0.0274261) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.699104,-0.0558551) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.41401,0.024476) , 
25, 0.010119, 1, 0, 0.534925,-0.00266119) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.547843,-0.00557924) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.689915,0.133323) , 
13, 0.154006, 1, 0, 0.630358,0.0267162) , 
18, 0.571429, 1, 0, 0.561456,0.00550602) , 
11, 0.142804, 1, 0, 0.5,-1.71475e-05)    );
  // itree = 6
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.317199,-0.0825879) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.789786,0.055401) , 
11, 0.951998, 1, 0, 0.389905,-0.0201305) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.619248,0.0627124) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.334328,-0.0773365) , 
25, 0.0303571, 1, 0, 0.588201,0.0156894) , 
24, -0.00160496, 1, 0, 0.532105,0.00555631) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.199098,-0.00216867) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.499904,-0.101898) , 
3, 3.38174, 1, 0, 0.289399,-0.0114083) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.337657,-0.17014) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.768998,0.0178509) , 
11, 0.904262, 1, 0, 0.428568,-0.0504652) , 
18, 0.428571, 1, 0, 0.346032,-0.0273018) , 
24, 0.00224642, 1, 0, 0.5,-0.000112995)    );
  // itree = 7
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.230766,-0.0237228) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.326751,0.0849103) , 
6, 0.134009, 1, 0, 0.24779,-0.000664306) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.391329,0.116768) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.555451,0.351647) , 
26, 37.5562, 1, 0, 0.418861,0.0578034) , 
11, 0.44197, 1, 0, 0.275057,0.00865492) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.679634,-0.050959) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.646497,-0.256332) , 
6, 0.173424, 1, 0, 0.67551,-0.0272719) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.803044,0.0304039) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.674967,-0.0580522) , 
21, 0.00905118, 1, 0, 0.772428,0.0020109) , 
14, 4.31524, 1, 0, 0.73519,-0.00924022) , 
11, 0.618817, 1, 0, 0.5,-9.33906e-05)    );
  // itree = 8
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.691205,0.0222783) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.5866,-0.0729505) , 
25, 0.00915508, 1, 0, 0.645552,-0.00614926) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.319255,0.00824343) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.787463,0.122185) , 
11, 0.951998, 1, 0, 0.389035,0.00876524) , 
25, 0.010119, 1, 0, 0.502722,0.00215519) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.193656,-0.00140719) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.397714,-0.170317) , 
18, 0.238095, 1, 0, 0.343357,-0.046891) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.818635,0.0407173) , 
11, 0.904251, 1, 0, 0.455453,-0.0330564) , 
19, 0.047619, 1, 0, 0.5,0.000127337)    );
  // itree = 9
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.486873,-0.01182) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.608326,0.0929177) , 
14, 17.6159, 1, 0, 0.495524,-0.00174804) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.73515,0.250668) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.505493,0.0437446) , 
7, 0.654464, 1, 0, 0.523384,0.0207239) , 
18, 0.666667, 1, 0, 0.499344,0.00133364) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.538196,-0.168495) , 
2, 0.123784, 1, 0, 0.5,0.000214602)    );
  // itree = 10
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.544722,0.258361) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.466715,-0.00259489) , 
4, 0.241139, 1, 0, 0.467752,0.000328965) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.489849,-0.137173) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.672376,-0.00671942) , 
3, 12.7296, 1, 0, 0.528594,-0.040984) , 
2, 0.04759, 1, 0, 0.471489,-0.00220901) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.79977,0.260862) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.817063,0.0646421) , 
12, 0.684011, 1, 0, 0.807604,0.0568499) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.652906,0.104783) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.812722,-0.0248766) , 
11, 0.856824, 1, 0, 0.765131,0.00732724) , 
4, 0.4138, 1, 0, 0.778179,0.0225403) , 
3, 15.7052, 1, 0, 0.5,9.17449e-05)    );
  // itree = 11
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.322916,-0.0525992) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.224931,0.0566497) , 
0, 1.66662, 1, 0, 0.287564,-0.00486825) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.662807,0.0249111) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.404121,0.130675) , 
25, 0.0101158, 1, 0, 0.521563,0.0290462) , 
3, 1.87313, 1, 0, 0.357435,0.00525854) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.62195,-0.0790116) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.745594,-0.00840549) , 
3, 7.6677, 1, 0, 0.693936,-0.0127929) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.723893,0.139265) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.799273,0.0305305) , 
10, 20, 1, 0, 0.7592,0.0301827) , 
15, 3.45687, 1, 0, 0.702684,-0.00703268) , 
3, 3.92928, 1, 0, 0.5,0.000183082)    );
  // itree = 12
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.761033,0.104326) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.568222,-0.00110364) , 
21, 0.00261111, 1, 0, 0.658883,0.0151283) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.210692,-0.123694) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.656614,0.0558666) , 
1, 0.00951879, 1, 0, 0.30946,-0.0203001) , 
21, 0.0274222, 1, 0, 0.616628,0.0108441) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.396215,-0.0210187) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.459843,0.0685844) , 
26, 41.0931, 1, 0, 0.402866,-0.00404853) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.604695,-0.0618331) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.444328,-0.222455) , 
25, 0.0323706, 1, 0, 0.568443,-0.0315501) , 
16, 7.37982, 1, 0, 0.422649,-0.00733436) , 
0, 0.95238, 1, 0, 0.5,-8.55302e-05)    );
  // itree = 13
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.42679,0.0465932) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.446018,-0.0315194) , 
4, 0.50763, 1, 0, 0.439093,-0.00119391) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.348612,-0.101685) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.594087,0.0276984) , 
5, 1.85465, 1, 0, 0.438465,-0.0166639) , 
12, 0.492903, 1, 0, 0.438905,-0.00583556) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.546723,0.0346892) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.54361,-0.0310518) , 
8, 0.464844, 1, 0, 0.544756,-0.0018813) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.435871,0.064322) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.850667,0.018399) , 
11, 0.856798, 1, 0, 0.612593,0.0141136) , 
8, 0.619048, 1, 0, 0.590851,0.0089872) , 
16, 3.68991, 1, 0, 0.5,0.000124441)    );
  // itree = 14
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.661802,0.0357052) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.490469,-0.0255917) , 
21, 0.00174455, 1, 0, 0.546502,-0.00194502) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.228074,-0.04197) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.321247,0.0544915) , 
6, 0.0653428, 1, 0, 0.303654,0.0107627) , 
21, 0.0183186, 1, 0, 0.499757,0.000501052) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.521939,-0.140608) , 
1, 0.0571305, 1, 0, 0.5,-7.64798e-05)    );
  // itree = 15
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.216291,0.0136897) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.365454,0.172562) , 
10, 10.3333, 1, 0, 0.281459,0.0261624) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.50384,-0.00349912) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.278373,-0.0933272) , 
25, 0.0404762, 1, 0, 0.49867,-0.00176617) , 
11, 0.0476013, 1, 0, 0.492332,-0.000951231) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.563256,0.22755) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.819332,0.0819738) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.811513,-0.0756865) , 
11, 0.963356, 1, 0, 0.815355,0.00173498) , 
11, 0.809182, 1, 0, 0.73459,0.0287937) , 
17, 0.0952381, 1, 0, 0.5,-9.75033e-06)    );
  // itree = 16
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.341448,0.0294291) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.797131,-0.0212011) , 
11, 0.618703, 1, 0, 0.611176,0.000416846) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.470341,-0.0792185) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.773541,0.0310487) , 
2, 0.0328218, 1, 0, 0.518212,-0.020622) , 
0, 1.15389, 1, 0, 0.593035,-0.00368876) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.601816,0.142264) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.365797,0.00533298) , 
21, 0.0052515, 1, 0, 0.489256,0.0282777) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.291898,-0.00187905) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.762855,0.0605096) , 
11, 0.951998, 1, 0, 0.350429,0.00217229) , 
25, 0.0237098, 1, 0, 0.366615,0.00521599) , 
25, 0.0141667, 1, 0, 0.5,-2.98342e-05)    );
  // itree = 17
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.350456,0.0870501) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.366695,-0.0605203) , 
23, -0.00942571, 1, 0, 0.362887,-0.00909255) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.495295,0.0449038) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.535147,-0.000426762) , 
4, 0.364308, 1, 0, 0.528505,0.0022403) , 
10, 10.4286, 1, 0, 0.50381,0.000550478) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.266543,-0.111077) , 
21, 0.0732745, 1, 0, 0.5,5.18215e-05)    );
  // itree = 18
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.501598,0.0380655) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.462564,-0.00708473) , 
4, 0.658394, 1, 0, 0.489384,0.00797284) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.258133,0.0421668) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.372935,-0.0900629) , 
18, 0.0952381, 1, 0, 0.323423,-0.0150558) , 
0, 2.14284, 1, 0, 0.470823,0.00539741) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.404802,-0.0779721) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.497709,0.00638952) , 
26, 14.5661, 1, 0, 0.451086,-0.0119645) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.530727,-0.0513993) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.652009,0.0555965) , 
6, 0.0779699, 1, 0, 0.612265,0.00587164) , 
26, 20.6543, 1, 0, 0.52188,-0.00413039) , 
12, 0.336187, 1, 0, 0.5,-4.72806e-05)    );
  // itree = 19
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.339619,-0.079342) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.602912,-0.0101862) , 
24, -0.00352725, 1, 0, 0.58491,-0.00481158) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.425603,0.106042) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.33851,0.00821568) , 
4, 0.313955, 1, 0, 0.345808,0.00501212) , 
21, 0.00915969, 1, 0, 0.500585,-0.00134701) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.353217,-0.0284961) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.540489,0.0648042) , 
2, 0.00946917, 1, 0, 0.430228,0.00426746) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.642206,0.192926) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.607896,0.0302368) , 
14, 3.36754, 1, 0, 0.622434,0.0344002) , 
13, 0.153958, 1, 0, 0.493793,0.0142326) , 
18, 0.714286, 1, 0, 0.5,-5.27712e-06)    );
  // itree = 20
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.426903,0.0325537) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.197243,-0.0849436) , 
23, 0.0412871, 1, 0, 0.410714,0.00783899) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.299301,-0.0931739) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.698805,0.000116224) , 
11, 0.1904, 1, 0, 0.664221,-0.00272514) , 
1, 0.00476096, 1, 0, 0.531027,0.00282531) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.56987,0.106081) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.532768,-0.0926718) , 
0, 0.113388, 1, 0, 0.539071,-0.0175541) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.411082,-0.00374269) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.405771,-0.0992949) , 
12, 0.882789, 1, 0, 0.410746,-0.00308728) , 
0, 0.595144, 1, 0, 0.435569,-0.00588571) , 
24, 0.000962649, 1, 0, 0.5,-6.05861e-06)    );
  // itree = 21
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.162464,0.0296271) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.494101,-0.0323295) , 
11, 0.190396, 1, 0, 0.38894,-0.0050961) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.450802,-0.0153861) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.554675,0.0184719) , 
24, -0.000963007, 1, 0, 0.522028,0.00253388) , 
9, 0.238095, 1, 0, 0.491537,0.000785797) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.50448,0.0168423) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.729913,-0.0763558) , 
2, 0.00942218, 1, 0, 0.597453,-0.00521525) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.718949,-0.144551) , 
9, 0.326168, 1, 0, 0.623708,-0.0120823) , 
10, 27.8095, 1, 0, 0.5,-3.8176e-05)    );
  // itree = 22
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.215141,-0.00672171) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.626382,-0.0641159) , 
11, 0.666388, 1, 0, 0.36903,-0.0103456) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.506897,0.0130568) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.640441,-0.0226625) , 
16, 7.57239, 1, 0, 0.531009,0.00232028) , 
16, 0.878547, 1, 0, 0.496784,-0.000355915) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.746452,0.11645) , 
16, 18.4495, 1, 0, 0.5,2.92655e-05)    );
  // itree = 23
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.176577,0.0557387) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.388618,-0.0375272) , 
18, 0.0952381, 1, 0, 0.283991,-0.000661576) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.493849,0.0606504) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.62873,-0.0343321) , 
10, 20.8571, 1, 0, 0.524757,0.0142658) , 
2, 0.0095201, 1, 0, 0.389905,0.00590501) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.230017,-0.0582653) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.577467,0.00329736) , 
11, 0.0952026, 1, 0, 0.553322,-0.000214989) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.144406,-0.123326) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.622131,0.0113489) , 
11, 0.666312, 1, 0, 0.27888,-0.0215563) , 
21, 0.0365366, 1, 0, 0.533647,-0.00174493) , 
24, -0.00160489, 1, 0, 0.5,4.57768e-05)    );
  // itree = 24
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.634954,0.0942878) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.355293,-0.0011354) , 
25, 0.00809351, 1, 0, 0.367618,0.00117005) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.686485,-0.155902) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.809824,-0.0100642) , 
18, 0.0952381, 1, 0, 0.796521,-0.00836445) , 
11, 0.856824, 1, 0, 0.522344,-0.0022695) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.462908,0.0333656) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.399675,-0.0244095) , 
4, 0.630092, 1, 0, 0.452232,0.0074618) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.272489,-0.0864261) , 
24, 0.00481239, 1, 0, 0.441776,0.00544357) , 
23, 0.00810078, 1, 0, 0.5,-0.000130458)    );
  // itree = 25
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.243631,-0.0364912) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.303452,0.0238536) , 
14, 8.80796, 1, 0, 0.262586,-0.00514975) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.606192,0.00778521) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.323733,-0.0858689) , 
23, 0.0722221, 1, 0, 0.599068,0.00179747) , 
3, 1.31225, 1, 0, 0.49318,-0.000388756) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.705513,-0.0150628) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.849242,0.154226) , 
14, 3.95436, 1, 0, 0.78673,0.0202192) , 
3, 27.4812, 1, 0, 0.5,8.99991e-05)    );
  // itree = 26
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.580579,-0.00858515) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.695698,0.0507932) , 
26, 45.5781, 1, 0, 0.592013,-0.0011745) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.224802,-0.181028) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.684638,0.0380804) , 
11, 0.618739, 1, 0, 0.425813,-0.0275665) , 
23, 0.0267506, 1, 0, 0.583807,-0.00247764) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.143909,0.121462) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.167822,0.0103862) , 
10, 16.8571, 1, 0, 0.154625,0.0143168) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.360284,-0.0307318) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.784534,0.0706423) , 
11, 0.927068, 1, 0, 0.469955,-0.00191167) , 
11, 0.237999, 1, 0, 0.342526,0.00464647) , 
21, 0.00915932, 1, 0, 0.5,-3.13354e-06)    );
  // itree = 27
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.443251,-0.00439043) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.720338,0.116014) , 
5, 4.40856, 1, 0, 0.458545,0.000566913) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.549368,0.0292854) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.513246,0.138853) , 
22, 0.0559037, 1, 0, 0.533175,0.0231847) , 
8, 0.809524, 1, 0, 0.473501,0.00509952) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.236359,-0.0200339) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.507565,0.0239171) , 
11, 0.285606, 1, 0, 0.368397,0.00112276) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.664961,-0.121231) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.808314,-0.0188363) , 
18, 0.380952, 1, 0, 0.794843,-0.00883759) , 
11, 0.856824, 1, 0, 0.510037,-0.00218548) , 
4, 0.4138, 1, 0, 0.5,-0.00018416)    );
  // itree = 28
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.256652,-0.016226) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.746945,0.0245344) , 
11, 0.71402, 1, 0, 0.477704,0.000888006) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.397455,0.0610707) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.387735,0.16934) , 
25, 0.0240474, 1, 0, 0.392613,0.0362553) , 
26, 62.3301, 1, 0, 0.475244,0.00191043) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.47987,-0.0478995) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.543257,-0.167492) , 
2, 0.038043, 1, 0, 0.490278,-0.0234707) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.383099,0.0347144) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.771362,-0.0333304) , 
11, 0.6187, 1, 0, 0.584589,0.000978328) , 
23, -0.00860437, 1, 0, 0.562799,-0.00467047) , 
18, 0.571429, 1, 0, 0.5,4.97152e-05)    );
  // itree = 29
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.291152,0.0922405) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.27951,-0.0554918) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.547274,-0.00268182) , 
24, -0.0050283, 1, 0, 0.535121,-0.00157684) , 
23, -0.0882263, 1, 0, 0.532105,-0.00121986) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.464984,0.129893) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.392591,0.0112529) , 
22, 0.0598467, 1, 0, 0.442678,0.0300668) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.223499,-0.0370775) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.452062,0.0380748) , 
2, 0.00952252, 1, 0, 0.322875,4.60236e-05) , 
24, 0.00267436, 1, 0, 0.346032,0.00584873) , 
24, 0.00224642, 1, 0, 0.5,-2.53927e-07)    );
  // itree = 30
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.446829,-0.0210226) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.498772,0.0077467) , 
14, 0.83885, 1, 0, 0.491077,0.000979856) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.575059,-0.0798628) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.669803,0.0501946) , 
13, 0.657181, 1, 0, 0.606904,-0.00981217) , 
14, 17.6159, 1, 0, 0.498607,0.000278235) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.585518,-0.0547352) , 
6, 0.20689, 1, 0, 0.5,-4.34889e-05)    );
  // itree = 31
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.305391,0.00805332) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.501933,-0.114409) , 
3, 5.61766, 1, 0, 0.332217,-0.00359525) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.54588,0.108824) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.574679,0.00575903) , 
6, 0.079849, 1, 0, 0.564034,0.0152095) , 
1, 0.00474317, 1, 0, 0.444772,0.00553513) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.389157,0.00737699) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.517139,0.135225) , 
1, 0.00453393, 1, 0, 0.392232,0.00317749) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.619454,-0.0365576) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.768815,0.0223414) , 
5, 2.77501, 1, 0, 0.660899,-0.00703026) , 
1, 0.00476093, 1, 0, 0.514867,-0.00148189) , 
12, 0.168093, 1, 0, 0.5,6.39649e-06)    );
  // itree = 32
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.396534,0.0890578) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.483421,-0.00240045) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.662852,0.025497) , 
2, 0.0380877, 1, 0, 0.509816,0.000600664) , 
8, 0.142857, 1, 0, 0.508151,0.001026) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.29029,-0.089034) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.446013,0.0104367) , 
2, 0.00135694, 1, 0, 0.412591,-0.00324527) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.508695,-0.0886492) , 
2, 0.0285049, 1, 0, 0.429921,-0.00851307) , 
7, 0.714286, 1, 0, 0.5,3.2069e-05)    );
  // itree = 33
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.309926,0.0774612) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.235853,-0.00774435) , 
24, 0.000970901, 1, 0, 0.2821,0.0140978) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.518661,0.145568) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.639181,0.00884588) , 
9, 0.162093, 1, 0, 0.633078,0.0045045) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.622521,-0.0376522) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.456319,-0.00185559) , 
0, 0.668953, 1, 0, 0.473669,-0.00169273) , 
0, 0.476199, 1, 0, 0.506368,-0.0004215) , 
11, 0.0476013, 1, 0, 0.5,-9.20419e-06)    );
  // itree = 34
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.231018,0.00310286) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.323772,-0.0935981) , 
2, 0.00951969, 1, 0, 0.269558,-0.0125301) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.241133,-0.00192508) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.73437,0.0871628) , 
11, 0.761598, 1, 0, 0.391656,0.00893883) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.548581,-0.0150117) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.489099,0.0120622) , 
23, 0.00156007, 1, 0, 0.519218,-0.000545313) , 
23, -0.0262951, 1, 0, 0.506861,0.000373426) , 
23, -0.0721718, 1, 0, 0.5,3.45143e-07)    );
  // itree = 35
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.445794,0.00234997) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.65222,0.0667473) , 
16, 11.0697, 1, 0, 0.459316,0.00187617) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.811004,0.0437032) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.545205,-0.163355) , 
0, 0.950889, 1, 0, 0.67233,-0.0230633) , 
1, 0.0332013, 1, 0, 0.466173,0.00107335) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.532983,-0.0156791) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.579192,-0.102937) , 
1, 0.00498662, 1, 0, 0.550975,-0.0166748) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.523779,0.0663763) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.787953,-0.0192905) , 
11, 0.856824, 1, 0, 0.695284,0.00492632) , 
1, 0.00952237, 1, 0, 0.634504,-0.00417154) , 
2, 0.0285659, 1, 0, 0.5,1.93742e-05)    );
  // itree = 36
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.315681,0.00718908) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.778067,0.0629269) , 
11, 0.904398, 1, 0, 0.421568,0.00662201) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.422355,-0.0126508) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.5545,0.00797706) , 
16, 2.10835, 1, 0, 0.490993,-0.00066937) , 
23, -0.00795373, 1, 0, 0.471736,0.00135319) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.283806,-0.03118) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.421817,0.143117) , 
13, 0.353977, 1, 0, 0.338034,0.0112378) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.659412,0.00217231) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.785218,-0.0867472) , 
5, 2.02505, 1, 0, 0.734963,-0.0118373) , 
18, 0.133087, 1, 0, 0.647667,-0.00676243) , 
16, 7.37982, 1, 0, 0.5,4.93657e-05)    );
  // itree = 37
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.165902,-0.0679882) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.393662,0.0584497) , 
10, 11.4286, 1, 0, 0.331627,0.00966275) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.241072,-0.058382) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.473586,-0.00617059) , 
6, 0.0774251, 1, 0, 0.433606,-0.00404639) , 
12, 0.123226, 1, 0, 0.422936,-0.00261207) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.723144,0.142615) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.686365,0.0316336) , 
7, 0.499253, 1, 0, 0.70485,0.0279208) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.450926,-0.106264) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.582201,0.00663364) , 
4, 0.4295, 1, 0, 0.578824,0.0012424) , 
7, 0.517653, 1, 0, 0.587666,0.00311422) , 
18, 0.47619, 1, 0, 0.5,6.67994e-05)    );
  // itree = 38
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.665701,-0.09516) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.754492,0.0841486) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.587066,-0.00830565) , 
25, 0.00746823, 1, 0, 0.59097,-0.00186282) , 
25, 0.00693174, 1, 0, 0.59264,-0.00249796) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.229996,-0.0024647) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.630292,0.0524095) , 
11, 0.523588, 1, 0, 0.420045,0.00903082) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.177955,0.0279951) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.508529,-0.0921324) , 
11, 0.618799, 1, 0, 0.277644,-0.00539259) , 
21, 0.0105591, 1, 0, 0.366185,0.00357548) , 
25, 0.0182143, 1, 0, 0.5,-1.33877e-05)    );
  // itree = 39
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.512832,0.00138466) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.322927,-0.0715055) , 
23, 0.0458686, 1, 0, 0.509105,1.02639e-05) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.155035,0.00448409) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.53382,0.0840134) , 
11, 0.571058, 1, 0, 0.273438,0.0103351) , 
23, 0.056545, 1, 0, 0.497557,0.000516159) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.540612,0.00972207) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.619428,-0.107106) , 
8, 0.714286, 1, 0, 0.576769,-0.0149139) , 
2, 0.0952186, 1, 0, 0.5,4.0354e-05)    );
  // itree = 40
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.239722,-0.029677) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.326252,0.018234) , 
9, 0.333333, 1, 0, 0.2795,-0.00192261) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.766039,0.0424718) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.758194,-0.014864) , 
9, 0.378522, 1, 0, 0.762561,0.00509987) , 
11, 0.71402, 1, 0, 0.484497,0.00105752) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.45424,0.0902684) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.277748,-0.034029) , 
0, 1.18928, 1, 0, 0.362569,0.0102627) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.750532,-0.0927824) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.65672,0.0143236) , 
25, 0.0100997, 1, 0, 0.711747,-0.0149711) , 
11, 0.618701, 1, 0, 0.571279,-0.00482) , 
6, 0.14337, 1, 0, 0.5,7.52863e-06)    );
  // itree = 41
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.244594,0.0934998) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.150484,-0.00938886) , 
25, 0.0101164, 1, 0, 0.180521,0.00671944) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.564897,-0.00559788) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.636129,0.0343754) , 
6, 0.174938, 1, 0, 0.571991,-0.000325691) , 
11, 0.190405, 1, 0, 0.475244,0.00141542) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.550492,-0.00687109) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.598295,-0.110496) , 
12, 0.453226, 1, 0, 0.554815,-0.00508696) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.714373,0.101572) , 
13, 0.616023, 1, 0, 0.562799,-0.00329992) , 
18, 0.571429, 1, 0, 0.5,8.21865e-05)    );
  // itree = 42
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.372207,-0.00149319) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.22734,0.101206) , 
25, 0.0344047, 1, 0, 0.351282,0.00328079) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.484693,0.122171) , 
16, 5.32382, 1, 0, 0.360475,0.00587776) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.552497,-0.045426) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.361248,0.00518669) , 
25, 0.0182085, 1, 0, 0.477648,-0.00829473) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.479773,0.0188406) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.612996,-0.00841366) , 
16, 3.68991, 1, 0, 0.543585,0.00192992) , 
8, 0.571429, 1, 0, 0.524332,-0.00105555) , 
10, 10.4286, 1, 0, 0.5,-2.59737e-05)    );
  // itree = 43
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.396569,0.0823922) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.226816,-0.0613071) , 
25, 0.00891042, 1, 0, 0.263312,-0.00783537) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.781054,-0.0113866) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.721531,0.0363638) , 
25, 0.00895812, 1, 0, 0.74367,0.00602525) , 
11, 0.285608, 1, 0, 0.597985,0.00182155) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.174025,0.0368979) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.339108,-0.0190747) , 
18, 0.0952381, 1, 0, 0.250802,0.00169692) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.627631,-0.103144) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.725106,-0.00390819) , 
18, 0.320212, 1, 0, 0.692636,-0.0136108) , 
11, 0.809198, 1, 0, 0.37021,-0.00244007) , 
0, 1.42856, 1, 0, 0.5,-1.17312e-05)    );
  // itree = 44
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.507899,-0.0527735) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.368818,0.0052547) , 
0, 1.07142, 1, 0, 0.413423,-0.00374964) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.354149,-0.0366295) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.542838,0.0172477) , 
23, -0.023585, 1, 0, 0.518749,0.00315348) , 
24, -0.000963007, 1, 0, 0.484497,0.000908558) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.54149,0.131218) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.435675,-0.0344502) , 
22, 0.0645467, 1, 0, 0.496321,0.0214547) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.61243,0.0288892) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.576172,-0.035246) , 
7, 0.400277, 1, 0, 0.583276,-0.00851422) , 
9, 0.20746, 1, 0, 0.571279,-0.0043795) , 
6, 0.14337, 1, 0, 0.5,-3.61273e-05)    );
  // itree = 45
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.521771,0.0181518) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.556805,-0.0267678) , 
12, 0.75642, 1, 0, 0.527085,0.0037048) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.279711,-0.116083) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.302974,0.0261679) , 
25, 0.0407654, 1, 0, 0.288425,-0.020158) , 
25, 0.0384523, 1, 0, 0.515238,0.00252027) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.286815,-0.0188754) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.758045,0.0125676) , 
11, 0.761621, 1, 0, 0.480438,-0.00185735) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.283917,-0.00997244) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.688099,-0.189397) , 
11, 0.428267, 1, 0, 0.484487,-0.0277149) , 
26, 62.3303, 1, 0, 0.480644,-0.00317484) , 
24, 0.000320764, 1, 0, 0.5,1.16436e-05)    );
  // itree = 46
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.275418,0.0781887) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.475163,-0.00988088) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.507145,0.00769487) , 
12, 0.43129, 1, 0, 0.489044,-0.000840361) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.639317,0.0704371) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.801943,-0.0755818) , 
2, 0.0190417, 1, 0, 0.687765,0.00834049) , 
16, 11.0697, 1, 0, 0.502275,-0.000229116) , 
23, -0.104281, 1, 0, 0.5,7.41101e-06)    );
  // itree = 47
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.473285,0.00289924) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.608286,0.0426988) , 
10, 23.619, 1, 0, 0.487334,0.00214875) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.573721,-0.0828841) , 
10, 31.2857, 1, 0, 0.488944,0.00165334) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.481528,-0.0385459) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.71356,0.032473) , 
2, 0.0379462, 1, 0, 0.511663,-0.00850522) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.251932,-0.0370517) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.781105,0.0646) , 
11, 0.475991, 1, 0, 0.558782,0.00578262) , 
15, 1.72844, 1, 0, 0.526698,-0.0039462) , 
12, 0.588327, 1, 0, 0.5,1.3541e-05)    );
  // itree = 48
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.176201,-0.0721972) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.246331,0.0407704) , 
9, 0.52381, 1, 0, 0.192668,-0.0113514) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.24201,0.0236549) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.357689,0.11348) , 
18, 0.673043, 1, 0, 0.249411,0.00907113) , 
6, 0.0710089, 1, 0, 0.233625,0.00338944) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.353521,-0.0415361) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.723288,0.0484129) , 
11, 0.523703, 1, 0, 0.657696,0.00942385) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.575374,-0.0330326) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.739319,0.00229639) , 
26, 17.647, 1, 0, 0.660238,-0.00565501) , 
6, 0.0795428, 1, 0, 0.65962,-0.00198521) , 
11, 0.333209, 1, 0, 0.5,2.86655e-05)    );
  // itree = 49
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.320019,-0.107363) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.225906,0.0321078) , 
25, 0.0257339, 1, 0, 0.27665,-0.0151867) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.500149,-0.012842) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.303514,0.0380201) , 
25, 0.0344047, 1, 0, 0.475981,-0.00190949) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.521551,0.0204427) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.656821,-0.0183323) , 
2, 0.0285542, 1, 0, 0.552952,0.00388754) , 
6, 0.11428, 1, 0, 0.50576,0.000333303) , 
10, 6.95238, 1, 0, 0.5,-5.68771e-05)    );
   return;
};
 
// Clean up
inline void ReadMinNodeSize 1.0::Clear() 
{
   for (unsigned int itree=0; itree<fForest.size(); itree++) { 
      delete fForest[itree]; 
   }
}
   inline double ReadMinNodeSize 1.0::GetMvaValue( const std::vector<double>& inputValues ) const
   {
      // classifier response value
      double retval = 0;

      // classifier response, sanity check first
      if (!IsStatusClean()) {
         std::cout << "Problem in class \"" << fClassName << "\": cannot return classifier response"
                   << " because status is dirty" << std::endl;
         retval = 0;
      }
      else {
         if (IsNormalised()) {
            // normalise variables
            std::vector<double> iV;
            iV.reserve(inputValues.size());
            int ivar = 0;
            for (std::vector<double>::const_iterator varIt = inputValues.begin();
                 varIt != inputValues.end(); varIt++, ivar++) {
               iV.push_back(NormVariable( *varIt, fVmin[ivar], fVmax[ivar] ));
            }
            retval = GetMvaValue__( iV );
         }
         else {
            retval = GetMvaValue__( inputValues );
         }
      }

      return retval;
   }
