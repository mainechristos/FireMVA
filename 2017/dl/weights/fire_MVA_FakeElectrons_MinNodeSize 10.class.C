// Class: ReadMinNodeSize 10
// Automatically generated by MethodBase::MakeClass
//

/* configuration options =====================================================

#GEN -*-*-*-*-*-*-*-*-*-*-*- general info -*-*-*-*-*-*-*-*-*-*-*-

Method         : BDT::MinNodeSize 10
TMVA Release   : 4.2.1         [262657]
ROOT Release   : 6.14/07       [396807]
Creator        : mchristos
Date           : Thu Nov 15 23:19:42 2018
Host           : Linux cmsbuild02.cern.ch 2.6.32-754.3.5.el6.x86_64 #1 SMP Wed Aug 15 08:57:36 CEST 2018 x86_64 x86_64 x86_64 GNU/Linux
Dir            : /cms/mchristos/ANN/FireMVA/2017
Training events: 70707
Analysis type  : [Classification]


#OPT -*-*-*-*-*-*-*-*-*-*-*-*- options -*-*-*-*-*-*-*-*-*-*-*-*-

# Set by User:
V: "False" [Verbose output (short form of "VerbosityLevel" below - overrides the latter one)]
H: "False" [Print method-specific help message]
NTrees: "50" [Number of trees in the forest]
MaxDepth: "3" [Max depth of the decision tree allowed]
MinNodeSize: "10.0%" [Minimum percentage of training events required in a leaf node (default: Classification: 5%, Regression: 0.2%)]
nCuts: "20" [Number of grid points in variable range used in finding optimal cut in node splitting]
BoostType: "Grad" [Boosting type for the trees in the forest (note: AdaCost is still experimental)]
Shrinkage: "1.000000e+00" [Learning rate for GradBoost algorithm]
# Default:
VerbosityLevel: "Default" [Verbosity level]
VarTransform: "None" [List of variable transformations performed before training, e.g., "D_Background,P_Signal,G,N_AllClasses" for: "Decorrelation, PCA-transformation, Gaussianisation, Normalisation, each for the given class of events ('AllClasses' denotes all events of all classes, if no class indication is given, 'All' is assumed)"]
CreateMVAPdfs: "False" [Create PDFs for classifier outputs (signal and background)]
IgnoreNegWeightsInTraining: "False" [Events with negative weights are ignored in the training (but are included for testing and performance evaluation)]
AdaBoostR2Loss: "quadratic" [Type of Loss function in AdaBoostR2]
UseBaggedBoost: "False" [Use only a random subsample of all events for growing the trees in each boost iteration.]
AdaBoostBeta: "5.000000e-01" [Learning rate  for AdaBoost algorithm]
UseRandomisedTrees: "False" [Determine at each node splitting the cut variable only as the best out of a random subset of variables (like in RandomForests)]
UseNvars: "5" [Size of the subset of variables used with RandomisedTree option]
UsePoissonNvars: "True" [Interpret "UseNvars" not as fixed number but as mean of a Poisson distribution in each split with RandomisedTree option]
BaggedSampleFraction: "6.000000e-01" [Relative size of bagged event sample to original size of the data sample (used whenever bagging is used (i.e. UseBaggedBoost, Bagging,)]
UseYesNoLeaf: "True" [Use Sig or Bkg categories, or the purity=S/(S+B) as classification of the leaf node -> Real-AdaBoost]
NegWeightTreatment: "pray" [How to treat events with negative weights in the BDT training (particular the boosting) : IgnoreInTraining;  Boost With inverse boostweight; Pair events with negative and positive weights in training sample and *annihilate* them (experimental!)]
Css: "1.000000e+00" [AdaCost: cost of true signal selected signal]
Cts_sb: "1.000000e+00" [AdaCost: cost of true signal selected bkg]
Ctb_ss: "1.000000e+00" [AdaCost: cost of true bkg    selected signal]
Cbb: "1.000000e+00" [AdaCost: cost of true bkg    selected bkg ]
NodePurityLimit: "5.000000e-01" [In boosting/pruning, nodes with purity > NodePurityLimit are signal; background otherwise.]
SeparationType: "giniindex" [Separation criterion for node splitting]
RegressionLossFunctionBDTG: "huber" [Loss function for BDTG regression.]
HuberQuantile: "7.000000e-01" [In the Huber loss function this is the quantile that separates the core from the tails in the residuals distribution.]
DoBoostMonitor: "False" [Create control plot with ROC integral vs tree number]
UseFisherCuts: "False" [Use multivariate splits using the Fisher criterion]
MinLinCorrForFisher: "8.000000e-01" [The minimum linear correlation between two variables demanded for use in Fisher criterion in node splitting]
UseExclusiveVars: "False" [Variables already used in fisher criterion are not anymore analysed individually for node splitting]
DoPreselection: "False" [and and apply automatic pre-selection for 100% efficient signal (bkg) cuts prior to training]
SigToBkgFraction: "1.000000e+00" [Sig to Bkg ratio used in Training (similar to NodePurityLimit, which cannot be used in real adaboost]
PruneMethod: "nopruning" [Note: for BDTs use small trees (e.g.MaxDepth=3) and NoPruning:  Pruning: Method used for pruning (removal) of statistically insignificant branches ]
PruneStrength: "0.000000e+00" [Pruning strength]
PruningValFraction: "5.000000e-01" [Fraction of events to use for optimizing automatic pruning.]
SkipNormalization: "False" [Skip normalization at initialization, to keep expectation value of BDT output according to the fraction of events]
nEventsMin: "0" [deprecated: Use MinNodeSize (in % of training events) instead]
UseBaggedGrad: "False" [deprecated: Use *UseBaggedBoost* instead:  Use only a random subsample of all events for growing the trees in each iteration.]
GradBaggingFraction: "6.000000e-01" [deprecated: Use *BaggedSampleFraction* instead: Defines the fraction of events to be used in each iteration, e.g. when UseBaggedGrad=kTRUE. ]
UseNTrainEvents: "0" [deprecated: Use *BaggedSampleFraction* instead: Number of randomly picked training events used in randomised (and bagged) trees]
NNodesMax: "0" [deprecated: Use MaxDepth instead to limit the tree size]
##


#VAR -*-*-*-*-*-*-*-*-*-*-*-* variables *-*-*-*-*-*-*-*-*-*-*-*-

NVar 27
abs(ElectronEta)              abs_ElectronEta_              abs(ElectronEta)              abs(ElectronEta)                                                'F'    [1.69258073583e-05,2.49997067451]
ElectronDXY                   ElectronDXY                   ElectronDXY                   ElectronDXY                                                     'F'    [6.64379129489e-08,0.0999782606959]
ElectronDZ                    ElectronDZ                    ElectronDZ                    ElectronDZ                                                      'F'    [4.06895367178e-07,0.199958592653]
ElectronSIP3D                 ElectronSIP3D                 ElectronSIP3D                 ElectronSIP3D                                                   'F'    [0.00396113377064,82.4355926514]
ElectronPtRatio               ElectronPtRatio               ElectronPtRatio               ElectronPtRatio                                                 'F'    [-1,3.24139928818]
ElectronPtRel                 ElectronPtRel                 ElectronPtRel                 ElectronPtRel                                                   'F'    [-1,970.202941895]
ElectronJetLRM                ElectronJetLRM                ElectronJetLRM                ElectronJetLRM                                                  'F'    [-1,0.33393111825]
ElectronJetFD                 ElectronJetFD                 ElectronJetFD                 ElectronJetFD                                                   'F'    [-1,1]
ElectronJetInOutRatio         ElectronJetInOutRatio         ElectronJetInOutRatio         ElectronJetInOutRatio                                           'F'    [-9999,1]
ElectronJetZest               ElectronJetZest               ElectronJetZest               ElectronJetZest                                                 'F'    [-1,1]
ElectronJetNoOfConst          ElectronJetNoOfConst          ElectronJetNoOfConst          ElectronJetNoOfConst                                            'F'    [0,73]
ElectronJetCSV                ElectronJetCSV                ElectronJetCSV                ElectronJetCSV                                                  'F'    [0,0.999627411366]
ElectronRelPFIsoPUCorr        ElectronRelPFIsoPUCorr        ElectronRelPFIsoPUCorr        ElectronRelPFIsoPUCorr                                          'F'    [0,1.76498115063]
ElectronRelTrkIso             ElectronRelTrkIso             ElectronRelTrkIso             ElectronRelTrkIso                                               'F'    [0,61.5004081726]
ElectronPFChargedHadronIso    ElectronPFChargedHadronIso    ElectronPFChargedHadronIso    ElectronPFChargedHadronIso                                      'F'    [0,92.4835739136]
ElectronPFNeutralHadronIso    ElectronPFNeutralHadronIso    ElectronPFNeutralHadronIso    ElectronPFNeutralHadronIso                                      'F'    [0,36.2971611023]
ElectronPFPhotonIso           ElectronPFPhotonIso           ElectronPFPhotonIso           ElectronPFPhotonIso                                             'F'    [0,77.488067627]
ElectronJetMuonEnergyFraction ElectronJetMuonEnergyFraction ElectronJetMuonEnergyFraction ElectronJetMuonEnergyFraction                                   'F'    [0,1]
ElectronJetElectronEnergyFraction ElectronJetElectronEnergyFraction ElectronJetElectronEnergyFraction ElectronJetElectronEnergyFraction                                       'F'    [0,1]
ElectronMissingHits           ElectronMissingHits           ElectronMissingHits           ElectronMissingHits                                             'F'    [0,1]
ElectronPassConversionVeto    ElectronPassConversionVeto    ElectronPassConversionVeto    ElectronPassConversionVeto                                      'F'    [1,1]
ElectronEInverseMinusPInverse ElectronEInverseMinusPInverse ElectronEInverseMinusPInverse ElectronEInverseMinusPInverse                                   'F'    [1.45857645961e-08,0.192345529795]
ElectronHoE                   ElectronHoE                   ElectronHoE                   ElectronHoE                                                     'F'    [0,1.74987196922]
ElectronDeltaPhiTrkSC         ElectronDeltaPhiTrkSC         ElectronDeltaPhiTrkSC         ElectronDeltaPhiTrkSC                                           'F'    [-0.168498814106,0.168645858765]
ElectronDeltaEtaTrkSeedSC     ElectronDeltaEtaTrkSeedSC     ElectronDeltaEtaTrkSeedSC     ElectronDeltaEtaTrkSeedSC                                       'F'    [-0.00673997402191,0.00673961639404]
ElectronFull5x5SigmaIEtaIEta  ElectronFull5x5SigmaIEtaIEta  ElectronFull5x5SigmaIEtaIEta  ElectronFull5x5SigmaIEtaIEta                                    'F'    [0,0.0424999594688]
ElectronPt                    ElectronPt                    ElectronPt                    ElectronPt                                                      'F'    [10.0002174377,1108.92687988]
NSpec 0


============================================================================ */

#include <array>
#include <vector>
#include <cmath>
#include <string>
#include <iostream>

#define NN new MinNodeSize 10Node
   
#ifndef MinNodeSize 10Node__def
#define MinNodeSize 10Node__def
   
class MinNodeSize 10Node {
   
public:
   
   // constructor of an essentially "empty" node floating in space
   MinNodeSize 10Node ( MinNodeSize 10Node* left,MinNodeSize 10Node* right,
                          int selector, double cutValue, bool cutType, 
                          int nodeType, double purity, double response ) :
   fLeft         ( left         ),
   fRight        ( right        ),
   fSelector     ( selector     ),
   fCutValue     ( cutValue     ),
   fCutType      ( cutType      ),
   fNodeType     ( nodeType     ),
   fPurity       ( purity       ),
   fResponse     ( response     ){
   }

   virtual ~MinNodeSize 10Node();

   // test event if it descends the tree at this node to the right
   virtual bool GoesRight( const std::vector<double>& inputValues ) const;
   MinNodeSize 10Node* GetRight( void )  {return fRight; };

   // test event if it descends the tree at this node to the left 
   virtual bool GoesLeft ( const std::vector<double>& inputValues ) const;
   MinNodeSize 10Node* GetLeft( void ) { return fLeft; };   

   // return  S/(S+B) (purity) at this node (from  training)

   double GetPurity( void ) const { return fPurity; } 
   // return the node type
   int    GetNodeType( void ) const { return fNodeType; }
   double GetResponse(void) const {return fResponse;}

private:

   MinNodeSize 10Node*   fLeft;     // pointer to the left daughter node
   MinNodeSize 10Node*   fRight;    // pointer to the right daughter node
   int                     fSelector; // index of variable used in node selection (decision tree)   
   double                  fCutValue; // cut value applied on this node to discriminate bkg against sig
   bool                    fCutType;  // true: if event variable > cutValue ==> signal , false otherwise
   int                     fNodeType; // Type of node: -1 == Bkg-leaf, 1 == Signal-leaf, 0 = internal 
   double                  fPurity;   // Purity of node from training
   double                  fResponse; // Regression response value of node
}; 
   
//_______________________________________________________________________
   MinNodeSize 10Node::~MinNodeSize 10Node()
{
   if (fLeft  != NULL) delete fLeft;
   if (fRight != NULL) delete fRight;
}; 
   
//_______________________________________________________________________
bool MinNodeSize 10Node::GoesRight( const std::vector<double>& inputValues ) const
{
   // test event if it descends the tree at this node to the right
   bool result;
     result = (inputValues[fSelector] > fCutValue );
   if (fCutType == true) return result; //the cuts are selecting Signal ;
   else return !result;
}
   
//_______________________________________________________________________
bool MinNodeSize 10Node::GoesLeft( const std::vector<double>& inputValues ) const
{
   // test event if it descends the tree at this node to the left
   if (!this->GoesRight(inputValues)) return true;
   else return false;
}
   
#endif
   
#ifndef IClassifierReader__def
#define IClassifierReader__def

class IClassifierReader {

 public:

   // constructor
   IClassifierReader() : fStatusIsClean( true ) {}
   virtual ~IClassifierReader() {}

   // return classifier response
   virtual double GetMvaValue( const std::vector<double>& inputValues ) const = 0;

   // returns classifier status
   bool IsStatusClean() const { return fStatusIsClean; }

 protected:

   bool fStatusIsClean;
};

#endif

class ReadMinNodeSize 10 : public IClassifierReader {

 public:

   // constructor
   ReadMinNodeSize 10( std::vector<std::string>& theInputVars )
      : IClassifierReader(),
        fClassName( "ReadMinNodeSize 10" ),
        fNvars( 27 ),
        fIsNormalised( false )
   {
      // the training input variables
      const char* inputVars[] = { "abs(ElectronEta)", "ElectronDXY", "ElectronDZ", "ElectronSIP3D", "ElectronPtRatio", "ElectronPtRel", "ElectronJetLRM", "ElectronJetFD", "ElectronJetInOutRatio", "ElectronJetZest", "ElectronJetNoOfConst", "ElectronJetCSV", "ElectronRelPFIsoPUCorr", "ElectronRelTrkIso", "ElectronPFChargedHadronIso", "ElectronPFNeutralHadronIso", "ElectronPFPhotonIso", "ElectronJetMuonEnergyFraction", "ElectronJetElectronEnergyFraction", "ElectronMissingHits", "ElectronPassConversionVeto", "ElectronEInverseMinusPInverse", "ElectronHoE", "ElectronDeltaPhiTrkSC", "ElectronDeltaEtaTrkSeedSC", "ElectronFull5x5SigmaIEtaIEta", "ElectronPt" };

      // sanity checks
      if (theInputVars.size() <= 0) {
         std::cout << "Problem in class \"" << fClassName << "\": empty input vector" << std::endl;
         fStatusIsClean = false;
      }

      if (theInputVars.size() != fNvars) {
         std::cout << "Problem in class \"" << fClassName << "\": mismatch in number of input values: "
                   << theInputVars.size() << " != " << fNvars << std::endl;
         fStatusIsClean = false;
      }

      // validate input variables
      for (size_t ivar = 0; ivar < theInputVars.size(); ivar++) {
         if (theInputVars[ivar] != inputVars[ivar]) {
            std::cout << "Problem in class \"" << fClassName << "\": mismatch in input variable names" << std::endl
                      << " for variable [" << ivar << "]: " << theInputVars[ivar].c_str() << " != " << inputVars[ivar] << std::endl;
            fStatusIsClean = false;
         }
      }

      // initialize min and max vectors (for normalisation)
      fVmin[0] = 0;
      fVmax[0] = 0;
      fVmin[1] = 0;
      fVmax[1] = 0;
      fVmin[2] = 0;
      fVmax[2] = 0;
      fVmin[3] = 0;
      fVmax[3] = 0;
      fVmin[4] = 0;
      fVmax[4] = 0;
      fVmin[5] = 0;
      fVmax[5] = 0;
      fVmin[6] = 0;
      fVmax[6] = 0;
      fVmin[7] = 0;
      fVmax[7] = 0;
      fVmin[8] = 0;
      fVmax[8] = 0;
      fVmin[9] = 0;
      fVmax[9] = 0;
      fVmin[10] = 0;
      fVmax[10] = 0;
      fVmin[11] = 0;
      fVmax[11] = 0;
      fVmin[12] = 0;
      fVmax[12] = 0;
      fVmin[13] = 0;
      fVmax[13] = 0;
      fVmin[14] = 0;
      fVmax[14] = 0;
      fVmin[15] = 0;
      fVmax[15] = 0;
      fVmin[16] = 0;
      fVmax[16] = 0;
      fVmin[17] = 0;
      fVmax[17] = 0;
      fVmin[18] = 0;
      fVmax[18] = 0;
      fVmin[19] = 0;
      fVmax[19] = 0;
      fVmin[20] = 0;
      fVmax[20] = 0;
      fVmin[21] = 0;
      fVmax[21] = 0;
      fVmin[22] = 0;
      fVmax[22] = 0;
      fVmin[23] = 0;
      fVmax[23] = 0;
      fVmin[24] = 0;
      fVmax[24] = 0;
      fVmin[25] = 0;
      fVmax[25] = 0;
      fVmin[26] = 0;
      fVmax[26] = 0;

      // initialize input variable types
      fType[0] = 'F';
      fType[1] = 'F';
      fType[2] = 'F';
      fType[3] = 'F';
      fType[4] = 'F';
      fType[5] = 'F';
      fType[6] = 'F';
      fType[7] = 'F';
      fType[8] = 'F';
      fType[9] = 'F';
      fType[10] = 'F';
      fType[11] = 'F';
      fType[12] = 'F';
      fType[13] = 'F';
      fType[14] = 'F';
      fType[15] = 'F';
      fType[16] = 'F';
      fType[17] = 'F';
      fType[18] = 'F';
      fType[19] = 'F';
      fType[20] = 'F';
      fType[21] = 'F';
      fType[22] = 'F';
      fType[23] = 'F';
      fType[24] = 'F';
      fType[25] = 'F';
      fType[26] = 'F';

      // initialize constants
      Initialize();

   }

   // destructor
   virtual ~ReadMinNodeSize 10() {
      Clear(); // method-specific
   }

   // the classifier response
   // "inputValues" is a vector of input values in the same order as the
   // variables given to the constructor
   double GetMvaValue( const std::vector<double>& inputValues ) const override;

 private:

   // method-specific destructor
   void Clear();

   // common member variables
   const char* fClassName;

   const size_t fNvars;
   size_t GetNvar()           const { return fNvars; }
   char   GetType( int ivar ) const { return fType[ivar]; }

   // normalisation of input variables
   const bool fIsNormalised;
   bool IsNormalised() const { return fIsNormalised; }
   double fVmin[27];
   double fVmax[27];
   double NormVariable( double x, double xmin, double xmax ) const {
      // normalise to output range: [-1, 1]
      return 2*(x - xmin)/(xmax - xmin) - 1.0;
   }

   // type of input variable: 'F' or 'I'
   char   fType[27];

   // initialize internal variables
   void Initialize();
   double GetMvaValue__( const std::vector<double>& inputValues ) const;

   // private members (method specific)
   std::vector<MinNodeSize 10Node*> fForest;       // i.e. root nodes of decision trees
   std::vector<double>                fBoostWeights; // the weights applied in the individual boosts
};

double ReadMinNodeSize 10::GetMvaValue__( const std::vector<double>& inputValues ) const
{
   double myMVA = 0;
   for (unsigned int itree=0; itree<fForest.size(); itree++){
      MinNodeSize 10Node *current = fForest[itree];
      while (current->GetNodeType() == 0) { //intermediate node
         if (current->GoesRight(inputValues)) current=(MinNodeSize 10Node*)current->GetRight();
         else current=(MinNodeSize 10Node*)current->GetLeft();
      }
      myMVA += current->GetResponse();
   }
   return 2.0/(1.0+exp(-2.0*myMVA))-1.0;
};

void ReadMinNodeSize 10::Initialize()
{
  // itree = 0
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.119276,-0.761448) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.183056,-0.633887) , 
11, 0.206248, 1, 0, 0.147473,-0.352527) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.448616,-0.102768) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.244828,-0.510344) , 
21, 0.00914059, 1, 0, 0.376342,-0.123658) , 
18, 0.142857, 1, 0, 0.275057,-0.224943) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.587184,0.174369) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.746132,0.492263) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.882889,0.765778) , 
26, 27.8466, 1, 0, 0.78713,0.28713) , 
11, 0.836436, 1, 0, 0.73519,0.23519) , 
11, 0.618817, 1, 0, 0.5,-4.0518e-16)    );
  // itree = 1
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.294741,-0.0891904) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.719489,0.16941) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.811623,0.374996) , 
16, 5.3918, 1, 0, 0.75182,0.0958994) , 
11, 0.238007, 1, 0, 0.64196,0.0639452) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.238405,-0.295247) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.312446,-0.12867) , 
10, 16.2857, 1, 0, 0.268937,-0.087671) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.602201,0.0140602) , 
3, 3.92928, 1, 0, 0.386005,-0.0549124) , 
25, 0.010119, 1, 0, 0.5,-0.00197663)    );
  // itree = 2
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.135263,-0.0633512) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.441003,-0.231093) , 
11, 0.42839, 1, 0, 0.243627,-0.0409811) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.450019,-0.132261) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.604549,0.0416526) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.716634,0.190747) , 
5, 2.47789, 1, 0, 0.649196,0.0366927) , 
10, 11.2857, 1, 0, 0.607234,0.017905) , 
18, 0.047619, 1, 0, 0.5,0.000538417)    );
  // itree = 3
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.627977,0.0713397) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.45546,-0.0420275) , 
21, 0.00173776, 1, 0, 0.511473,-0.00160106) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.273386,-0.135398) , 
21, 0.0182499, 1, 0, 0.466618,-0.00928211) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.460351,0.028172) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.742461,0.15811) , 
1, 0.0047613, 1, 0, 0.594339,0.0287568) , 
10, 20.8571, 1, 0, 0.5,0.000659957)    );
  // itree = 4
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.200017,-0.0782207) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.285095,0.0497917) , 
11, 0.164155, 1, 0, 0.240022,-0.00500417) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.403482,0.225036) , 
11, 0.383041, 1, 0, 0.275057,0.0132293) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.69884,-0.0393759) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.690696,-0.176277) , 
6, 0.1261, 1, 0, 0.695642,-0.0321404) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.812612,0.0772401) , 
14, 8.63049, 1, 0, 0.73519,-0.0135653) , 
11, 0.618817, 1, 0, 0.5,0.000130365)    );
  // itree = 5
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.30259,-0.112804) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.21449,-0.000401674) , 
0, 1.66593, 1, 0, 0.270501,-0.0240722) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.485085,0.063959) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.632851,-0.0580377) , 
3, 3.92014, 1, 0, 0.5486,0.00407947) , 
3, 1.49922, 1, 0, 0.42159,-0.00877763) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.751268,0.125624) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.7586,0.0577845) , 
9, 0.333333, 1, 0, 0.755416,0.0290161) , 
3, 7.85459, 1, 0, 0.5,9.94639e-05)    );
  // itree = 6
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.428814,0.120586) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.8232,0.0135837) , 
11, 0.809073, 1, 0, 0.627941,0.0232376) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.203454,0.0194515) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.498868,-0.0537588) , 
11, 0.226672, 1, 0, 0.389117,-0.0105378) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.81056,0.0489162) , 
11, 0.952026, 1, 0, 0.467393,-0.00585828) , 
0, 0.476199, 1, 0, 0.5,5.10439e-05)    );
  // itree = 7
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.239645,0.00989893) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.503475,-0.0812841) , 
18, 0.142857, 1, 0, 0.389905,-0.0161201) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.430213,0.0668855) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.815643,-0.0146515) , 
11, 0.856824, 1, 0, 0.588201,0.0127917) , 
24, -0.00160496, 1, 0, 0.532105,0.00461284) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.346032,-0.0672276) , 
24, 0.00224642, 1, 0, 0.5,-1.68785e-06)    );
  // itree = 8
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.550385,0.047946) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.830503,-0.0695689) , 
11, 0.856824, 1, 0, 0.686327,0.00123444) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.584916,-0.114632) , 
25, 0.00915508, 1, 0, 0.64196,-0.0155042) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.234325,-0.0194322) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.393569,0.0571306) , 
1, 0.00476093, 1, 0, 0.290211,0.00365405) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.766338,0.124116) , 
11, 0.904398, 1, 0, 0.386005,0.0122841) , 
25, 0.010119, 1, 0, 0.5,-9.1997e-05)    );
  // itree = 9
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.567056,0.0144922) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.318799,-0.0511862) , 
25, 0.0283333, 1, 0, 0.500214,-0.000838472) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.268528,-0.0826648) , 
21, 0.0274779, 1, 0, 0.471736,-0.00378963) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.647667,0.0753198) , 
16, 7.37982, 1, 0, 0.5,0.000449882)    );
  // itree = 10
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.180293,0.00582706) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.459899,-0.0547897) , 
18, 0.333333, 1, 0, 0.342628,-0.0113232) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.524536,0.00798255) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.590015,0.0695215) , 
18, 0.619048, 1, 0, 0.537941,0.00710722) , 
2, 0.00226738, 1, 0, 0.483207,0.00194229) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.636513,-0.0467517) , 
2, 0.0476095, 1, 0, 0.5,-4.99981e-05)    );
  // itree = 11
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.426592,-0.0102529) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.541807,0.0964125) , 
26, 16.332, 1, 0, 0.473501,0.00983969) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.446007,-0.0217491) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.629516,0.0233072) , 
24, -0.000871235, 1, 0, 0.542659,0.000632353) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.524777,-0.0823136) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.341677,0.00764723) , 
25, 0.0141617, 1, 0, 0.438541,-0.0131451) , 
24, 0.000962723, 1, 0, 0.510037,-0.00368437) , 
4, 0.4138, 1, 0, 0.5,3.09252e-05)    );
  // itree = 12
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.455283,0.0510372) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.468441,-0.00690639) , 
7, 0.619048, 1, 0, 0.461433,0.00797394) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.576324,-0.0261483) , 
10, 20.8571, 1, 0, 0.485556,0.00456019) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.349543,-0.124063) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.472102,-0.0428342) , 
5, 1.03895, 1, 0, 0.414818,-0.0255564) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.667914,0.0559741) , 
5, 1.85465, 1, 0, 0.52391,-0.00744095) , 
12, 0.50428, 1, 0, 0.5,4.06245e-05)    );
  // itree = 13
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.299684,-0.0289977) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.169052,0.0708782) , 
21, 0.00912495, 1, 0, 0.240727,0.00208924) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.67949,-0.000289341) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.682355,-0.0728292) , 
2, 0.019039, 1, 0, 0.680747,-0.0117597) , 
11, 0.618817, 1, 0, 0.438905,-0.0041481) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.531457,-0.0367279) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.830579,0.0257187) , 
3, 3.79909, 1, 0, 0.688705,-0.00241506) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.466905,0.0506579) , 
25, 0.0101169, 1, 0, 0.590851,0.00607351) , 
16, 3.68991, 1, 0, 0.5,-3.81494e-05)    );
  // itree = 14
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.420071,0.0374346) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.482378,-0.00682786) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.315176,-0.0562846) , 
23, 0.0241553, 1, 0, 0.458962,-0.00449442) , 
4, 0.356867, 1, 0, 0.45388,-0.00233849) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.772023,0.044129) , 
3, 11.7799, 1, 0, 0.5,-4.60821e-05)    );
  // itree = 15
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.344214,0.00609206) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.692536,-0.0356044) , 
3, 3.78146, 1, 0, 0.48972,-0.00367634) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.541825,0.0324767) , 
15, 3.45687, 1, 0, 0.496359,-0.00189779) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.522923,0.0328432) , 
18, 0.666667, 1, 0, 0.5,4.32636e-06)    );
  // itree = 16
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.421595,-0.0486664) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.579604,0.0516685) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.832839,0.00558639) , 
11, 0.904254, 1, 0, 0.682278,0.0121249) , 
18, 0.380952, 1, 0, 0.616628,0.00562681) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.251976,-0.0104316) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.248475,0.0583482) , 
0, 1.76303, 1, 0, 0.250156,0.00717245) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.311164,-0.0697871) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.701641,0.00452987) , 
11, 0.523614, 1, 0, 0.534426,-0.0106861) , 
18, 0.0952381, 1, 0, 0.422649,-0.00366398) , 
0, 0.95238, 1, 0, 0.5,4.08088e-05)    );
  // itree = 17
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.407154,-0.0162129) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.593887,0.0152444) , 
18, 0.47619, 1, 0, 0.497243,3.44217e-05) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.705597,0.0372361) , 
2, 0.0380775, 1, 0, 0.523372,0.00159217) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.330775,-0.0360019) , 
0, 2.02379, 1, 0, 0.5,-0.000117178)    );
  // itree = 18
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.456733,0.0199063) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.461879,-0.0341165) , 
8, 0.464844, 1, 0, 0.459687,-0.00349348) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.278543,0.00453998) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.791959,0.0517206) , 
11, 0.761598, 1, 0, 0.506056,0.00772492) , 
8, 0.619048, 1, 0, 0.487618,0.00326394) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.373331,0.00975211) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.759164,-0.0842456) , 
11, 0.809222, 1, 0, 0.532079,-0.00844635) , 
9, 0.428571, 1, 0, 0.5,2.65762e-06)    );
  // itree = 19
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.377465,0.0353756) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.519417,-0.013428) , 
10, 11.2381, 1, 0, 0.494625,-0.00148234) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.598821,0.0772861) , 
26, 37.5519, 1, 0, 0.508151,0.00142469) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.429921,-0.0297275) , 
7, 0.714286, 1, 0, 0.5,0.000180434)    );
  // itree = 20
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.448696,0.0394306) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.361635,-0.0384257) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.510636,0.00413691) , 
16, 0.702782, 1, 0, 0.478246,-0.0017329) , 
4, 0.39533, 1, 0, 0.471736,0.00141935) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.647667,-0.0264694) , 
16, 7.37982, 1, 0, 0.5,9.98607e-07)    );
  // itree = 21
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.239177,-0.00680606) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.327377,0.0539185) , 
2, 0.00952223, 1, 0, 0.261404,0.00315983) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.638743,-0.0674429) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.772931,0.00537395) , 
18, 0.380943, 1, 0, 0.732696,-0.00623023) , 
11, 0.618817, 1, 0, 0.496359,-0.00152142) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.522923,0.0263877) , 
18, 0.666667, 1, 0, 0.5,-1.03943e-05)    );
  // itree = 22
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.294145,-0.0531646) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.358096,-0.00455622) , 
6, 0.0710089, 1, 0, 0.34237,-0.00522451) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.545108,0.024404) , 
1, 0.0095218, 1, 0, 0.37991,-0.00256144) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.788522,0.0666022) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.820087,-0.0233436) , 
3, 7.61464, 1, 0, 0.805554,0.00657354) , 
11, 0.904425, 1, 0, 0.5,1.58738e-05)    );
  // itree = 23
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.192668,-0.0387644) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.216041,-0.00469216) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.283635,0.0696337) , 
6, 0.107013, 1, 0, 0.249411,0.0104829) , 
6, 0.0710089, 1, 0, 0.233625,0.00454843) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.657696,0.0382411) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.589449,-0.066659) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.693592,0.00278724) , 
14, 3.02788, 1, 0, 0.660238,-0.00737224) , 
6, 0.0795428, 1, 0, 0.65962,-0.00262781) , 
11, 0.333209, 1, 0, 0.5,6.11129e-05)    );
  // itree = 24
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.465918,0.0521205) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.451849,0.0314512) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.498395,-0.0367881) , 
6, 0.0795161, 1, 0, 0.473933,-0.00109325) , 
4, 0.550367, 1, 0, 0.470823,0.00636647) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.595896,-0.0295314) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.665075,0.0298399) , 
6, 0.112769, 1, 0, 0.628133,0.000187711) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.291007,-0.0136397) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.536213,-0.0563679) , 
1, 0.00475652, 1, 0, 0.397069,-0.0107432) , 
0, 1.18992, 1, 0, 0.52188,-0.00483878) , 
12, 0.336187, 1, 0, 0.5,-3.6803e-05)    );
  // itree = 25
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.270736,-0.0628933) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.729591,0.0255683) , 
11, 0.523508, 1, 0, 0.432766,-0.0105005) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.724358,-0.000902477) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.813806,0.0409403) , 
3, 7.4084, 1, 0, 0.77917,0.00691224) , 
3, 3.79909, 1, 0, 0.593035,-0.00244422) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.232034,0.0731819) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.300175,-0.00804647) , 
10, 15.4286, 1, 0, 0.261526,0.0105176) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.558174,-0.023921) , 
3, 3.92928, 1, 0, 0.366615,0.00354157) , 
25, 0.0141667, 1, 0, 0.5,1.53179e-05)    );
  // itree = 26
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.334074,0.0577438) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.137577,0.0344415) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.259433,-0.0415202) , 
18, 0.0952381, 1, 0, 0.191556,-0.00240057) , 
25, 0.0101181, 1, 0, 0.239796,0.00522585) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.767471,-0.0488749) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.547043,-0.0039236) , 
25, 0.010119, 1, 0, 0.660535,-0.00825616) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.71095,0.0275634) , 
15, 1.72844, 1, 0, 0.674013,-0.0037193) , 
11, 0.38081, 1, 0, 0.5,-0.000134516)    );
  // itree = 27
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.378456,-0.0350225) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.551216,0.00410365) , 
16, 2.6959, 1, 0, 0.465345,-0.00488988) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.578401,0.00357237) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.515257,0.0431752) , 
23, 0.00843087, 1, 0, 0.56231,0.00459847) , 
6, 0.0774251, 1, 0, 0.536095,0.00203324) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.311079,-0.0324602) , 
25, 0.0323809, 1, 0, 0.5,-8.39655e-06)    );
  // itree = 28
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.179601,0.0196085) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.467207,-0.0281072) , 
11, 0.181337, 1, 0, 0.380675,-0.00541485) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.815164,0.0258307) , 
11, 0.952026, 1, 0, 0.475244,-0.00262602) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.479818,-0.0378999) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.631308,0.0706516) , 
13, 0.154006, 1, 0, 0.562799,0.00659228) , 
18, 0.571429, 1, 0, 0.5,-1.95968e-05)    );
  // itree = 29
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.702786,0.0204461) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.463051,-0.0525291) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.788616,0.00570831) , 
3, 3.79909, 1, 0, 0.619989,-0.00844426) , 
25, 0.00867324, 1, 0, 0.64196,-0.00447744) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.174094,-0.0149651) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.574587,0.040301) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.395719,-0.00773077) , 
21, 0.00905106, 1, 0, 0.504357,0.00793413) , 
11, 0.237999, 1, 0, 0.386005,0.00366118) , 
25, 0.010119, 1, 0, 0.5,3.64735e-05)    );
  // itree = 30
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.316476,0.0370794) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.260948,0.00230357) , 
22, 0.0338086, 1, 0, 0.298384,0.0085841) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.220952,-0.0170778) , 
22, 0.0645467, 1, 0, 0.275057,0.00448586) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.72226,0.0195276) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.700118,-0.0121549) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.808461,-0.0763953) , 
11, 0.963363, 1, 0, 0.74166,-0.0102856) , 
9, 0.28974, 1, 0, 0.73519,-0.00467859) , 
11, 0.618817, 1, 0, 0.5,5.67871e-06)    );
  // itree = 31
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.357462,0.00235843) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.171721,-0.0541996) , 
21, 0.018319, 1, 0, 0.309289,-0.00309505) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.748651,0.0404536) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.810275,-0.00742061) , 
3, 7.60342, 1, 0, 0.776337,0.00651291) , 
11, 0.71402, 1, 0, 0.534479,0.00153749) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.336657,-0.0197155) , 
0, 1.90474, 1, 0, 0.5,8.04152e-05)    );
  // itree = 32
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.416311,0.0478454) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.283601,-0.0584297) , 
21, 0.00261684, 1, 0, 0.345317,-0.00217672) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.190217,-0.00334503) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.184135,0.0949126) , 
25, 0.0242805, 1, 0, 0.18739,0.0107839) , 
21, 0.00915932, 1, 0, 0.275057,0.00358935) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.744634,-0.00817299) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.594487,-0.0580657) , 
21, 0.00809402, 1, 0, 0.702181,-0.0082058) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.827003,0.0314333) , 
11, 0.981495, 1, 0, 0.73519,-0.00376195) , 
11, 0.618817, 1, 0, 0.5,-4.44347e-06)    );
  // itree = 33
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.33097,-0.01449) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.566248,0.0416757) , 
1, 0.00474034, 1, 0, 0.444421,0.00508679) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.413356,-0.0307022) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.534032,0.00328337) , 
16, 2.10835, 1, 0, 0.481895,-0.00373771) , 
12, 0.184839, 1, 0, 0.471736,-0.00134528) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.647667,0.0211914) , 
16, 7.37982, 1, 0, 0.5,-0.000179573)    );
  // itree = 34
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.627977,-0.0332989) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.45546,0.0130213) , 
21, 0.00173776, 1, 0, 0.511473,-0.000656706) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.273386,0.0414003) , 
21, 0.0182499, 1, 0, 0.466618,0.00170136) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.460351,0.0235753) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.742461,-0.0688373) , 
1, 0.0047613, 1, 0, 0.594339,-0.00480351) , 
10, 20.8571, 1, 0, 0.5,1.20714e-06)    );
  // itree = 35
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.502906,-0.00418898) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.719743,0.0266865) , 
2, 0.019039, 1, 0, 0.557786,0.00122355) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.31536,0.0104545) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.331381,-0.0349008) , 
24, -0.00160489, 1, 0, 0.32555,-0.0062071) , 
25, 0.0263095, 1, 0, 0.483702,-0.00114685) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.616842,0.0290325) , 
10, 24.3333, 1, 0, 0.5,4.39385e-05)    );
  // itree = 36
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.325084,-0.0334915) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.637705,0.0177961) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.426791,-0.00799055) , 
21, 0.00523381, 1, 0, 0.554464,0.00248676) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.293845,-0.0198694) , 
21, 0.0274779, 1, 0, 0.524671,0.00153002) , 
24, -0.00288866, 1, 0, 0.5,-2.68587e-06)    );
  // itree = 37
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.612305,0.027328) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.610789,-0.00947095) , 
4, 0.43115, 1, 0, 0.611176,-0.000131518) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.518212,-0.0455701) , 
0, 1.15389, 1, 0, 0.593035,-0.00300164) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.465729,0.00636476) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.367473,0.0489023) , 
21, 0.00351903, 1, 0, 0.420487,0.00866222) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.277943,-0.00915226) , 
21, 0.0105591, 1, 0, 0.366615,0.00428936) , 
25, 0.0141667, 1, 0, 0.5,-5.79937e-06)    );
  // itree = 38
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.679117,0.0214973) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.653928,-0.0348089) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.483489,-0.00329957) , 
0, 0.476199, 1, 0, 0.516739,-0.00300736) , 
21, 0.000872283, 1, 0, 0.546881,-0.00119345) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.305223,0.0166219) , 
21, 0.0183186, 1, 0, 0.5,-8.90613e-06)    );
  // itree = 39
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.590128,-0.00126961) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.356035,0.0345065) , 
21, 0.00915986, 1, 0, 0.511415,0.00335598) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.24043,-0.0386863) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.79772,0.00576581) , 
11, 0.428412, 1, 0, 0.581021,-0.00363163) , 
14, 8.80796, 1, 0, 0.534479,0.00104059) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.336657,-0.0139447) , 
0, 1.90474, 1, 0, 0.5,1.28842e-05)    );
  // itree = 40
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.29476,0.0492377) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.174118,-0.00902364) , 
25, 0.0101181, 1, 0, 0.216327,0.00423069) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.55257,-0.0491114) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.577909,-0.00562536) , 
14, 1.02714, 1, 0, 0.568538,-0.00813236) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.658158,0.0262775) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.67068,-0.0200391) , 
12, 0.603298, 1, 0, 0.66338,0.00232252) , 
14, 4.31524, 1, 0, 0.624961,-0.00191264) , 
11, 0.238007, 1, 0, 0.5,-3.40031e-05)    );
  // itree = 41
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.430012,0.0180512) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.423273,-0.0427543) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.46556,-0.00763956) , 
24, -0.000318156, 1, 0, 0.447161,-0.0065519) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.516522,-0.00492675) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.601601,0.0452125) , 
8, 0.809524, 1, 0, 0.532629,0.0013881) , 
6, 0.079849, 1, 0, 0.508843,-0.000821626) , 
12, 0.0840467, 1, 0, 0.5,-3.07881e-06)    );
  // itree = 42
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.443818,0.0331355) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.439303,-0.0037737) , 
14, 4.40383, 1, 0, 0.441454,0.00494631) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.483298,0.0117325) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.507443,-0.015703) , 
4, 0.39533, 1, 0, 0.502214,-0.00323269) , 
23, -0.00795373, 1, 0, 0.485446,-0.000975451) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.588958,0.0227209) , 
14, 13.2119, 1, 0, 0.5,3.49259e-06)    );
  // itree = 43
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.558371,0.00585072) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.324716,-0.0224118) , 
25, 0.0263072, 1, 0, 0.494742,-0.000633295) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.389935,0.0226705) , 
22, 0.0645467, 1, 0, 0.466618,0.00144799) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.499022,0.00142225) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.720265,-0.0357275) , 
2, 0.00951832, 1, 0, 0.594339,-0.00409563) , 
10, 20.8571, 1, 0, 0.5,-9.24624e-07)    );
  // itree = 44
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.45246,-0.0459664) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.749763,0.00397026) , 
3, 3.80057, 1, 0, 0.596987,-0.00776237) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.654026,0.0421208) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.72346,-0.037097) , 
16, 5.3918, 1, 0, 0.688033,0.00231656) , 
10, 17.381, 1, 0, 0.64196,-0.00278381) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.23137,0.0347556) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.545233,-0.00717038) , 
3, 3.55543, 1, 0, 0.344851,0.00528858) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.226438,-0.031882) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.673196,0.020043) , 
11, 0.523599, 1, 0, 0.44193,-0.00190424) , 
10, 16.2857, 1, 0, 0.386005,0.00223936) , 
25, 0.010119, 1, 0, 0.5,2.18723e-06)    );
  // itree = 45
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.496507,-0.0136825) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.329029,0.0198759) , 
24, 0.00224642, 1, 0, 0.465432,-0.0025003) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.507836,0.0170636) , 
18, 0.666667, 1, 0, 0.471736,-0.00122982) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.647667,0.0223118) , 
16, 7.37982, 1, 0, 0.5,-1.98484e-05)    );
  // itree = 46
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.450268,-0.0246044) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.588101,0.0205922) , 
26, 17.0179, 1, 0, 0.524589,-0.000761411) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.466868,0.0330557) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.623417,-0.00768815) , 
2, 0.00948454, 1, 0, 0.529183,0.00544536) , 
4, 0.550367, 1, 0, 0.526176,0.00138281) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.317254,-0.0305298) , 
24, 0.0028883, 1, 0, 0.5,3.78623e-07)    );
  // itree = 47
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.439369,0.022159) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.205998,-0.0295697) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.602257,-0.00240292) , 
11, 0.190374, 1, 0, 0.490871,-0.0029761) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.647483,0.0200314) , 
2, 0.0380877, 1, 0, 0.513433,-0.00154561) , 
7, 0.428571, 1, 0, 0.5,-1.03945e-05)    );
  // itree = 48
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.472113,0.0372191) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.329071,-0.017341) , 
21, 0.00479753, 1, 0, 0.431859,0.00815518) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.155618,0.0112368) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.312933,-0.0472958) , 
11, 0.244776, 1, 0, 0.230052,-0.00666628) , 
21, 0.00915932, 1, 0, 0.348653,0.00204421) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.771783,0.0251532) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.73443,-0.0196849) , 
9, 0.343297, 1, 0, 0.752553,0.000439319) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.887084,-0.0862556) , 
26, 27.8466, 1, 0, 0.792707,-0.00401696) , 
11, 0.856824, 1, 0, 0.5,-2.16188e-05)    );
  // itree = 49
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.283991,-0.018484) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.524757,0.0433405) , 
2, 0.0095201, 1, 0, 0.389905,0.00380308) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.250086,0.0140383) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.594974,-0.0163674) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.718677,0.0151603) , 
26, 27.7572, 1, 0, 0.633308,-0.00279776) , 
18, 0.0952381, 1, 0, 0.533647,-0.00106717) , 
24, -0.00160489, 1, 0, 0.5,7.28663e-05)    );
   return;
};
 
// Clean up
inline void ReadMinNodeSize 10::Clear() 
{
   for (unsigned int itree=0; itree<fForest.size(); itree++) { 
      delete fForest[itree]; 
   }
}
   inline double ReadMinNodeSize 10::GetMvaValue( const std::vector<double>& inputValues ) const
   {
      // classifier response value
      double retval = 0;

      // classifier response, sanity check first
      if (!IsStatusClean()) {
         std::cout << "Problem in class \"" << fClassName << "\": cannot return classifier response"
                   << " because status is dirty" << std::endl;
         retval = 0;
      }
      else {
         if (IsNormalised()) {
            // normalise variables
            std::vector<double> iV;
            iV.reserve(inputValues.size());
            int ivar = 0;
            for (std::vector<double>::const_iterator varIt = inputValues.begin();
                 varIt != inputValues.end(); varIt++, ivar++) {
               iV.push_back(NormVariable( *varIt, fVmin[ivar], fVmax[ivar] ));
            }
            retval = GetMvaValue__( iV );
         }
         else {
            retval = GetMvaValue__( inputValues );
         }
      }

      return retval;
   }
