// Class: ReadMinNodeSize 7.5
// Automatically generated by MethodBase::MakeClass
//

/* configuration options =====================================================

#GEN -*-*-*-*-*-*-*-*-*-*-*- general info -*-*-*-*-*-*-*-*-*-*-*-

Method         : BDT::MinNodeSize 7.5
TMVA Release   : 4.2.1         [262657]
ROOT Release   : 6.14/07       [396807]
Creator        : mchristos
Date           : Thu Nov 15 23:19:24 2018
Host           : Linux cmsbuild02.cern.ch 2.6.32-754.3.5.el6.x86_64 #1 SMP Wed Aug 15 08:57:36 CEST 2018 x86_64 x86_64 x86_64 GNU/Linux
Dir            : /cms/mchristos/ANN/FireMVA/2017
Training events: 70707
Analysis type  : [Classification]


#OPT -*-*-*-*-*-*-*-*-*-*-*-*- options -*-*-*-*-*-*-*-*-*-*-*-*-

# Set by User:
V: "False" [Verbose output (short form of "VerbosityLevel" below - overrides the latter one)]
H: "False" [Print method-specific help message]
NTrees: "50" [Number of trees in the forest]
MaxDepth: "3" [Max depth of the decision tree allowed]
MinNodeSize: "7.5%" [Minimum percentage of training events required in a leaf node (default: Classification: 5%, Regression: 0.2%)]
nCuts: "20" [Number of grid points in variable range used in finding optimal cut in node splitting]
BoostType: "Grad" [Boosting type for the trees in the forest (note: AdaCost is still experimental)]
Shrinkage: "1.000000e+00" [Learning rate for GradBoost algorithm]
# Default:
VerbosityLevel: "Default" [Verbosity level]
VarTransform: "None" [List of variable transformations performed before training, e.g., "D_Background,P_Signal,G,N_AllClasses" for: "Decorrelation, PCA-transformation, Gaussianisation, Normalisation, each for the given class of events ('AllClasses' denotes all events of all classes, if no class indication is given, 'All' is assumed)"]
CreateMVAPdfs: "False" [Create PDFs for classifier outputs (signal and background)]
IgnoreNegWeightsInTraining: "False" [Events with negative weights are ignored in the training (but are included for testing and performance evaluation)]
AdaBoostR2Loss: "quadratic" [Type of Loss function in AdaBoostR2]
UseBaggedBoost: "False" [Use only a random subsample of all events for growing the trees in each boost iteration.]
AdaBoostBeta: "5.000000e-01" [Learning rate  for AdaBoost algorithm]
UseRandomisedTrees: "False" [Determine at each node splitting the cut variable only as the best out of a random subset of variables (like in RandomForests)]
UseNvars: "5" [Size of the subset of variables used with RandomisedTree option]
UsePoissonNvars: "True" [Interpret "UseNvars" not as fixed number but as mean of a Poisson distribution in each split with RandomisedTree option]
BaggedSampleFraction: "6.000000e-01" [Relative size of bagged event sample to original size of the data sample (used whenever bagging is used (i.e. UseBaggedBoost, Bagging,)]
UseYesNoLeaf: "True" [Use Sig or Bkg categories, or the purity=S/(S+B) as classification of the leaf node -> Real-AdaBoost]
NegWeightTreatment: "pray" [How to treat events with negative weights in the BDT training (particular the boosting) : IgnoreInTraining;  Boost With inverse boostweight; Pair events with negative and positive weights in training sample and *annihilate* them (experimental!)]
Css: "1.000000e+00" [AdaCost: cost of true signal selected signal]
Cts_sb: "1.000000e+00" [AdaCost: cost of true signal selected bkg]
Ctb_ss: "1.000000e+00" [AdaCost: cost of true bkg    selected signal]
Cbb: "1.000000e+00" [AdaCost: cost of true bkg    selected bkg ]
NodePurityLimit: "5.000000e-01" [In boosting/pruning, nodes with purity > NodePurityLimit are signal; background otherwise.]
SeparationType: "giniindex" [Separation criterion for node splitting]
RegressionLossFunctionBDTG: "huber" [Loss function for BDTG regression.]
HuberQuantile: "7.000000e-01" [In the Huber loss function this is the quantile that separates the core from the tails in the residuals distribution.]
DoBoostMonitor: "False" [Create control plot with ROC integral vs tree number]
UseFisherCuts: "False" [Use multivariate splits using the Fisher criterion]
MinLinCorrForFisher: "8.000000e-01" [The minimum linear correlation between two variables demanded for use in Fisher criterion in node splitting]
UseExclusiveVars: "False" [Variables already used in fisher criterion are not anymore analysed individually for node splitting]
DoPreselection: "False" [and and apply automatic pre-selection for 100% efficient signal (bkg) cuts prior to training]
SigToBkgFraction: "1.000000e+00" [Sig to Bkg ratio used in Training (similar to NodePurityLimit, which cannot be used in real adaboost]
PruneMethod: "nopruning" [Note: for BDTs use small trees (e.g.MaxDepth=3) and NoPruning:  Pruning: Method used for pruning (removal) of statistically insignificant branches ]
PruneStrength: "0.000000e+00" [Pruning strength]
PruningValFraction: "5.000000e-01" [Fraction of events to use for optimizing automatic pruning.]
SkipNormalization: "False" [Skip normalization at initialization, to keep expectation value of BDT output according to the fraction of events]
nEventsMin: "0" [deprecated: Use MinNodeSize (in % of training events) instead]
UseBaggedGrad: "False" [deprecated: Use *UseBaggedBoost* instead:  Use only a random subsample of all events for growing the trees in each iteration.]
GradBaggingFraction: "6.000000e-01" [deprecated: Use *BaggedSampleFraction* instead: Defines the fraction of events to be used in each iteration, e.g. when UseBaggedGrad=kTRUE. ]
UseNTrainEvents: "0" [deprecated: Use *BaggedSampleFraction* instead: Number of randomly picked training events used in randomised (and bagged) trees]
NNodesMax: "0" [deprecated: Use MaxDepth instead to limit the tree size]
##


#VAR -*-*-*-*-*-*-*-*-*-*-*-* variables *-*-*-*-*-*-*-*-*-*-*-*-

NVar 27
abs(ElectronEta)              abs_ElectronEta_              abs(ElectronEta)              abs(ElectronEta)                                                'F'    [1.69258073583e-05,2.49997067451]
ElectronDXY                   ElectronDXY                   ElectronDXY                   ElectronDXY                                                     'F'    [6.64379129489e-08,0.0999782606959]
ElectronDZ                    ElectronDZ                    ElectronDZ                    ElectronDZ                                                      'F'    [4.06895367178e-07,0.199958592653]
ElectronSIP3D                 ElectronSIP3D                 ElectronSIP3D                 ElectronSIP3D                                                   'F'    [0.00396113377064,82.4355926514]
ElectronPtRatio               ElectronPtRatio               ElectronPtRatio               ElectronPtRatio                                                 'F'    [-1,3.24139928818]
ElectronPtRel                 ElectronPtRel                 ElectronPtRel                 ElectronPtRel                                                   'F'    [-1,970.202941895]
ElectronJetLRM                ElectronJetLRM                ElectronJetLRM                ElectronJetLRM                                                  'F'    [-1,0.33393111825]
ElectronJetFD                 ElectronJetFD                 ElectronJetFD                 ElectronJetFD                                                   'F'    [-1,1]
ElectronJetInOutRatio         ElectronJetInOutRatio         ElectronJetInOutRatio         ElectronJetInOutRatio                                           'F'    [-9999,1]
ElectronJetZest               ElectronJetZest               ElectronJetZest               ElectronJetZest                                                 'F'    [-1,1]
ElectronJetNoOfConst          ElectronJetNoOfConst          ElectronJetNoOfConst          ElectronJetNoOfConst                                            'F'    [0,73]
ElectronJetCSV                ElectronJetCSV                ElectronJetCSV                ElectronJetCSV                                                  'F'    [0,0.999627411366]
ElectronRelPFIsoPUCorr        ElectronRelPFIsoPUCorr        ElectronRelPFIsoPUCorr        ElectronRelPFIsoPUCorr                                          'F'    [0,1.76498115063]
ElectronRelTrkIso             ElectronRelTrkIso             ElectronRelTrkIso             ElectronRelTrkIso                                               'F'    [0,61.5004081726]
ElectronPFChargedHadronIso    ElectronPFChargedHadronIso    ElectronPFChargedHadronIso    ElectronPFChargedHadronIso                                      'F'    [0,92.4835739136]
ElectronPFNeutralHadronIso    ElectronPFNeutralHadronIso    ElectronPFNeutralHadronIso    ElectronPFNeutralHadronIso                                      'F'    [0,36.2971611023]
ElectronPFPhotonIso           ElectronPFPhotonIso           ElectronPFPhotonIso           ElectronPFPhotonIso                                             'F'    [0,77.488067627]
ElectronJetMuonEnergyFraction ElectronJetMuonEnergyFraction ElectronJetMuonEnergyFraction ElectronJetMuonEnergyFraction                                   'F'    [0,1]
ElectronJetElectronEnergyFraction ElectronJetElectronEnergyFraction ElectronJetElectronEnergyFraction ElectronJetElectronEnergyFraction                                       'F'    [0,1]
ElectronMissingHits           ElectronMissingHits           ElectronMissingHits           ElectronMissingHits                                             'F'    [0,1]
ElectronPassConversionVeto    ElectronPassConversionVeto    ElectronPassConversionVeto    ElectronPassConversionVeto                                      'F'    [1,1]
ElectronEInverseMinusPInverse ElectronEInverseMinusPInverse ElectronEInverseMinusPInverse ElectronEInverseMinusPInverse                                   'F'    [1.45857645961e-08,0.192345529795]
ElectronHoE                   ElectronHoE                   ElectronHoE                   ElectronHoE                                                     'F'    [0,1.74987196922]
ElectronDeltaPhiTrkSC         ElectronDeltaPhiTrkSC         ElectronDeltaPhiTrkSC         ElectronDeltaPhiTrkSC                                           'F'    [-0.168498814106,0.168645858765]
ElectronDeltaEtaTrkSeedSC     ElectronDeltaEtaTrkSeedSC     ElectronDeltaEtaTrkSeedSC     ElectronDeltaEtaTrkSeedSC                                       'F'    [-0.00673997402191,0.00673961639404]
ElectronFull5x5SigmaIEtaIEta  ElectronFull5x5SigmaIEtaIEta  ElectronFull5x5SigmaIEtaIEta  ElectronFull5x5SigmaIEtaIEta                                    'F'    [0,0.0424999594688]
ElectronPt                    ElectronPt                    ElectronPt                    ElectronPt                                                      'F'    [10.0002174377,1108.92687988]
NSpec 0


============================================================================ */

#include <array>
#include <vector>
#include <cmath>
#include <string>
#include <iostream>

#define NN new MinNodeSize 7.5Node
   
#ifndef MinNodeSize 7.5Node__def
#define MinNodeSize 7.5Node__def
   
class MinNodeSize 7.5Node {
   
public:
   
   // constructor of an essentially "empty" node floating in space
   MinNodeSize 7.5Node ( MinNodeSize 7.5Node* left,MinNodeSize 7.5Node* right,
                          int selector, double cutValue, bool cutType, 
                          int nodeType, double purity, double response ) :
   fLeft         ( left         ),
   fRight        ( right        ),
   fSelector     ( selector     ),
   fCutValue     ( cutValue     ),
   fCutType      ( cutType      ),
   fNodeType     ( nodeType     ),
   fPurity       ( purity       ),
   fResponse     ( response     ){
   }

   virtual ~MinNodeSize 7.5Node();

   // test event if it descends the tree at this node to the right
   virtual bool GoesRight( const std::vector<double>& inputValues ) const;
   MinNodeSize 7.5Node* GetRight( void )  {return fRight; };

   // test event if it descends the tree at this node to the left 
   virtual bool GoesLeft ( const std::vector<double>& inputValues ) const;
   MinNodeSize 7.5Node* GetLeft( void ) { return fLeft; };   

   // return  S/(S+B) (purity) at this node (from  training)

   double GetPurity( void ) const { return fPurity; } 
   // return the node type
   int    GetNodeType( void ) const { return fNodeType; }
   double GetResponse(void) const {return fResponse;}

private:

   MinNodeSize 7.5Node*   fLeft;     // pointer to the left daughter node
   MinNodeSize 7.5Node*   fRight;    // pointer to the right daughter node
   int                     fSelector; // index of variable used in node selection (decision tree)   
   double                  fCutValue; // cut value applied on this node to discriminate bkg against sig
   bool                    fCutType;  // true: if event variable > cutValue ==> signal , false otherwise
   int                     fNodeType; // Type of node: -1 == Bkg-leaf, 1 == Signal-leaf, 0 = internal 
   double                  fPurity;   // Purity of node from training
   double                  fResponse; // Regression response value of node
}; 
   
//_______________________________________________________________________
   MinNodeSize 7.5Node::~MinNodeSize 7.5Node()
{
   if (fLeft  != NULL) delete fLeft;
   if (fRight != NULL) delete fRight;
}; 
   
//_______________________________________________________________________
bool MinNodeSize 7.5Node::GoesRight( const std::vector<double>& inputValues ) const
{
   // test event if it descends the tree at this node to the right
   bool result;
     result = (inputValues[fSelector] > fCutValue );
   if (fCutType == true) return result; //the cuts are selecting Signal ;
   else return !result;
}
   
//_______________________________________________________________________
bool MinNodeSize 7.5Node::GoesLeft( const std::vector<double>& inputValues ) const
{
   // test event if it descends the tree at this node to the left
   if (!this->GoesRight(inputValues)) return true;
   else return false;
}
   
#endif
   
#ifndef IClassifierReader__def
#define IClassifierReader__def

class IClassifierReader {

 public:

   // constructor
   IClassifierReader() : fStatusIsClean( true ) {}
   virtual ~IClassifierReader() {}

   // return classifier response
   virtual double GetMvaValue( const std::vector<double>& inputValues ) const = 0;

   // returns classifier status
   bool IsStatusClean() const { return fStatusIsClean; }

 protected:

   bool fStatusIsClean;
};

#endif

class ReadMinNodeSize 7.5 : public IClassifierReader {

 public:

   // constructor
   ReadMinNodeSize 7.5( std::vector<std::string>& theInputVars )
      : IClassifierReader(),
        fClassName( "ReadMinNodeSize 7.5" ),
        fNvars( 27 ),
        fIsNormalised( false )
   {
      // the training input variables
      const char* inputVars[] = { "abs(ElectronEta)", "ElectronDXY", "ElectronDZ", "ElectronSIP3D", "ElectronPtRatio", "ElectronPtRel", "ElectronJetLRM", "ElectronJetFD", "ElectronJetInOutRatio", "ElectronJetZest", "ElectronJetNoOfConst", "ElectronJetCSV", "ElectronRelPFIsoPUCorr", "ElectronRelTrkIso", "ElectronPFChargedHadronIso", "ElectronPFNeutralHadronIso", "ElectronPFPhotonIso", "ElectronJetMuonEnergyFraction", "ElectronJetElectronEnergyFraction", "ElectronMissingHits", "ElectronPassConversionVeto", "ElectronEInverseMinusPInverse", "ElectronHoE", "ElectronDeltaPhiTrkSC", "ElectronDeltaEtaTrkSeedSC", "ElectronFull5x5SigmaIEtaIEta", "ElectronPt" };

      // sanity checks
      if (theInputVars.size() <= 0) {
         std::cout << "Problem in class \"" << fClassName << "\": empty input vector" << std::endl;
         fStatusIsClean = false;
      }

      if (theInputVars.size() != fNvars) {
         std::cout << "Problem in class \"" << fClassName << "\": mismatch in number of input values: "
                   << theInputVars.size() << " != " << fNvars << std::endl;
         fStatusIsClean = false;
      }

      // validate input variables
      for (size_t ivar = 0; ivar < theInputVars.size(); ivar++) {
         if (theInputVars[ivar] != inputVars[ivar]) {
            std::cout << "Problem in class \"" << fClassName << "\": mismatch in input variable names" << std::endl
                      << " for variable [" << ivar << "]: " << theInputVars[ivar].c_str() << " != " << inputVars[ivar] << std::endl;
            fStatusIsClean = false;
         }
      }

      // initialize min and max vectors (for normalisation)
      fVmin[0] = 0;
      fVmax[0] = 0;
      fVmin[1] = 0;
      fVmax[1] = 0;
      fVmin[2] = 0;
      fVmax[2] = 0;
      fVmin[3] = 0;
      fVmax[3] = 0;
      fVmin[4] = 0;
      fVmax[4] = 0;
      fVmin[5] = 0;
      fVmax[5] = 0;
      fVmin[6] = 0;
      fVmax[6] = 0;
      fVmin[7] = 0;
      fVmax[7] = 0;
      fVmin[8] = 0;
      fVmax[8] = 0;
      fVmin[9] = 0;
      fVmax[9] = 0;
      fVmin[10] = 0;
      fVmax[10] = 0;
      fVmin[11] = 0;
      fVmax[11] = 0;
      fVmin[12] = 0;
      fVmax[12] = 0;
      fVmin[13] = 0;
      fVmax[13] = 0;
      fVmin[14] = 0;
      fVmax[14] = 0;
      fVmin[15] = 0;
      fVmax[15] = 0;
      fVmin[16] = 0;
      fVmax[16] = 0;
      fVmin[17] = 0;
      fVmax[17] = 0;
      fVmin[18] = 0;
      fVmax[18] = 0;
      fVmin[19] = 0;
      fVmax[19] = 0;
      fVmin[20] = 0;
      fVmax[20] = 0;
      fVmin[21] = 0;
      fVmax[21] = 0;
      fVmin[22] = 0;
      fVmax[22] = 0;
      fVmin[23] = 0;
      fVmax[23] = 0;
      fVmin[24] = 0;
      fVmax[24] = 0;
      fVmin[25] = 0;
      fVmax[25] = 0;
      fVmin[26] = 0;
      fVmax[26] = 0;

      // initialize input variable types
      fType[0] = 'F';
      fType[1] = 'F';
      fType[2] = 'F';
      fType[3] = 'F';
      fType[4] = 'F';
      fType[5] = 'F';
      fType[6] = 'F';
      fType[7] = 'F';
      fType[8] = 'F';
      fType[9] = 'F';
      fType[10] = 'F';
      fType[11] = 'F';
      fType[12] = 'F';
      fType[13] = 'F';
      fType[14] = 'F';
      fType[15] = 'F';
      fType[16] = 'F';
      fType[17] = 'F';
      fType[18] = 'F';
      fType[19] = 'F';
      fType[20] = 'F';
      fType[21] = 'F';
      fType[22] = 'F';
      fType[23] = 'F';
      fType[24] = 'F';
      fType[25] = 'F';
      fType[26] = 'F';

      // initialize constants
      Initialize();

   }

   // destructor
   virtual ~ReadMinNodeSize 7.5() {
      Clear(); // method-specific
   }

   // the classifier response
   // "inputValues" is a vector of input values in the same order as the
   // variables given to the constructor
   double GetMvaValue( const std::vector<double>& inputValues ) const override;

 private:

   // method-specific destructor
   void Clear();

   // common member variables
   const char* fClassName;

   const size_t fNvars;
   size_t GetNvar()           const { return fNvars; }
   char   GetType( int ivar ) const { return fType[ivar]; }

   // normalisation of input variables
   const bool fIsNormalised;
   bool IsNormalised() const { return fIsNormalised; }
   double fVmin[27];
   double fVmax[27];
   double NormVariable( double x, double xmin, double xmax ) const {
      // normalise to output range: [-1, 1]
      return 2*(x - xmin)/(xmax - xmin) - 1.0;
   }

   // type of input variable: 'F' or 'I'
   char   fType[27];

   // initialize internal variables
   void Initialize();
   double GetMvaValue__( const std::vector<double>& inputValues ) const;

   // private members (method specific)
   std::vector<MinNodeSize 7.5Node*> fForest;       // i.e. root nodes of decision trees
   std::vector<double>                fBoostWeights; // the weights applied in the individual boosts
};

double ReadMinNodeSize 7.5::GetMvaValue__( const std::vector<double>& inputValues ) const
{
   double myMVA = 0;
   for (unsigned int itree=0; itree<fForest.size(); itree++){
      MinNodeSize 7.5Node *current = fForest[itree];
      while (current->GetNodeType() == 0) { //intermediate node
         if (current->GoesRight(inputValues)) current=(MinNodeSize 7.5Node*)current->GetRight();
         else current=(MinNodeSize 7.5Node*)current->GetLeft();
      }
      myMVA += current->GetResponse();
   }
   return 2.0/(1.0+exp(-2.0*myMVA))-1.0;
};

void ReadMinNodeSize 7.5::Initialize()
{
  // itree = 0
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.119276,-0.761448) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.183056,-0.633887) , 
11, 0.206248, 1, 0, 0.147473,-0.352527) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.448616,-0.102768) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.244828,-0.510344) , 
21, 0.00914059, 1, 0, 0.376342,-0.123658) , 
18, 0.142857, 1, 0, 0.275057,-0.224943) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.587184,0.174369) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.746132,0.492263) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.882889,0.765778) , 
26, 27.8466, 1, 0, 0.78713,0.28713) , 
11, 0.836436, 1, 0, 0.73519,0.23519) , 
11, 0.618817, 1, 0, 0.5,-4.0518e-16)    );
  // itree = 1
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.273263,-0.133506) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.704826,0.16757) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.800127,0.370788) , 
16, 5.3918, 1, 0, 0.737974,0.0949401) , 
11, 0.190405, 1, 0, 0.64196,0.0639452) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.238405,-0.295247) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.312446,-0.12867) , 
10, 16.2857, 1, 0, 0.268937,-0.087671) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.540657,-0.0873816) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.672724,0.132768) , 
16, 2.65301, 1, 0, 0.602201,0.00558503) , 
3, 3.92928, 1, 0, 0.386005,-0.0549124) , 
25, 0.010119, 1, 0, 0.5,-0.00197663)    );
  // itree = 2
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.121233,-0.160661) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.164076,0.0717687) , 
0, 1.66669, 1, 0, 0.142588,-0.012676) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.518719,-0.293962) , 
11, 0.571187, 1, 0, 0.243627,-0.0406526) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.450019,-0.117039) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.604549,0.037632) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.716634,0.185334) , 
5, 2.47789, 1, 0, 0.649196,0.0348443) , 
10, 11.2857, 1, 0, 0.607234,0.0177031) , 
18, 0.047619, 1, 0, 0.5,0.000492952)    );
  // itree = 3
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.183082,-0.128258) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.432227,-0.0217901) , 
11, 0.285545, 1, 0, 0.270501,-0.0288373) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.485085,0.075326) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.632851,-0.048032) , 
3, 3.92014, 1, 0, 0.5486,0.0081714) , 
3, 1.49922, 1, 0, 0.42159,-0.0087308) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.644734,0.156952) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.820286,0.0436815) , 
11, 0.904425, 1, 0, 0.755416,0.0309102) , 
3, 7.85459, 1, 0, 0.5,0.000580194)    );
  // itree = 4
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.235684,-0.0118582) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.396811,0.148735) , 
11, 0.412506, 1, 0, 0.26548,0.007429) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.68462,-0.115365) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.803898,0.0771706) , 
14, 8.74342, 1, 0, 0.720784,-0.0213689) , 
11, 0.618817, 1, 0, 0.483702,-0.00637354) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.616842,0.13696) , 
10, 24.3333, 1, 0, 0.5,-0.000359315)    );
  // itree = 5
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.604234,0.0355677) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.768179,0.220665) , 
26, 30.9112, 1, 0, 0.647761,0.0267918) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.388291,-0.0475369) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.817498,0.106384) , 
11, 0.952026, 1, 0, 0.469497,-0.00705179) , 
21, 0.00261682, 1, 0, 0.546881,0.00763959) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.149593,-0.0529217) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.472936,-0.119962) , 
11, 0.333199, 1, 0, 0.305223,-0.0289643) , 
21, 0.0183186, 1, 0, 0.5,0.000538541)    );
  // itree = 6
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.550385,0.0845264) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.830503,-0.103526) , 
11, 0.856824, 1, 0, 0.686327,0.00480826) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.635005,-0.0306656) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.546668,-0.146652) , 
0, 0.55685, 1, 0, 0.584916,-0.0308546) , 
25, 0.00915508, 1, 0, 0.64196,-0.0107942) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.358933,0.0521086) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.26839,-0.0474746) , 
25, 0.0286225, 1, 0, 0.317228,0.00231274) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.786616,0.142475) , 
11, 0.951998, 1, 0, 0.386005,0.0094819) , 
25, 0.010119, 1, 0, 0.5,0.000451494)    );
  // itree = 7
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.23791,0.0204972) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.502385,-0.085352) , 
18, 0.0952381, 1, 0, 0.389905,-0.0155687) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.342274,0.0685172) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.776505,0.0163788) , 
11, 0.618817, 1, 0, 0.588201,0.0132234) , 
24, -0.00160496, 1, 0, 0.532105,0.00507838) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.251748,0.00468481) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.446141,-0.123675) , 
18, 0.333333, 1, 0, 0.346032,-0.0216187) , 
24, 0.00224642, 1, 0, 0.5,0.000472106)    );
  // itree = 8
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.334578,0.0170614) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.178517,-0.118601) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.470614,-0.0255263) , 
11, 0.142793, 1, 0, 0.393018,-0.0156483) , 
4, 0.39533, 1, 0, 0.380118,-0.0110481) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.361405,0.0878616) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.765301,0.0429325) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.736224,-0.0768748) , 
6, 0.141922, 1, 0, 0.758375,0.00448765) , 
11, 0.618817, 1, 0, 0.639388,0.0126142) , 
1, 0.00476093, 1, 0, 0.5,-0.000107059)    );
  // itree = 9
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.457989,0.0140659) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.462802,-0.0338676) , 
12, 0.492903, 1, 0, 0.459654,-0.000609474) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.634904,0.05366) , 
16, 7.37982, 1, 0, 0.487929,0.00199834) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.631349,-0.0665024) , 
2, 0.0571313, 1, 0, 0.5,-0.000182254)    );
  // itree = 10
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.443215,0.0507144) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.464039,-0.00512162) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.551051,-0.0705608) , 
2, 0.028432, 1, 0, 0.475764,-0.00492473) , 
4, 0.356867, 1, 0, 0.471489,-0.00208339) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.778179,0.0667837) , 
3, 15.7052, 1, 0, 0.5,4.68824e-05)    );
  // itree = 11
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.487197,0.0548649) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.828294,-0.00965489) , 
11, 0.856665, 1, 0, 0.647215,0.00919613) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.557009,-0.0567663) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.376307,0.0131877) , 
25, 0.0141667, 1, 0, 0.434645,-0.00306573) , 
0, 0.95238, 1, 0, 0.518606,0.00177748) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.282198,-0.0641588) , 
21, 0.0366373, 1, 0, 0.5,6.47052e-05)    );
  // itree = 12
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.159764,0.0287857) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.387944,-0.0600606) , 
11, 0.215324, 1, 0, 0.292144,-0.00976226) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.347799,-0.015323) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.678742,0.0365618) , 
11, 0.516814, 1, 0, 0.486849,0.00237064) , 
18, 0.47619, 1, 0, 0.37991,-0.00429319) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.817269,0.0970095) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.794447,-0.0241788) , 
9, 0.350324, 1, 0, 0.805554,0.0108973) , 
11, 0.904425, 1, 0, 0.5,-7.38827e-06)    );
  // itree = 13
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.663699,0.0164574) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.535025,-0.0310733) , 
21, 0.00130843, 1, 0, 0.576592,-0.0054173) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.185039,0.0527146) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.630074,-0.0274819) , 
11, 0.618799, 1, 0, 0.337858,0.00545508) , 
21, 0.00915932, 1, 0, 0.493857,-0.00164942) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.542601,0.0401003) , 
15, 3.45687, 1, 0, 0.5,0.000159225)    );
  // itree = 14
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.269638,-0.100938) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.200975,-0.0190165) , 
0, 1.42829, 1, 0, 0.231843,-0.0178116) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.242358,-0.0342914) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.310083,0.0312516) , 
6, 0.104048, 1, 0, 0.284522,0.00261981) , 
6, 0.079849, 1, 0, 0.265928,-0.00459161) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.575003,0.0492185) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.721506,-0.0727762) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.806321,0.0153792) , 
11, 0.906373, 1, 0, 0.787139,-0.00198491) , 
11, 0.836427, 1, 0, 0.725842,0.00430828) , 
11, 0.571216, 1, 0, 0.5,-6.20383e-05)    );
  // itree = 15
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.235332,0.0118233) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.588654,-0.0433481) , 
11, 0.333185, 1, 0, 0.464745,-0.00910123) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.479064,0.0507486) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.522668,-0.00527261) , 
12, 0.354366, 1, 0, 0.515148,0.00132326) , 
14, 4.40398, 1, 0, 0.496359,-0.00256271) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.522923,0.0448341) , 
18, 0.666667, 1, 0, 0.5,-3.93909e-05)    );
  // itree = 16
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.234122,-0.0477573) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.307041,-0.00707279) , 
24, -0.000962147, 1, 0, 0.281439,-0.00665801) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.447099,0.026588) , 
1, 0.0095218, 1, 0, 0.305552,-0.00417571) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.738318,-0.0206255) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.791965,0.0736497) , 
8, 0.619048, 1, 0, 0.773005,0.012141) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.749791,-0.0259364) , 
9, 0.422913, 1, 0, 0.765766,0.00574999) , 
11, 0.761621, 1, 0, 0.5,1.8067e-05)    );
  // itree = 17
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.30381,0.0358555) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.737418,0.00375712) , 
11, 0.618772, 1, 0, 0.520938,0.00649552) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.473497,-0.0607742) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.659006,0.0563977) , 
26, 19.6679, 1, 0, 0.555031,-0.00444297) , 
12, 0.588327, 1, 0, 0.531027,0.00325853) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.540823,-0.0591375) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.276398,0.0114184) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.594901,-0.0259503) , 
3, 3.94709, 1, 0, 0.388056,-0.00106085) , 
0, 0.952207, 1, 0, 0.435569,-0.0064578) , 
24, 0.000962649, 1, 0, 0.5,0.000100403)    );
  // itree = 18
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.5094,-0.00441845) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.574823,0.0657617) , 
8, 0.809524, 1, 0, 0.523023,0.00299562) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.443655,-0.0345317) , 
7, 0.714286, 1, 0, 0.514943,0.00147424) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.32403,-0.0492126) , 
0, 2.14283, 1, 0, 0.5,-3.35403e-07)    );
  // itree = 19
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.468415,0.0189094) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.517734,-0.0114632) , 
12, 0.336187, 1, 0, 0.50055,-4.67644e-05) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.500977,-0.040715) , 
9, 0.52381, 1, 0, 0.500585,-0.00118217) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.493793,0.0351076) , 
18, 0.714286, 1, 0, 0.5,3.77375e-06)    );
  // itree = 20
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.330548,-0.0486674) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.538065,0.0265025) , 
5, 1.47646, 1, 0, 0.426592,-0.00398047) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.541807,0.0771263) , 
26, 16.332, 1, 0, 0.473501,0.00694195) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.398395,0.0265138) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.578078,-0.0124196) , 
10, 11.2857, 1, 0, 0.534773,-0.000722103) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.341091,-0.0483467) , 
23, 0.0241553, 1, 0, 0.510037,-0.00263035) , 
4, 0.4138, 1, 0, 0.5,-6.72115e-07)    );
  // itree = 21
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.342457,-0.0330399) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.491713,0.00448903) , 
10, 10, 1, 0, 0.471854,-0.000228676) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.581277,0.0521018) , 
10, 21.7143, 1, 0, 0.483702,0.0015411) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.616842,-0.0394754) , 
10, 24.3333, 1, 0, 0.5,-2.30932e-05)    );
  // itree = 22
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.629473,0.0264467) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.488665,0.0044574) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.419466,-0.022382) , 
7, 0.714286, 1, 0, 0.480091,0.000311962) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.515963,-0.0263156) , 
12, 0.75642, 1, 0, 0.485442,-0.000903222) , 
0, 0.238108, 1, 0, 0.5,7.14125e-06)    );
  // itree = 23
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.380058,-0.0139352) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.491417,0.0188713) , 
9, 0.238095, 1, 0, 0.464907,0.00393185) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.26631,-0.0599854) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.224665,0.0151536) , 
25, 0.0222619, 1, 0, 0.246542,-0.00731682) , 
21, 0.0183186, 1, 0, 0.417407,0.00148498) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.845205,0.00827253) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.784422,-0.049199) , 
6, 0.117599, 1, 0, 0.81737,-0.00568991) , 
11, 0.952026, 1, 0, 0.5,3.35945e-06)    );
  // itree = 24
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.466972,0.0213806) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.453708,0.00208347) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.572352,-0.0181235) , 
23, -0.00871826, 1, 0, 0.532853,-0.00358799) , 
7, 0.428571, 1, 0, 0.522344,-0.00195398) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.190982,0.0157193) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.337833,-0.0173192) , 
11, 0.217593, 1, 0, 0.26792,-0.00124784) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.743232,0.0474304) , 
11, 0.761586, 1, 0, 0.441776,0.00510216) , 
23, 0.00810078, 1, 0, 0.5,2.88123e-06)    );
  // itree = 25
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.702823,0.0357841) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.207854,-0.0199603) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.621849,0.00513553) , 
11, 0.237999, 1, 0, 0.490853,-0.000642762) , 
25, 0.00867334, 1, 0, 0.518223,0.000932083) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.30284,-0.0308633) , 
25, 0.0364285, 1, 0, 0.5,2.65139e-05)    );
  // itree = 26
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.207305,0.0241167) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.304242,-0.0391894) , 
3, 1.44757, 1, 0, 0.237462,0.000218202) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.435308,0.0516199) , 
3, 3.37371, 1, 0, 0.275057,0.00396171) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.682976,-0.00756828) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.77784,-0.0561681) , 
3, 7.88362, 1, 0, 0.721208,-0.00826196) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.773744,0.0240517) , 
15, 1.72844, 1, 0, 0.73519,-0.0041519) , 
11, 0.618817, 1, 0, 0.5,-4.75312e-06)    );
  // itree = 27
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.203066,-0.0440849) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.258425,0.0180465) , 
6, 0.0710089, 1, 0, 0.243411,0.000672898) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.442505,-0.0288044) , 
11, 0.408009, 1, 0, 0.29343,-0.00226223) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.718395,0.0413704) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.71378,-0.00229483) , 
4, 0.479853, 1, 0, 0.715901,0.00641226) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.828761,-0.0161392) , 
14, 8.63049, 1, 0, 0.754791,0.00283848) , 
11, 0.71402, 1, 0, 0.5,2.15631e-05)    );
  // itree = 28
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.517439,-0.00628162) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.820494,0.036797) , 
3, 7.11197, 1, 0, 0.611534,0.00176435) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.269064,0.00238582) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.588273,-0.0386282) , 
3, 3.78146, 1, 0, 0.386821,-0.00472863) , 
0, 1.19044, 1, 0, 0.496359,-0.00156358) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.522923,0.0280454) , 
18, 0.666667, 1, 0, 0.5,-9.57237e-06)    );
  // itree = 29
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.273263,0.0575633) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.645747,-0.0669813) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.796982,-0.00443786) , 
3, 3.80057, 1, 0, 0.737974,-0.00972987) , 
11, 0.190405, 1, 0, 0.64196,-0.003894) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.168568,-0.0823457) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.161615,0.0205386) , 
25, 0.0270747, 1, 0, 0.165132,-0.00880892) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.586642,0.061973) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.415714,0.00291485) , 
25, 0.0239967, 1, 0, 0.474169,0.00798652) , 
11, 0.1904, 1, 0, 0.386005,0.003195) , 
25, 0.010119, 1, 0, 0.5,3.77614e-05)    );
  // itree = 30
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.254248,0.0548578) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.24363,0.0116565) , 
12, 0.311573, 1, 0, 0.247886,0.00811981) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.241563,-0.0255674) , 
15, 1.26904, 1, 0, 0.246029,0.00372804) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.450087,0.0283425) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.688575,-0.00244553) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.474359,-0.0638788) , 
25, 0.0262999, 1, 0, 0.650617,-0.00494982) , 
10, 11.2857, 1, 0, 0.608193,-0.00164788) , 
18, 0.0952381, 1, 0, 0.5,-4.18863e-05)    );
  // itree = 31
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.317921,-0.0527856) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.416892,0.00632118) , 
6, 0.0937712, 1, 0, 0.366712,-0.00664491) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.42932,-0.00335496) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.662818,0.0304563) , 
18, 0.407701, 1, 0, 0.564043,0.00541154) , 
5, 1.22304, 1, 0, 0.503886,0.00173607) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.477018,0.0114468) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.496666,-0.0687593) , 
6, 0.0795161, 1, 0, 0.484422,-0.00718465) , 
4, 0.615771, 1, 0, 0.5,-4.4788e-05)    );
  // itree = 32
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.459021,0.0393611) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.47755,0.00166794) , 
12, 0.575097, 1, 0, 0.467608,0.00675445) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.51147,-0.0399519) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.613785,-0.00476901) , 
24, -0.000960283, 1, 0, 0.584947,-0.00478634) , 
9, 0.238095, 1, 0, 0.559134,-0.00224745) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.319434,0.054487) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.347804,-0.0429214) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.310595,0.044891) , 
24, 0.00197208, 1, 0, 0.328107,0.000606044) , 
24, -0.00160489, 1, 0, 0.324935,0.00665894) , 
25, 0.0283333, 1, 0, 0.5,1.35772e-06)    );
  // itree = 33
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.309016,-0.0379659) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.438936,0.027294) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.567677,0.00322912) , 
24, -0.00157412, 1, 0, 0.543663,0.00248998) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.304285,-0.0328301) , 
24, 0.00331636, 1, 0, 0.517875,0.00108939) , 
24, -0.00353055, 1, 0, 0.5,-4.89686e-05)    );
  // itree = 34
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.47755,-0.0548099) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.492232,-0.00448751) , 
4, 0.550412, 1, 0, 0.485946,-0.00883245) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.582864,0.0148197) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.67186,-0.02087) , 
16, 5.3918, 1, 0, 0.617951,0.000750813) , 
10, 13.9048, 1, 0, 0.58197,-0.00186133) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.286985,0.0102701) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.350886,0.0502665) , 
16, 1.45258, 1, 0, 0.313832,0.00873953) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.396923,-0.0330566) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.38405,0.0190437) , 
14, 6.66694, 1, 0, 0.390733,-0.00326208) , 
10, 15.7143, 1, 0, 0.348154,0.00338316) , 
25, 0.0242857, 1, 0, 0.5,-2.27479e-05)    );
  // itree = 35
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.439772,-0.0455414) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.280563,-0.00158673) , 
25, 0.0263026, 1, 0, 0.359537,-0.00818049) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.460271,0.0165738) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.53606,-0.00985207) , 
16, 2.61038, 1, 0, 0.501899,0.000794413) , 
16, 0.702782, 1, 0, 0.471736,-0.0011072) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.433267,0.0519363) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.859423,-0.0304848) , 
11, 0.761525, 1, 0, 0.647667,0.00572404) , 
16, 7.37982, 1, 0, 0.5,-9.72028e-06)    );
  // itree = 36
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.433781,0.013103) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.25254,-0.0478268) , 
0, 1.19044, 1, 0, 0.324722,-0.00749383) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.194792,0.0396593) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.151549,-0.0354703) , 
21, 0.0266068, 1, 0, 0.177952,0.00316303) , 
21, 0.00915932, 1, 0, 0.258705,-0.00270038) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.629347,0.0380099) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.762484,0.00163057) , 
3, 3.95022, 1, 0, 0.714483,0.00523225) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.688392,-0.0422633) , 
6, 0.157613, 1, 0, 0.710784,0.00235963) , 
11, 0.523614, 1, 0, 0.5,3.7636e-07)    );
  // itree = 37
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.576451,-0.009172) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.56552,0.0237199) , 
23, 0.00211709, 1, 0, 0.57231,0.00107458) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.176852,-0.00231289) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.632873,-0.0516204) , 
11, 0.618799, 1, 0, 0.324914,-0.0066084) , 
21, 0.00915932, 1, 0, 0.484497,-0.00165249) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.536443,-0.00605313) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.601856,0.0449686) , 
14, 3.86689, 1, 0, 0.571279,0.00726949) , 
6, 0.14337, 1, 0, 0.5,-5.86219e-05)    );
  // itree = 38
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.160713,0.00491683) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.45952,-0.0568598) , 
18, 0.0952381, 1, 0, 0.342628,-0.0119094) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.375897,0.0320696) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.598914,-0.0137506) , 
1, 0.00473485, 1, 0, 0.458201,0.00457155) , 
2, 0.0022675, 1, 0, 0.407055,-0.00272193) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.787382,-0.0179068) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.426193,-0.00907618) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.634448,0.0369447) , 
18, 0.380952, 1, 0, 0.554571,0.00700576) , 
0, 0.833335, 1, 0, 0.620175,0.00359561) , 
2, 0.00952223, 1, 0, 0.5,3.32411e-05)    );
  // itree = 39
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.491773,0.0156323) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.815115,-0.0275531) , 
11, 0.904425, 1, 0, 0.606945,0.000963895) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.352752,0.0104744) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.468565,-0.0472187) , 
10, 15.4286, 1, 0, 0.415022,-0.00670171) , 
21, 0.0061059, 1, 0, 0.546881,-0.00143513) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.15547,-0.00363402) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.513744,0.040139) , 
11, 0.428399, 1, 0, 0.305223,0.00596223) , 
21, 0.0183186, 1, 0, 0.5,-6.56119e-08)    );
  // itree = 40
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.24006,-0.00974666) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.528963,-0.0402586) , 
11, 0.612016, 1, 0, 0.299751,-0.00587395) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.422151,-0.0154921) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.441831,0.043714) , 
8, 0.714286, 1, 0, 0.430375,0.00291289) , 
16, 3.68991, 1, 0, 0.348653,-0.00258439) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.683638,-0.0297067) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.792987,0.0706273) , 
26, 15.0991, 1, 0, 0.752553,0.0103783) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.887084,-0.0420023) , 
26, 27.8466, 1, 0, 0.792707,0.0050476) , 
11, 0.856824, 1, 0, 0.5,1.68244e-05)    );
  // itree = 41
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.323955,0.00711542) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.291453,-0.0224376) , 
24, 0.000320001, 1, 0, 0.309289,-0.0019576) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.796792,0.00441088) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.707866,0.044652) , 
21, 0.00905106, 1, 0, 0.776337,0.00472136) , 
11, 0.71402, 1, 0, 0.534479,0.0012627) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.209805,0.0158135) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.494216,-0.0435249) , 
11, 0.475971, 1, 0, 0.336657,-0.00514858) , 
0, 1.90474, 1, 0, 0.5,0.000145255)    );
  // itree = 42
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.48886,-0.00776205) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.397607,-0.0433045) , 
23, 0.00810078, 1, 0, 0.46246,-0.00559718) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.559567,0.0236618) , 
6, 0.140803, 1, 0, 0.480958,-0.0028986) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.46247,0.0303235) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.508554,-0.0076119) , 
12, 0.155786, 1, 0, 0.498112,0.000542394) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.607566,0.0450039) , 
14, 12.9457, 1, 0, 0.51463,0.00224043) , 
24, -0.000321121, 1, 0, 0.5,7.57824e-06)    );
  // itree = 43
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.233878,0.00244169) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.720522,-0.0256026) , 
11, 0.618799, 1, 0, 0.44534,-0.00320577) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.647757,0.0305093) , 
2, 0.0380877, 1, 0, 0.475244,-0.00120646) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.479818,-0.0519336) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.628753,0.0976482) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.633836,0.0268378) , 
12, 0.292199, 1, 0, 0.631308,0.0211275) , 
13, 0.154006, 1, 0, 0.562799,0.00304908) , 
18, 0.571429, 1, 0, 0.5,-3.22932e-06)    );
  // itree = 44
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.33363,-0.0137403) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.521004,0.0182511) , 
1, 0.00181193, 1, 0, 0.454525,0.0023384) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.707483,-0.0234773) , 
1, 0.0190247, 1, 0, 0.483207,0.00124895) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.636513,-0.0277093) , 
2, 0.0476095, 1, 0, 0.5,6.21948e-05)    );
  // itree = 45
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.46448,0.00540096) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.327337,-0.0225043) , 
22, 0.0833272, 1, 0, 0.441697,0.000292163) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.597376,-0.021483) , 
2, 0.0285659, 1, 0, 0.465462,-0.000881867) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.701792,0.0160982) , 
1, 0.0190435, 1, 0, 0.5,8.99579e-06)    );
  // itree = 46
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.53643,0.0360369) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.366964,-0.0380781) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.574691,-0.00545327) , 
24, -0.00224651, 1, 0, 0.549301,-0.00292528) , 
4, 0.365526, 1, 0, 0.547597,-0.00106747) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.260451,0.0309849) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.254353,0.0229976) , 
0, 2.02377, 1, 0, 0.257312,0.00842526) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.515242,-0.0147961) , 
3, 3.78212, 1, 0, 0.348195,0.00341196) , 
0, 1.7857, 1, 0, 0.5,1.77077e-06)    );
  // itree = 47
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.16485,-0.00104162) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.617333,-0.0441576) , 
11, 0.618799, 1, 0, 0.295643,-0.00482621) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.534792,0.0126749) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.717662,-0.0213705) , 
1, 0.00948614, 1, 0, 0.587993,0.00118754) , 
18, 0.380952, 1, 0, 0.475704,-0.00112228) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.641888,0.0186656) , 
2, 0.0380877, 1, 0, 0.5,-1.67625e-05)    );
  // itree = 48
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.194075,-0.00212033) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.299985,-0.0324246) , 
11, 0.174523, 1, 0, 0.249398,-0.00604555) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.29997,0.022147) , 
4, 0.638631, 1, 0, 0.258705,-0.00356713) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.665408,0.019066) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.717182,0.0659624) , 
8, 0.614852, 1, 0, 0.694633,0.0147814) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.683361,0.0210889) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.729727,-0.0182078) , 
23, -0.00801821, 1, 0, 0.718935,-0.00270632) , 
9, 0.28974, 1, 0, 0.710784,0.0031591) , 
11, 0.523614, 1, 0, 0.5,2.29601e-05)    );
  // itree = 49
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.344997,-0.0245439) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.423383,0.00609506) , 
6, 0.0710089, 1, 0, 0.405045,-0.00010866) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.550975,-0.0349719) , 
2, 0.0285659, 1, 0, 0.422483,-0.00154566) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.642464,0.040433) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.697554,0.0161779) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.737822,-0.0412459) , 
8, 0.714286, 1, 0, 0.717808,-0.00328684) , 
14, 3.68213, 1, 0, 0.688188,0.00385468) , 
1, 0.0095218, 1, 0, 0.5,2.98382e-05)    );
   return;
};
 
// Clean up
inline void ReadMinNodeSize 7.5::Clear() 
{
   for (unsigned int itree=0; itree<fForest.size(); itree++) { 
      delete fForest[itree]; 
   }
}
   inline double ReadMinNodeSize 7.5::GetMvaValue( const std::vector<double>& inputValues ) const
   {
      // classifier response value
      double retval = 0;

      // classifier response, sanity check first
      if (!IsStatusClean()) {
         std::cout << "Problem in class \"" << fClassName << "\": cannot return classifier response"
                   << " because status is dirty" << std::endl;
         retval = 0;
      }
      else {
         if (IsNormalised()) {
            // normalise variables
            std::vector<double> iV;
            iV.reserve(inputValues.size());
            int ivar = 0;
            for (std::vector<double>::const_iterator varIt = inputValues.begin();
                 varIt != inputValues.end(); varIt++, ivar++) {
               iV.push_back(NormVariable( *varIt, fVmin[ivar], fVmax[ivar] ));
            }
            retval = GetMvaValue__( iV );
         }
         else {
            retval = GetMvaValue__( inputValues );
         }
      }

      return retval;
   }
