// Class: Read50 Trees
// Automatically generated by MethodBase::MakeClass
//

/* configuration options =====================================================

#GEN -*-*-*-*-*-*-*-*-*-*-*- general info -*-*-*-*-*-*-*-*-*-*-*-

Method         : BDT::50 Trees
TMVA Release   : 4.2.1         [262657]
ROOT Release   : 6.14/07       [396807]
Creator        : mchristos
Date           : Wed Nov 14 20:11:43 2018
Host           : Linux cmsbuild02.cern.ch 2.6.32-754.3.5.el6.x86_64 #1 SMP Wed Aug 15 08:57:36 CEST 2018 x86_64 x86_64 x86_64 GNU/Linux
Dir            : /cms/mchristos/ANN/FireMVA/2017
Training events: 158971
Analysis type  : [Classification]


#OPT -*-*-*-*-*-*-*-*-*-*-*-*- options -*-*-*-*-*-*-*-*-*-*-*-*-

# Set by User:
V: "False" [Verbose output (short form of "VerbosityLevel" below - overrides the latter one)]
H: "False" [Print method-specific help message]
NTrees: "50" [Number of trees in the forest]
MaxDepth: "3" [Max depth of the decision tree allowed]
MinNodeSize: "2.5%" [Minimum percentage of training events required in a leaf node (default: Classification: 5%, Regression: 0.2%)]
nCuts: "20" [Number of grid points in variable range used in finding optimal cut in node splitting]
BoostType: "Grad" [Boosting type for the trees in the forest (note: AdaCost is still experimental)]
Shrinkage: "1.000000e+00" [Learning rate for GradBoost algorithm]
# Default:
VerbosityLevel: "Default" [Verbosity level]
VarTransform: "None" [List of variable transformations performed before training, e.g., "D_Background,P_Signal,G,N_AllClasses" for: "Decorrelation, PCA-transformation, Gaussianisation, Normalisation, each for the given class of events ('AllClasses' denotes all events of all classes, if no class indication is given, 'All' is assumed)"]
CreateMVAPdfs: "False" [Create PDFs for classifier outputs (signal and background)]
IgnoreNegWeightsInTraining: "False" [Events with negative weights are ignored in the training (but are included for testing and performance evaluation)]
AdaBoostR2Loss: "quadratic" [Type of Loss function in AdaBoostR2]
UseBaggedBoost: "False" [Use only a random subsample of all events for growing the trees in each boost iteration.]
AdaBoostBeta: "5.000000e-01" [Learning rate  for AdaBoost algorithm]
UseRandomisedTrees: "False" [Determine at each node splitting the cut variable only as the best out of a random subset of variables (like in RandomForests)]
UseNvars: "5" [Size of the subset of variables used with RandomisedTree option]
UsePoissonNvars: "True" [Interpret "UseNvars" not as fixed number but as mean of a Poisson distribution in each split with RandomisedTree option]
BaggedSampleFraction: "6.000000e-01" [Relative size of bagged event sample to original size of the data sample (used whenever bagging is used (i.e. UseBaggedBoost, Bagging,)]
UseYesNoLeaf: "True" [Use Sig or Bkg categories, or the purity=S/(S+B) as classification of the leaf node -> Real-AdaBoost]
NegWeightTreatment: "pray" [How to treat events with negative weights in the BDT training (particular the boosting) : IgnoreInTraining;  Boost With inverse boostweight; Pair events with negative and positive weights in training sample and *annihilate* them (experimental!)]
Css: "1.000000e+00" [AdaCost: cost of true signal selected signal]
Cts_sb: "1.000000e+00" [AdaCost: cost of true signal selected bkg]
Ctb_ss: "1.000000e+00" [AdaCost: cost of true bkg    selected signal]
Cbb: "1.000000e+00" [AdaCost: cost of true bkg    selected bkg ]
NodePurityLimit: "5.000000e-01" [In boosting/pruning, nodes with purity > NodePurityLimit are signal; background otherwise.]
SeparationType: "giniindex" [Separation criterion for node splitting]
RegressionLossFunctionBDTG: "huber" [Loss function for BDTG regression.]
HuberQuantile: "7.000000e-01" [In the Huber loss function this is the quantile that separates the core from the tails in the residuals distribution.]
DoBoostMonitor: "False" [Create control plot with ROC integral vs tree number]
UseFisherCuts: "False" [Use multivariate splits using the Fisher criterion]
MinLinCorrForFisher: "8.000000e-01" [The minimum linear correlation between two variables demanded for use in Fisher criterion in node splitting]
UseExclusiveVars: "False" [Variables already used in fisher criterion are not anymore analysed individually for node splitting]
DoPreselection: "False" [and and apply automatic pre-selection for 100% efficient signal (bkg) cuts prior to training]
SigToBkgFraction: "1.000000e+00" [Sig to Bkg ratio used in Training (similar to NodePurityLimit, which cannot be used in real adaboost]
PruneMethod: "nopruning" [Note: for BDTs use small trees (e.g.MaxDepth=3) and NoPruning:  Pruning: Method used for pruning (removal) of statistically insignificant branches ]
PruneStrength: "0.000000e+00" [Pruning strength]
PruningValFraction: "5.000000e-01" [Fraction of events to use for optimizing automatic pruning.]
SkipNormalization: "False" [Skip normalization at initialization, to keep expectation value of BDT output according to the fraction of events]
nEventsMin: "0" [deprecated: Use MinNodeSize (in % of training events) instead]
UseBaggedGrad: "False" [deprecated: Use *UseBaggedBoost* instead:  Use only a random subsample of all events for growing the trees in each iteration.]
GradBaggingFraction: "6.000000e-01" [deprecated: Use *BaggedSampleFraction* instead: Defines the fraction of events to be used in each iteration, e.g. when UseBaggedGrad=kTRUE. ]
UseNTrainEvents: "0" [deprecated: Use *BaggedSampleFraction* instead: Number of randomly picked training events used in randomised (and bagged) trees]
NNodesMax: "0" [deprecated: Use MaxDepth instead to limit the tree size]
##


#VAR -*-*-*-*-*-*-*-*-*-*-*-* variables *-*-*-*-*-*-*-*-*-*-*-*-

NVar 29
MuonPt                        MuonPt                        MuonPt                        MuonPt                                                          'F'    [10.0003871918,309.485809326]
abs(MuonEta)                  abs_MuonEta_                  abs(MuonEta)                  abs(MuonEta)                                                    'F'    [5.86361784372e-06,2.39989900589]
MuonDXY                       MuonDXY                       MuonDXY                       MuonDXY                                                         'F'    [3.86541465502e-09,0.04999172315]
MuonDZ                        MuonDZ                        MuonDZ                        MuonDZ                                                          'F'    [2.31312702326e-09,0.0999953448772]
MuonSIP3D                     MuonSIP3D                     MuonSIP3D                     MuonSIP3D                                                       'F'    [0.00528861023486,84.1137466431]
MuonPtRatio                   MuonPtRatio                   MuonPtRatio                   MuonPtRatio                                                     'F'    [-1,1.42276537418]
MuonPtRel                     MuonPtRel                     MuonPtRel                     MuonPtRel                                                       'F'    [-1,63.2444343567]
MuonJetLRM                    MuonJetLRM                    MuonJetLRM                    MuonJetLRM                                                      'F'    [-1,0.342095643282]
MuonJetFD                     MuonJetFD                     MuonJetFD                     MuonJetFD                                                       'F'    [-1,1]
MuonJetInOutRatio             MuonJetInOutRatio             MuonJetInOutRatio             MuonJetInOutRatio                                               'F'    [-9999,1]
MuonJetZest                   MuonJetZest                   MuonJetZest                   MuonJetZest                                                     'F'    [-1,1]
MuonJetNoOfConst              MuonJetNoOfConst              MuonJetNoOfConst              MuonJetNoOfConst                                                'F'    [0,63]
MuonJetCSV                    MuonJetCSV                    MuonJetCSV                    MuonJetCSV                                                      'F'    [0,0.999629497528]
MuonRelPFIsoPUCorr            MuonRelPFIsoPUCorr            MuonRelPFIsoPUCorr            MuonRelPFIsoPUCorr                                              'F'    [0,0.999982357025]
MuonRelTrkIso                 MuonRelTrkIso                 MuonRelTrkIso                 MuonRelTrkIso                                                   'F'    [0,69.4224243164]
MuonPFChargedHadronIso        MuonPFChargedHadronIso        MuonPFChargedHadronIso        MuonPFChargedHadronIso                                          'F'    [0,147.538024902]
MuonPFNeutralHadronIso        MuonPFNeutralHadronIso        MuonPFNeutralHadronIso        MuonPFNeutralHadronIso                                          'F'    [0,68.6367034912]
MuonPFPhotonIso               MuonPFPhotonIso               MuonPFPhotonIso               MuonPFPhotonIso                                                 'F'    [0,128.854370117]
MuonJetElectronEnergyFraction MuonJetElectronEnergyFraction MuonJetElectronEnergyFraction MuonJetElectronEnergyFraction                                   'F'    [0,0.836917221546]
MuonJetMuonEnergyFraction     MuonJetMuonEnergyFraction     MuonJetMuonEnergyFraction     MuonJetMuonEnergyFraction                                       'F'    [0,1.00000011921]
MuonIsPF                      MuonIsPF                      MuonIsPF                      MuonIsPF                                                        'F'    [1,1]
MuonIsTracker                 MuonIsTracker                 MuonIsTracker                 MuonIsTracker                                                   'F'    [0,1]
MuonTrkValidFractionOfHits    MuonTrkValidFractionOfHits    MuonTrkValidFractionOfHits    MuonTrkValidFractionOfHits                                      'F'    [0,1]
MuonIsGlobal                  MuonIsGlobal                  MuonIsGlobal                  MuonIsGlobal                                                    'F'    [0,1]
MuonGlobalChi2                MuonGlobalChi2                MuonGlobalChi2                MuonGlobalChi2                                                  'F'    [-9999,17700.0703125]
MuonChi2LocalPosition         MuonChi2LocalPosition         MuonChi2LocalPosition         MuonChi2LocalPosition                                           'F'    [0,113890.148438]
MuonTrkKink                   MuonTrkKink                   MuonTrkKink                   MuonTrkKink                                                     'F'    [0,2146.34912109]
MuonSegmentCompatibility      MuonSegmentCompatibility      MuonSegmentCompatibility      MuonSegmentCompatibility                                        'F'    [0,1]
MuonPt                        MuonPt                        MuonPt                        MuonPt                                                          'F'    [10.0003871918,309.485809326]
NSpec 0


============================================================================ */

#include <array>
#include <vector>
#include <cmath>
#include <string>
#include <iostream>

#define NN new 50 TreesNode
   
#ifndef 50 TreesNode__def
#define 50 TreesNode__def
   
class 50 TreesNode {
   
public:
   
   // constructor of an essentially "empty" node floating in space
   50 TreesNode ( 50 TreesNode* left,50 TreesNode* right,
                          int selector, double cutValue, bool cutType, 
                          int nodeType, double purity, double response ) :
   fLeft         ( left         ),
   fRight        ( right        ),
   fSelector     ( selector     ),
   fCutValue     ( cutValue     ),
   fCutType      ( cutType      ),
   fNodeType     ( nodeType     ),
   fPurity       ( purity       ),
   fResponse     ( response     ){
   }

   virtual ~50 TreesNode();

   // test event if it descends the tree at this node to the right
   virtual bool GoesRight( const std::vector<double>& inputValues ) const;
   50 TreesNode* GetRight( void )  {return fRight; };

   // test event if it descends the tree at this node to the left 
   virtual bool GoesLeft ( const std::vector<double>& inputValues ) const;
   50 TreesNode* GetLeft( void ) { return fLeft; };   

   // return  S/(S+B) (purity) at this node (from  training)

   double GetPurity( void ) const { return fPurity; } 
   // return the node type
   int    GetNodeType( void ) const { return fNodeType; }
   double GetResponse(void) const {return fResponse;}

private:

   50 TreesNode*   fLeft;     // pointer to the left daughter node
   50 TreesNode*   fRight;    // pointer to the right daughter node
   int                     fSelector; // index of variable used in node selection (decision tree)   
   double                  fCutValue; // cut value applied on this node to discriminate bkg against sig
   bool                    fCutType;  // true: if event variable > cutValue ==> signal , false otherwise
   int                     fNodeType; // Type of node: -1 == Bkg-leaf, 1 == Signal-leaf, 0 = internal 
   double                  fPurity;   // Purity of node from training
   double                  fResponse; // Regression response value of node
}; 
   
//_______________________________________________________________________
   50 TreesNode::~50 TreesNode()
{
   if (fLeft  != NULL) delete fLeft;
   if (fRight != NULL) delete fRight;
}; 
   
//_______________________________________________________________________
bool 50 TreesNode::GoesRight( const std::vector<double>& inputValues ) const
{
   // test event if it descends the tree at this node to the right
   bool result;
     result = (inputValues[fSelector] > fCutValue );
   if (fCutType == true) return result; //the cuts are selecting Signal ;
   else return !result;
}
   
//_______________________________________________________________________
bool 50 TreesNode::GoesLeft( const std::vector<double>& inputValues ) const
{
   // test event if it descends the tree at this node to the left
   if (!this->GoesRight(inputValues)) return true;
   else return false;
}
   
#endif
   
#ifndef IClassifierReader__def
#define IClassifierReader__def

class IClassifierReader {

 public:

   // constructor
   IClassifierReader() : fStatusIsClean( true ) {}
   virtual ~IClassifierReader() {}

   // return classifier response
   virtual double GetMvaValue( const std::vector<double>& inputValues ) const = 0;

   // returns classifier status
   bool IsStatusClean() const { return fStatusIsClean; }

 protected:

   bool fStatusIsClean;
};

#endif

class Read50 Trees : public IClassifierReader {

 public:

   // constructor
   Read50 Trees( std::vector<std::string>& theInputVars )
      : IClassifierReader(),
        fClassName( "Read50 Trees" ),
        fNvars( 29 ),
        fIsNormalised( false )
   {
      // the training input variables
      const char* inputVars[] = { "MuonPt", "abs(MuonEta)", "MuonDXY", "MuonDZ", "MuonSIP3D", "MuonPtRatio", "MuonPtRel", "MuonJetLRM", "MuonJetFD", "MuonJetInOutRatio", "MuonJetZest", "MuonJetNoOfConst", "MuonJetCSV", "MuonRelPFIsoPUCorr", "MuonRelTrkIso", "MuonPFChargedHadronIso", "MuonPFNeutralHadronIso", "MuonPFPhotonIso", "MuonJetElectronEnergyFraction", "MuonJetMuonEnergyFraction", "MuonIsPF", "MuonIsTracker", "MuonTrkValidFractionOfHits", "MuonIsGlobal", "MuonGlobalChi2", "MuonChi2LocalPosition", "MuonTrkKink", "MuonSegmentCompatibility", "MuonPt" };

      // sanity checks
      if (theInputVars.size() <= 0) {
         std::cout << "Problem in class \"" << fClassName << "\": empty input vector" << std::endl;
         fStatusIsClean = false;
      }

      if (theInputVars.size() != fNvars) {
         std::cout << "Problem in class \"" << fClassName << "\": mismatch in number of input values: "
                   << theInputVars.size() << " != " << fNvars << std::endl;
         fStatusIsClean = false;
      }

      // validate input variables
      for (size_t ivar = 0; ivar < theInputVars.size(); ivar++) {
         if (theInputVars[ivar] != inputVars[ivar]) {
            std::cout << "Problem in class \"" << fClassName << "\": mismatch in input variable names" << std::endl
                      << " for variable [" << ivar << "]: " << theInputVars[ivar].c_str() << " != " << inputVars[ivar] << std::endl;
            fStatusIsClean = false;
         }
      }

      // initialize min and max vectors (for normalisation)
      fVmin[0] = 0;
      fVmax[0] = 0;
      fVmin[1] = 0;
      fVmax[1] = 0;
      fVmin[2] = 0;
      fVmax[2] = 0;
      fVmin[3] = 0;
      fVmax[3] = 0;
      fVmin[4] = 0;
      fVmax[4] = 0;
      fVmin[5] = 0;
      fVmax[5] = 0;
      fVmin[6] = 0;
      fVmax[6] = 0;
      fVmin[7] = 0;
      fVmax[7] = 0;
      fVmin[8] = 0;
      fVmax[8] = 0;
      fVmin[9] = 0;
      fVmax[9] = 0;
      fVmin[10] = 0;
      fVmax[10] = 0;
      fVmin[11] = 0;
      fVmax[11] = 0;
      fVmin[12] = 0;
      fVmax[12] = 0;
      fVmin[13] = 0;
      fVmax[13] = 0;
      fVmin[14] = 0;
      fVmax[14] = 0;
      fVmin[15] = 0;
      fVmax[15] = 0;
      fVmin[16] = 0;
      fVmax[16] = 0;
      fVmin[17] = 0;
      fVmax[17] = 0;
      fVmin[18] = 0;
      fVmax[18] = 0;
      fVmin[19] = 0;
      fVmax[19] = 0;
      fVmin[20] = 0;
      fVmax[20] = 0;
      fVmin[21] = 0;
      fVmax[21] = 0;
      fVmin[22] = 0;
      fVmax[22] = 0;
      fVmin[23] = 0;
      fVmax[23] = 0;
      fVmin[24] = 0;
      fVmax[24] = 0;
      fVmin[25] = 0;
      fVmax[25] = 0;
      fVmin[26] = 0;
      fVmax[26] = 0;
      fVmin[27] = 0;
      fVmax[27] = 0;
      fVmin[28] = 0;
      fVmax[28] = 0;

      // initialize input variable types
      fType[0] = 'F';
      fType[1] = 'F';
      fType[2] = 'F';
      fType[3] = 'F';
      fType[4] = 'F';
      fType[5] = 'F';
      fType[6] = 'F';
      fType[7] = 'F';
      fType[8] = 'F';
      fType[9] = 'F';
      fType[10] = 'F';
      fType[11] = 'F';
      fType[12] = 'F';
      fType[13] = 'F';
      fType[14] = 'F';
      fType[15] = 'F';
      fType[16] = 'F';
      fType[17] = 'F';
      fType[18] = 'F';
      fType[19] = 'F';
      fType[20] = 'F';
      fType[21] = 'F';
      fType[22] = 'F';
      fType[23] = 'F';
      fType[24] = 'F';
      fType[25] = 'F';
      fType[26] = 'F';
      fType[27] = 'F';
      fType[28] = 'F';

      // initialize constants
      Initialize();

   }

   // destructor
   virtual ~Read50 Trees() {
      Clear(); // method-specific
   }

   // the classifier response
   // "inputValues" is a vector of input values in the same order as the
   // variables given to the constructor
   double GetMvaValue( const std::vector<double>& inputValues ) const override;

 private:

   // method-specific destructor
   void Clear();

   // common member variables
   const char* fClassName;

   const size_t fNvars;
   size_t GetNvar()           const { return fNvars; }
   char   GetType( int ivar ) const { return fType[ivar]; }

   // normalisation of input variables
   const bool fIsNormalised;
   bool IsNormalised() const { return fIsNormalised; }
   double fVmin[29];
   double fVmax[29];
   double NormVariable( double x, double xmin, double xmax ) const {
      // normalise to output range: [-1, 1]
      return 2*(x - xmin)/(xmax - xmin) - 1.0;
   }

   // type of input variable: 'F' or 'I'
   char   fType[29];

   // initialize internal variables
   void Initialize();
   double GetMvaValue__( const std::vector<double>& inputValues ) const;

   // private members (method specific)
   std::vector<50 TreesNode*> fForest;       // i.e. root nodes of decision trees
   std::vector<double>                fBoostWeights; // the weights applied in the individual boosts
};

double Read50 Trees::GetMvaValue__( const std::vector<double>& inputValues ) const
{
   double myMVA = 0;
   for (unsigned int itree=0; itree<fForest.size(); itree++){
      50 TreesNode *current = fForest[itree];
      while (current->GetNodeType() == 0) { //intermediate node
         if (current->GoesRight(inputValues)) current=(50 TreesNode*)current->GetRight();
         else current=(50 TreesNode*)current->GetLeft();
      }
      myMVA += current->GetResponse();
   }
   return 2.0/(1.0+exp(-2.0*myMVA))-1.0;
};

void Read50 Trees::Initialize()
{
  // itree = 0
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.974215,0.94843) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.77116,0.54232) , 
13, 0.149641, 1, 0, 0.952336,0.452336) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.19611,-0.60778) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.57502,0.15004) , 
10, 0.428571, 1, 0, 0.327738,-0.172262) , 
13, 0.285681, 1, 0, 0.854618,0.354618) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.151631,-0.696739) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.0115431,-0.976914) , 
13, 0.142855, 1, 0, 0.0254606,-0.474539) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.497541,-0.00491723) , 
5, 0.687248, 1, 0, 0.058959,-0.441041) , 
12, 0.571217, 1, 0, 0.5,-4.7281e-15)    );
  // itree = 1
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.981768,0.507509) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.761683,0.612306) , 
13, 0.237714, 1, 0, 0.967298,0.128859) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.413912,-0.12269) , 
15, 3.99366, 1, 0, 0.917362,0.113028) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.460036,-0.0163799) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.882429,0.568272) , 
10, 0.56189, 1, 0, 0.692139,0.0976127) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.0422235,-0.538303) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.402903,-0.148372) , 
10, 0.559342, 1, 0, 0.070361,-0.124301) , 
13, 0.0476182, 1, 0, 0.143532,-0.0981861) , 
12, 0.238007, 1, 0, 0.5,-0.000889257)    );
  // itree = 2
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.895519,0.386459) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.343009,-0.191406) , 
17, 5.49331, 1, 0, 0.849592,0.0474957) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.0389755,-0.466433) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.112332,-0.0319064) , 
7, 0.108177, 1, 0, 0.061868,-0.051098) , 
15, 7.02562, 1, 0, 0.70176,0.0289926) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.428023,-0.674403) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.160042,0.139606) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.00676301,-0.536038) , 
12, 0.836491, 1, 0, 0.0298946,-0.0481689) , 
12, 0.571186, 1, 0, 0.0743182,-0.0607096) , 
2, 0.00476112, 1, 0, 0.5,0.000148025)    );
  // itree = 3
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.24193,-0.191113) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.0341348,-0.75386) , 
18, 0.0398532, 1, 0, 0.223516,-0.0253218) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.591498,0.383754) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.021091,-0.229864) , 
12, 0.856685, 1, 0, 0.342754,0.0358171) , 
7, 0.150368, 1, 0, 0.240341,-0.0166949) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.993728,0.433251) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.858514,0.243874) , 
12, 0.237955, 1, 0, 0.975875,0.0284097) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.876587,0.062401) , 
17, 2.79509, 1, 0, 0.966603,0.0265521) , 
5, 0.730547, 1, 0, 0.5,-0.00123288)    );
  // itree = 4
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.236489,-0.163009) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.869906,0.229459) , 
8, 0.52381, 1, 0, 0.814487,0.0164501) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.221418,-0.323534) , 
4, 8.01562, 1, 0, 0.774807,0.011528) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.0114077,-0.369463) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.00383817,-0.378124) , 
2, 0.00476115, 1, 0, 0.00603786,-0.0138776) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.102085,-0.325185) , 
5, 0.599658, 1, 0, 0.0188819,-0.0184476) , 
12, 0.809224, 1, 0, 0.5,0.000630771)    );
  // itree = 5
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.964758,0.221163) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.344885,0.649914) , 
12, 0.571186, 1, 0, 0.862325,0.0297034) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.618065,-0.157164) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.0257691,-0.0417633) , 
12, 0.571217, 1, 0, 0.220658,-0.0103034) , 
15, 1.11875, 1, 0, 0.499924,0.00710831) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.174771,-0.431929) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.2706,0.205302) , 
7, 0.103163, 1, 0, 0.192527,-0.0188993) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.950653,-0.0746839) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.992314,0.314586) , 
5, 0.81429, 1, 0, 0.985039,0.00598526) , 
5, 0.780156, 1, 0, 0.50008,-0.00924224) , 
0, 24.2616, 1, 0, 0.5,-0.000881694)    );
  // itree = 6
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.781775,-0.648518) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.0624056,-0.113905) , 
12, 0.571186, 1, 0, 0.330601,-0.0371887) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.292432,0.121647) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.00937955,-0.209017) , 
12, 0.380811, 1, 0, 0.0467567,-0.00121525) , 
13, 0.285709, 1, 0, 0.105178,-0.00861942) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.88757,-0.0192516) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.882252,0.348885) , 
1, 2.05626, 1, 0, 0.887071,0.00204774) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.238675,0.301318) , 
13, 0.285367, 1, 0, 0.815599,0.00602463) , 
8, 0.619048, 1, 0, 0.5,-0.000480873)    );
  // itree = 7
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.0447509,-0.0491633) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.438408,-0.257389) , 
19, 0.571429, 1, 0, 0.258034,-0.0133911) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.9928,0.266951) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.889257,-0.0956431) , 
2, 0.00237287, 1, 0, 0.980496,0.00351654) , 
8, 0.809524, 1, 0, 0.620171,-0.00491608) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.834729,0.307132) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.804004,0.470352) , 
1, 0.798985, 1, 0, 0.819053,0.0417455) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.258051,-0.00438657) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.669545,0.358085) , 
6, 5.1176, 1, 0, 0.289984,0.00267813) , 
9, 0.238095, 1, 0, 0.352105,0.00726527) , 
7, 0.0864584, 1, 0, 0.5,0.000544673)    );
  // itree = 8
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.808648,0.0277048) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.297512,-0.125514) , 
2, 0.00237345, 1, 0, 0.679109,-0.00179818) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.916186,0.0443084) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.348616,0.194637) , 
12, 0.258404, 1, 0, 0.700657,0.010589) , 
1, 1.02853, 1, 0, 0.689248,0.00403018) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.0236716,-0.435205) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.00080183,-0.404168) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.00222955,-0.462946) , 
19, 0.569802, 1, 0, 0.00106647,-0.00418239) , 
13, 0.238091, 1, 0, 0.00499684,-0.00853079) , 
12, 0.904427, 1, 0, 0.5,0.000556112)    );
  // itree = 9
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.642339,-0.000853216) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.378935,0.13574) , 
16, 3.26841, 1, 0, 0.595749,0.00180507) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.0571112,-0.343206) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.000834813,-0.465341) , 
12, 0.952028, 1, 0, 0.0216254,-0.0104718) , 
4, 15.2367, 1, 0, 0.526468,0.000323566) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.0557935,-0.424342) , 
18, 0.0398532, 1, 0, 0.5,-0.000647425)    );
  // itree = 10
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.902177,0.0646614) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.59075,0.327361) , 
13, 0.142682, 1, 0, 0.857064,0.0091465) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.295339,-0.118919) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.0147977,0.0569086) , 
2, 0.00476114, 1, 0, 0.149818,-0.00613054) , 
15, 1.78046, 1, 0, 0.498516,0.0014016) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.937625,-0.0440312) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.990036,0.399262) , 
6, 6.02328, 1, 0, 0.952702,0.00188036) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.54399,-0.393356) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.0309299,-0.267846) , 
12, 0.591491, 1, 0, 0.15966,-0.0121627) , 
12, 0.142773, 1, 0, 0.505116,-0.00604539) , 
0, 38.5228, 1, 0, 0.5,-0.00027256)    );
  // itree = 11
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.755532,-0.0283088) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.609186,-0.310336) , 
12, 0.170002, 1, 0, 0.719547,-0.0148265) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.0373072,-0.112788) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.140879,0.165403) , 
7, 0.131417, 1, 0, 0.0624524,0.000339588) , 
12, 0.238007, 1, 0, 0.194467,-0.00270739) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.956192,0.00437356) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.950453,0.269731) , 
16, 1.77005, 1, 0, 0.955165,0.00225087) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.577718,0.208369) , 
13, 0.189255, 1, 0, 0.932039,0.00412074) , 
8, 0.714286, 1, 0, 0.5,0.000121105)    );
  // itree = 12
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.648272,0.199352) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.0269286,-0.0976961) , 
12, 0.475923, 1, 0, 0.332043,0.0119217) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.490092,-0.119815) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.948525,0.0411252) , 
8, 0.634344, 1, 0, 0.900867,-0.000391039) , 
10, 0.428571, 1, 0, 0.735461,0.00318935) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.821747,-0.450159) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.725264,-0.140017) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.0803827,0.0161671) , 
13, 0.0476182, 1, 0, 0.172903,-0.00145413) , 
12, 0.142804, 1, 0, 0.216646,-0.00374395) , 
3, 0.00476169, 1, 0, 0.5,4.27114e-05)    );
  // itree = 13
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.937644,0.0684799) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.247018,-0.0390851) , 
13, 0.0952269, 1, 0, 0.627144,0.000146107) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.1087,-0.0687304) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.626906,0.134167) , 
5, 0.476324, 1, 0, 0.450072,0.00853144) , 
7, 0.122868, 1, 0, 0.59719,0.00156462) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.444067,-0.00170819) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.0822469,-0.277605) , 
17, 6.13592, 1, 0, 0.253091,-0.0124898) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.00097504,-0.359734) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.00479445,0.0326738) , 
8, 0.500274, 1, 0, 0.00247904,-0.00120246) , 
12, 0.856685, 1, 0, 0.0984133,-0.00552325) , 
11, 21, 1, 0, 0.5,0.000183503)    );
  // itree = 14
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.775038,0.151836) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.0187949,-0.196689) , 
12, 0.61872, 1, 0, 0.450021,0.00551615) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.493472,-0.041775) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.3945,0.171948) , 
7, 0.179665, 1, 0, 0.489476,-0.0011811) , 
6, 0.7481, 1, 0, 0.485662,-0.00053358) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.92821,0.37883) , 
6, 8.17778, 1, 0, 0.5,-7.82667e-05)    );
  // itree = 15
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.816695,0.0185074) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.261063,0.105599) , 
2, 0.00475286, 1, 0, 0.747792,0.00250318) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.0466815,-0.179654) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.00139516,-0.257411) , 
13, 0.190473, 1, 0, 0.00778672,-0.0023661) , 
12, 0.856825, 1, 0, 0.513108,0.000958944) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.607002,-0.172281) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.645641,-0.0643835) , 
16, 1.59698, 1, 0, 0.626048,-0.0195424) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.022694,0.367594) , 
12, 0.856685, 1, 0, 0.377075,-0.00851852) , 
7, 0.150368, 1, 0, 0.5,4.57174e-05)    );
  // itree = 16
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.720651,-0.0146935) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.167505,0.109362) , 
2, 0.00453439, 1, 0, 0.644455,0.000272389) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.183337,0.24242) , 
3, 0.0428551, 1, 0, 0.623981,0.000974362) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.149144,-0.159939) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.00227481,-0.296999) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.00671057,0.182231) , 
1, 1.14251, 1, 0, 0.00382449,-0.000674283) , 
12, 0.856779, 1, 0, 0.0338582,-0.00440247) , 
2, 0.00952224, 1, 0, 0.5,-0.000155273)    );
  // itree = 17
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.926728,-0.0424073) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.43165,0.143626) , 
17, 5.49331, 1, 0, 0.892248,-0.000185485) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.240547,0.218846) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.0105972,0.0601354) , 
12, 0.523615, 1, 0, 0.0886711,0.0132816) , 
15, 6.73355, 1, 0, 0.763158,0.00197793) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.743432,-0.207294) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.0419864,0.034375) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.503554,-0.108092) , 
10, 0.559431, 1, 0, 0.0900937,-0.000490859) , 
12, 0.237994, 1, 0, 0.158334,-0.00276731) , 
2, 0.00238056, 1, 0, 0.5,-8.67152e-05)    );
  // itree = 18
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.826968,-0.0616513) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.891945,0.0857809) , 
0, 20.4936, 1, 0, 0.865403,-3.00719e-05) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.579036,0.204868) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.0529096,0.044129) , 
12, 0.713983, 1, 0, 0.188385,0.0122659) , 
2, 0.00475829, 1, 0, 0.739152,0.0022629) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.927509,-0.0127676) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.42263,0.142463) , 
13, 0.0476084, 1, 0, 0.603694,0.00863503) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.442921,-0.115498) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.0150821,-0.115982) , 
12, 0.571217, 1, 0, 0.109874,-0.00546048) , 
9, 0.428571, 1, 0, 0.201129,-0.00285569) , 
11, 15, 1, 0, 0.5,-1.23194e-05)    );
  // itree = 19
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.78406,0.141281) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.485162,-0.0588336) , 
17, 1.26655, 1, 0, 0.672787,0.00345082) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.175377,-0.183606) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.0615126,0.0131318) , 
17, 7.41877, 1, 0, 0.118241,-0.005393) , 
17, 3.79973, 1, 0, 0.49985,0.000692848) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.175912,-0.298638) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.994789,0.113136) , 
8, 0.877465, 1, 0, 0.501328,-0.00586187) , 
0, 52.784, 1, 0, 0.5,2.64317e-05)    );
  // itree = 20
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.988132,-0.0456655) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.769486,0.0791279) , 
13, 0.190216, 1, 0, 0.966548,0.000746069) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.440792,-0.226624) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.312024,0.00512701) , 
7, 0.0740403, 1, 0, 0.364001,-0.00627626) , 
12, 0.190395, 1, 0, 0.739152,-0.0019041) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.0475933,-0.0468016) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.6742,0.0925206) , 
5, 0.615193, 1, 0, 0.185089,0.000367126) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.333495,0.173181) , 
7, 0.16601, 1, 0, 0.201129,0.00253308) , 
11, 15, 1, 0, 0.5,6.82314e-05)    );
  // itree = 21
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.927301,0.00659901) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.283825,0.122318) , 
12, 0.181315, 1, 0, 0.612224,0.00503877) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.00142216,-0.433048) , 
12, 0.951918, 1, 0, 0.479343,0.00336354) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.385069,-0.0450801) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.749877,0.116272) , 
6, 4.29525, 1, 0, 0.436321,-0.00143683) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.996013,0.374593) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.996989,0.233315) , 
6, 3.01164, 1, 0, 0.996411,0.00364379) , 
8, 0.904762, 1, 0, 0.505399,-0.000810217) , 
22, 0.047619, 1, 0, 0.5,5.46335e-05)    );
  // itree = 22
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.0752264,0.00274148) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.164967,-0.1331) , 
19, 0.571429, 1, 0, 0.0861005,-0.00105562) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.827658,-0.00799765) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.111415,0.220966) , 
12, 0.57117, 1, 0, 0.541097,0.0056505) , 
5, 0.56573, 1, 0, 0.240341,0.0012177) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.991329,-0.0804266) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.960798,0.112583) , 
17, 2.58906, 1, 0, 0.988214,-0.000314143) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.697991,-0.161021) , 
12, 0.47591, 1, 0, 0.966603,-0.00202917) , 
5, 0.730547, 1, 0, 0.5,5.68536e-05)    );
  // itree = 23
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.971281,0.0409694) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.801713,-0.161725) , 
15, 2.4719, 1, 0, 0.960065,-0.00016393) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.364013,0.109584) , 
15, 3.99366, 1, 0, 0.897105,0.00214054) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.0302944,-0.062125) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.270067,0.137977) , 
8, 0.665471, 1, 0, 0.0513371,-0.000309519) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.354356,-0.236901) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.810973,0.00359459) , 
8, 0.776459, 1, 0, 0.56646,-0.0160928) , 
10, 0.559342, 1, 0, 0.110955,-0.00213619) , 
12, 0.33321, 1, 0, 0.5,-1.97459e-05)    );
  // itree = 24
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.420847,0.0714602) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.286955,-0.0945954) , 
0, 20.297, 1, 0, 0.355727,0.00148312) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.845635,0.00361747) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.258145,-0.22925) , 
9, 0.571429, 1, 0, 0.551928,-0.00619227) , 
6, 2.0286, 1, 0, 0.478122,-0.00330499) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.986707,0.0758248) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.918658,-0.250573) , 
11, 7.61905, 1, 0, 0.959412,-0.00448807) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.0318871,-0.147135) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.516382,0.0369013) , 
8, 0.46127, 1, 0, 0.457542,0.00134436) , 
12, 0.0476014, 1, 0, 0.505121,0.000791434) , 
1, 0.342848, 1, 0, 0.5,1.44746e-05)    );
  // itree = 25
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.343407,0.133785) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.0186536,0.0798196) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.0047968,-0.171263) , 
2, 0.00476114, 1, 0, 0.00882828,-0.000621014) , 
12, 0.618818, 1, 0, 0.070828,0.00350245) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.269468,-0.0818623) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.960153,0.03025) , 
8, 0.756624, 1, 0, 0.629795,-0.00206069) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.863342,-0.0533439) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.441291,0.100315) , 
13, 0.0950458, 1, 0, 0.586017,0.00712295) , 
7, 0.128393, 1, 0, 0.624623,-0.000975588) , 
19, 0.476191, 1, 0, 0.5,3.21221e-05)    );
  // itree = 26
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.57289,0.026914) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.636248,-0.0616005) , 
1, 1.48565, 1, 0, 0.590995,-0.000249618) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.0553284,-0.0492845) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.698368,0.0867713) , 
8, 0.583023, 1, 0, 0.340115,0.00260403) , 
7, 0.0955827, 1, 0, 0.513108,0.000636309) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.59678,-0.0883842) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.0780463,0.0310202) , 
2, 0.00475171, 1, 0, 0.377075,-0.00622252) , 
7, 0.150368, 1, 0, 0.5,-2.45923e-05)    );
  // itree = 27
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.239692,-0.0581837) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.45395,0.135997) , 
10, 0.292516, 1, 0, 0.364637,0.00563405) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.961202,0.0231718) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.427524,-0.0938604) , 
13, 0.285439, 1, 0, 0.912296,-0.000727163) , 
10, 0.428571, 1, 0, 0.763158,0.00100512) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.432705,0.0323617) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.51956,-0.100022) , 
1, 1.02822, 1, 0, 0.47857,-0.0050985) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.00380385,-0.147811) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.0762819,0.184915) , 
10, 0.487348, 1, 0, 0.0140451,0.000501719) , 
12, 0.80918, 1, 0, 0.158334,-0.0012378) , 
2, 0.00238056, 1, 0, 0.5,2.92301e-05)    );
  // itree = 28
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.291015,0.143189) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.041363,-0.0679966) , 
13, 0.380946, 1, 0, 0.0978882,0.000959405) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.946867,-0.016729) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.165876,-0.125972) , 
12, 0.42833, 1, 0, 0.761329,-0.0026008) , 
19, 0.571429, 1, 0, 0.478152,-0.0010812) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.763324,-0.0901685) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.979841,0.07615) , 
19, 0.809524, 1, 0, 0.895091,-0.00204544) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.46206,0.12509) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.114058,0.0248982) , 
11, 12, 1, 0, 0.204072,0.00474899) , 
13, 0.0952359, 1, 0, 0.532444,0.00152029) , 
1, 1.14281, 1, 0, 0.5,-3.43218e-05)    );
  // itree = 29
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.962012,-0.0372614) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.359628,0.0397921) , 
13, 0.285681, 1, 0, 0.873926,-0.000185731) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.494263,-0.144715) , 
3, 0.0190417, 1, 0, 0.854618,-0.00110071) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.286193,0.158052) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.0379669,-0.183465) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.0322003,0.0347006) , 
4, 3.82177, 1, 0, 0.0332701,-0.000486731) , 
12, 0.734438, 1, 0, 0.058959,0.00143282) , 
12, 0.571217, 1, 0, 0.5,2.84657e-05)    );
  // itree = 30
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.955526,0.0285052) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.417417,0.118374) , 
2, 0.00474987, 1, 0, 0.900413,0.00274313) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.692365,0.00879374) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.267169,-0.172108) , 
15, 1.22449, 1, 0, 0.508186,-0.00526038) , 
17, 2.68709, 1, 0, 0.830734,0.00132132) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.0293847,-0.0543306) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.108581,0.131238) , 
8, 0.577452, 1, 0, 0.0441889,0.000172415) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.499406,-0.0978414) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.0117892,0.160058) , 
12, 0.80909, 1, 0, 0.229874,-0.00727457) , 
10, 0.428571, 1, 0, 0.090684,-0.00169229) , 
13, 0.238091, 1, 0, 0.5,-2.54858e-05)    );
  // itree = 31
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.901953,0.0791594) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.668425,-0.0294351) , 
17, 0.29214, 1, 0, 0.75321,-5.32285e-06) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.0536108,-0.0046049) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.31975,0.211915) , 
10, 0.404407, 1, 0, 0.124479,0.00620132) , 
17, 6.13592, 1, 0, 0.656356,0.000950786) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.0190161,-0.129882) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.00750477,0.0626172) , 
2, 0.0112229, 1, 0, 0.0104988,-0.000358822) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.181894,-0.123468) , 
8, 0.619048, 1, 0, 0.0453575,-0.00281861) , 
2, 0.00714168, 1, 0, 0.5,-1.38109e-05)    );
  // itree = 32
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.343407,0.0715261) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.0105226,0.0917291) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.00565335,-0.174887) , 
3, 0.0285641, 1, 0, 0.00882828,0.0001577) , 
12, 0.618818, 1, 0, 0.070828,0.00224902) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.323742,0.0229929) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.0155639,-0.307648) , 
14, 0.348855, 1, 0, 0.178879,-0.00272594) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.884861,-0.0814511) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.826596,0.0616641) , 
7, 0.0660925, 1, 0, 0.861167,0.000467441) , 
8, 0.647543, 1, 0, 0.624623,-0.000639682) , 
19, 0.476191, 1, 0, 0.5,1.03729e-05)    );
  // itree = 33
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.876883,0.0716763) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.560755,-0.0387802) , 
4, 0.768173, 1, 0, 0.666098,-0.000499561) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.274247,0.111435) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.00801832,0.0412449) , 
13, 0.142855, 1, 0, 0.0476978,0.0023425) , 
4, 8.01562, 1, 0, 0.513108,0.000203555) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.374479,-0.0742569) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.382007,0.0609753) , 
0, 15.8596, 1, 0, 0.377075,-0.00317741) , 
7, 0.150368, 1, 0, 0.5,-0.000122227)    );
  // itree = 34
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.673036,0.109168) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.183245,-0.0421344) , 
13, 0.476134, 1, 0, 0.445782,0.00759796) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.0225965,0.16297) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.0154078,-0.0727979) , 
3, 0.00476118, 1, 0, 0.0170712,-0.000149156) , 
12, 0.523615, 1, 0, 0.105178,0.001443) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.359133,-0.129117) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.908774,-0.0114678) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.319204,0.0657667) , 
13, 0.28472, 1, 0, 0.870467,5.47968e-05) , 
8, 0.655331, 1, 0, 0.815599,-0.00112126) , 
8, 0.619048, 1, 0, 0.5,1.78926e-05)    );
  // itree = 35
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.485327,-0.0901758) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.57569,-0.0110289) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.4288,0.0503486) , 
16, 1.55638, 1, 0, 0.5288,0.000449435) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.394948,-0.111689) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.00715386,0.139624) , 
12, 0.809224, 1, 0, 0.153943,-0.00326193) , 
16, 6.53683, 1, 0, 0.500463,0.000168881) , 
27, 0.52381, 1, 0, 0.5,-9.90915e-06)    );
  // itree = 36
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.976062,-0.0435167) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.465256,0.0523961) , 
12, 0.237994, 1, 0, 0.838442,0.000757094) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.349681,-0.0993202) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.00365681,-0.0856294) , 
12, 0.856684, 1, 0, 0.160961,-0.00722292) , 
15, 3.55999, 1, 0, 0.717202,-0.000670991) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.367723,0.0647707) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.0351182,0.0632351) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.00511459,-0.085701) , 
4, 3.83354, 1, 0, 0.0127984,9.69028e-05) , 
12, 0.238007, 1, 0, 0.0485243,0.00139321) , 
13, 0.428564, 1, 0, 0.5,-4.89554e-07)    );
  // itree = 37
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.977987,0.0453083) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.721177,-0.0939618) , 
13, 0.237714, 1, 0, 0.960065,6.8297e-05) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.364013,0.0572554) , 
15, 3.99366, 1, 0, 0.897105,0.00123952) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.629312,-0.170998) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.319072,0.0764553) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.0274359,0.00161122) , 
13, 0.138325, 1, 0, 0.0520765,0.000910609) , 
13, 0.0476182, 1, 0, 0.110955,-0.00121979) , 
12, 0.33321, 1, 0, 0.5,-2.74119e-06)    );
  // itree = 38
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.949899,-0.0229276) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.274065,0.044207) , 
13, 0.285681, 1, 0, 0.844217,0.000217427) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.519778,-0.0838543) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.00963389,0.0405322) , 
12, 0.761476, 1, 0, 0.307428,-0.00565722) , 
11, 17.3333, 1, 0, 0.735461,-0.00097281) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.821747,0.119554) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.114683,-0.000687701) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.915307,0.111527) , 
8, 0.81767, 1, 0, 0.172903,0.000631396) , 
12, 0.142804, 1, 0, 0.216646,0.00131808) , 
3, 0.00476169, 1, 0, 0.5,6.68939e-05)    );
  // itree = 39
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.631631,0.149945) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.40561,-0.00476821) , 
7, 0.0864584, 1, 0, 0.515888,0.00435222) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.509585,-0.0744498) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.0187599,0.0436699) , 
12, 0.571217, 1, 0, 0.134651,-0.00204942) , 
9, 0.619048, 1, 0, 0.299658,0.000721342) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.963562,-0.0842027) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.994727,0.0771317) , 
8, 0.780097, 1, 0, 0.99041,0.000121715) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.762223,-0.098083) , 
12, 0.23796, 1, 0, 0.954943,-0.00155468) , 
10, 0.619048, 1, 0, 0.5,2.54895e-05)    );
  // itree = 40
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.225599,0.0553505) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.00679223,-0.137805) , 
15, 7.02562, 1, 0, 0.114246,0.00138064) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.369761,-0.153759) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.900739,-0.0674093) , 
5, 0.640249, 1, 0, 0.801497,-0.00544881) , 
19, 0.619048, 1, 0, 0.42036,-0.00166132) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.971559,0.128134) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.427287,-0.58552) , 
9, 0.52381, 1, 0, 0.856083,-0.00246971) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.610294,0.0690438) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.0121077,-0.244185) , 
14, 0.464914, 1, 0, 0.480387,0.00272457) , 
7, 0.0502267, 1, 0, 0.566377,0.00153569) , 
6, 2.05926, 1, 0, 0.5,8.23848e-05)    );
  // itree = 41
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.985697,0.0859375) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.678785,0.0961588) , 
4, 3.46109, 1, 0, 0.943431,0.00273174) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.447218,-0.155284) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.8912,-0.0903267) , 
19, 0.619048, 1, 0, 0.818507,-0.00638179) , 
13, 0.0272096, 1, 0, 0.888627,-0.00126639) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.402973,0.0117135) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.849554,0.104866) , 
5, 0.641544, 1, 0, 0.554935,0.00638921) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.0125586,0.0301734) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.0913671,-0.103918) , 
5, 0.605074, 1, 0, 0.0211035,-0.000504927) , 
12, 0.428413, 1, 0, 0.14631,0.00111205) , 
13, 0.142855, 1, 0, 0.5,-2.12028e-05)    );
  // itree = 42
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.800286,0.0193817) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.728104,-0.0703276) , 
12, 0.124668, 1, 0, 0.757428,-0.00474696) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.983511,-0.00922743) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.965787,0.123405) , 
7, 0.114128, 1, 0, 0.981661,0.000597168) , 
10, 0.52381, 1, 0, 0.917362,-0.000935266) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.805503,0.0407138) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.617966,-0.116668) , 
7, 0.0640968, 1, 0, 0.692139,-0.00730724) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.328052,0.0976766) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.0292419,0.0131206) , 
13, 0.183675, 1, 0, 0.070361,0.00205039) , 
13, 0.0476182, 1, 0, 0.143532,0.000949181) , 
12, 0.238007, 1, 0, 0.5,8.1103e-05)    );
  // itree = 43
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.242765,0.105097) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.938276,0.00048696) , 
5, 0.64755, 1, 0, 0.66163,0.00347253) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.124028,-0.0410952) , 
3, 0.00952342, 1, 0, 0.491355,0.00181999) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.704503,0.0980251) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.979665,-0.0197767) , 
8, 0.714286, 1, 0, 0.936324,0.00108679) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.907871,-0.123418) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.249993,-0.0139468) , 
12, 0.0475988, 1, 0, 0.283199,-0.00119285) , 
13, 0.0476182, 1, 0, 0.50232,-0.00042804) , 
27, 0.809524, 1, 0, 0.5,4.75833e-05)    );
  // itree = 44
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.19708,0.0774237) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.00229201,0.0159422) , 
12, 0.761622, 1, 0, 0.0464478,0.00177359) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.799145,0.00809086) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.169805,-0.0618311) , 
17, 4.57661, 1, 0, 0.700207,-0.0002076) , 
5, 0.499807, 1, 0, 0.513108,0.000359398) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.805908,0.0262822) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.109343,-0.0950225) , 
12, 0.428343, 1, 0, 0.377075,-0.00316292) , 
7, 0.150368, 1, 0, 0.5,1.9996e-05)    );
  // itree = 45
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.820838,0.00132248) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.436342,0.0505447) , 
3, 0.00476042, 1, 0, 0.728823,0.00122816) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.0108246,-0.224998) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.00319219,-0.00996596) , 
2, 0.00476115, 1, 0, 0.00529439,-0.000983771) , 
12, 0.856825, 1, 0, 0.481,0.000470531) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.761173,-0.0713948) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.0684448,0.029357) , 
13, 0.285681, 1, 0, 0.525681,-0.00271726) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.78066,0.153081) , 
6, 4.00394, 1, 0, 0.554781,-0.00142572) , 
1, 1.48565, 1, 0, 0.5,-1.77951e-05)    );
  // itree = 46
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.57566,0.0030624) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.0546761,-0.120016) , 
3, 0.0428482, 1, 0, 0.542374,-8.80323e-05) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.388864,0.083336) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.965242,-0.0685914) , 
5, 0.696038, 1, 0, 0.622453,0.00340274) , 
1, 1.8285, 1, 0, 0.554633,0.000446345) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.352596,-0.109295) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.845287,-0.0196465) , 
19, 0.571429, 1, 0, 0.645917,-0.00649354) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.062691,0.127763) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.00264958,-0.121229) , 
12, 0.918041, 1, 0, 0.0235288,0.00152741) , 
12, 0.714021, 1, 0, 0.281905,-0.00180237) , 
16, 3.26841, 1, 0, 0.5,-4.11628e-06)    );
  // itree = 47
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.875046,-0.00477773) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.39943,0.117764) , 
2, 0.00475286, 1, 0, 0.842035,0.000923652) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.0165308,0.00472551) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.371317,-0.0716074) , 
5, 0.667124, 1, 0, 0.0447332,-0.000760148) , 
12, 0.618818, 1, 0, 0.491012,0.000182337) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.88459,-0.164003) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.454189,0.010556) , 
11, 8.38095, 1, 0, 0.61462,-0.00246524) , 
1, 2.05706, 1, 0, 0.5,-1.0174e-05)    );
  // itree = 48
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.882887,-0.0149839) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.274172,0.126718) , 
12, 0.578017, 1, 0, 0.830883,0.000339552) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.436566,0.0105537) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.190111,-0.159769) , 
12, 0.53945, 1, 0, 0.309677,-0.00927641) , 
2, 0.00475286, 1, 0, 0.774807,-0.000695025) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.160364,0.163389) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.0076824,0.0512864) , 
13, 0.285708, 1, 0, 0.0476022,0.00477842) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.0127015,-0.163329) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.000749668,-0.0707776) , 
13, 0.238091, 1, 0, 0.00282091,-0.000694242) , 
12, 0.936163, 1, 0, 0.0188819,0.00126855) , 
12, 0.809224, 1, 0, 0.5,1.88097e-05)    );
  // itree = 49
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.979723,0.0273197) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.902727,-0.107738) , 
3, 0.00474873, 1, 0, 0.971389,-0.000149097) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.457245,0.0587506) , 
15, 3.99366, 1, 0, 0.930866,0.000787322) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.0914667,-0.00779829) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.683013,-0.073786) , 
10, 0.596761, 1, 0, 0.1426,-0.00105703) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.943933,0.110533) , 
8, 0.854136, 1, 0, 0.177668,-0.000683842) , 
12, 0.190406, 1, 0, 0.5,-5.42559e-05)    );
   return;
};
 
// Clean up
inline void Read50 Trees::Clear() 
{
   for (unsigned int itree=0; itree<fForest.size(); itree++) { 
      delete fForest[itree]; 
   }
}
   inline double Read50 Trees::GetMvaValue( const std::vector<double>& inputValues ) const
   {
      // classifier response value
      double retval = 0;

      // classifier response, sanity check first
      if (!IsStatusClean()) {
         std::cout << "Problem in class \"" << fClassName << "\": cannot return classifier response"
                   << " because status is dirty" << std::endl;
         retval = 0;
      }
      else {
         if (IsNormalised()) {
            // normalise variables
            std::vector<double> iV;
            iV.reserve(inputValues.size());
            int ivar = 0;
            for (std::vector<double>::const_iterator varIt = inputValues.begin();
                 varIt != inputValues.end(); varIt++, ivar++) {
               iV.push_back(NormVariable( *varIt, fVmin[ivar], fVmax[ivar] ));
            }
            retval = GetMvaValue__( iV );
         }
         else {
            retval = GetMvaValue__( inputValues );
         }
      }

      return retval;
   }
