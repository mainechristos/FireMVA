// Class: Read50 Trees
// Automatically generated by MethodBase::MakeClass
//

/* configuration options =====================================================

#GEN -*-*-*-*-*-*-*-*-*-*-*- general info -*-*-*-*-*-*-*-*-*-*-*-

Method         : BDT::50 Trees
TMVA Release   : 4.2.1         [262657]
ROOT Release   : 6.14/07       [396807]
Creator        : mchristos
Date           : Tue Nov 20 22:04:52 2018
Host           : Linux cmsbuild02.cern.ch 2.6.32-754.3.5.el6.x86_64 #1 SMP Wed Aug 15 08:57:36 CEST 2018 x86_64 x86_64 x86_64 GNU/Linux
Dir            : /cms/mchristos/ANN/FireMVA/2016
Training events: 31877
Analysis type  : [Classification]


#OPT -*-*-*-*-*-*-*-*-*-*-*-*- options -*-*-*-*-*-*-*-*-*-*-*-*-

# Set by User:
V: "False" [Verbose output (short form of "VerbosityLevel" below - overrides the latter one)]
H: "False" [Print method-specific help message]
NTrees: "50" [Number of trees in the forest]
MaxDepth: "3" [Max depth of the decision tree allowed]
MinNodeSize: "2.5%" [Minimum percentage of training events required in a leaf node (default: Classification: 5%, Regression: 0.2%)]
nCuts: "20" [Number of grid points in variable range used in finding optimal cut in node splitting]
BoostType: "Grad" [Boosting type for the trees in the forest (note: AdaCost is still experimental)]
Shrinkage: "1.000000e+00" [Learning rate for GradBoost algorithm]
# Default:
VerbosityLevel: "Default" [Verbosity level]
VarTransform: "None" [List of variable transformations performed before training, e.g., "D_Background,P_Signal,G,N_AllClasses" for: "Decorrelation, PCA-transformation, Gaussianisation, Normalisation, each for the given class of events ('AllClasses' denotes all events of all classes, if no class indication is given, 'All' is assumed)"]
CreateMVAPdfs: "False" [Create PDFs for classifier outputs (signal and background)]
IgnoreNegWeightsInTraining: "False" [Events with negative weights are ignored in the training (but are included for testing and performance evaluation)]
AdaBoostR2Loss: "quadratic" [Type of Loss function in AdaBoostR2]
UseBaggedBoost: "False" [Use only a random subsample of all events for growing the trees in each boost iteration.]
AdaBoostBeta: "5.000000e-01" [Learning rate  for AdaBoost algorithm]
UseRandomisedTrees: "False" [Determine at each node splitting the cut variable only as the best out of a random subset of variables (like in RandomForests)]
UseNvars: "5" [Size of the subset of variables used with RandomisedTree option]
UsePoissonNvars: "True" [Interpret "UseNvars" not as fixed number but as mean of a Poisson distribution in each split with RandomisedTree option]
BaggedSampleFraction: "6.000000e-01" [Relative size of bagged event sample to original size of the data sample (used whenever bagging is used (i.e. UseBaggedBoost, Bagging,)]
UseYesNoLeaf: "True" [Use Sig or Bkg categories, or the purity=S/(S+B) as classification of the leaf node -> Real-AdaBoost]
NegWeightTreatment: "pray" [How to treat events with negative weights in the BDT training (particular the boosting) : IgnoreInTraining;  Boost With inverse boostweight; Pair events with negative and positive weights in training sample and *annihilate* them (experimental!)]
Css: "1.000000e+00" [AdaCost: cost of true signal selected signal]
Cts_sb: "1.000000e+00" [AdaCost: cost of true signal selected bkg]
Ctb_ss: "1.000000e+00" [AdaCost: cost of true bkg    selected signal]
Cbb: "1.000000e+00" [AdaCost: cost of true bkg    selected bkg ]
NodePurityLimit: "5.000000e-01" [In boosting/pruning, nodes with purity > NodePurityLimit are signal; background otherwise.]
SeparationType: "giniindex" [Separation criterion for node splitting]
RegressionLossFunctionBDTG: "huber" [Loss function for BDTG regression.]
HuberQuantile: "7.000000e-01" [In the Huber loss function this is the quantile that separates the core from the tails in the residuals distribution.]
DoBoostMonitor: "False" [Create control plot with ROC integral vs tree number]
UseFisherCuts: "False" [Use multivariate splits using the Fisher criterion]
MinLinCorrForFisher: "8.000000e-01" [The minimum linear correlation between two variables demanded for use in Fisher criterion in node splitting]
UseExclusiveVars: "False" [Variables already used in fisher criterion are not anymore analysed individually for node splitting]
DoPreselection: "False" [and and apply automatic pre-selection for 100% efficient signal (bkg) cuts prior to training]
SigToBkgFraction: "1.000000e+00" [Sig to Bkg ratio used in Training (similar to NodePurityLimit, which cannot be used in real adaboost]
PruneMethod: "nopruning" [Note: for BDTs use small trees (e.g.MaxDepth=3) and NoPruning:  Pruning: Method used for pruning (removal) of statistically insignificant branches ]
PruneStrength: "0.000000e+00" [Pruning strength]
PruningValFraction: "5.000000e-01" [Fraction of events to use for optimizing automatic pruning.]
SkipNormalization: "False" [Skip normalization at initialization, to keep expectation value of BDT output according to the fraction of events]
nEventsMin: "0" [deprecated: Use MinNodeSize (in % of training events) instead]
UseBaggedGrad: "False" [deprecated: Use *UseBaggedBoost* instead:  Use only a random subsample of all events for growing the trees in each iteration.]
GradBaggingFraction: "6.000000e-01" [deprecated: Use *BaggedSampleFraction* instead: Defines the fraction of events to be used in each iteration, e.g. when UseBaggedGrad=kTRUE. ]
UseNTrainEvents: "0" [deprecated: Use *BaggedSampleFraction* instead: Number of randomly picked training events used in randomised (and bagged) trees]
NNodesMax: "0" [deprecated: Use MaxDepth instead to limit the tree size]
##


#VAR -*-*-*-*-*-*-*-*-*-*-*-* variables *-*-*-*-*-*-*-*-*-*-*-*-

NVar 29
MuonPt                        MuonPt                        MuonPt                        MuonPt                                                          'F'    [10.0002336502,469.914337158]
abs(MuonEta)                  abs_MuonEta_                  abs(MuonEta)                  abs(MuonEta)                                                    'F'    [3.24385000567e-05,2.4979095459]
MuonDXY                       MuonDXY                       MuonDXY                       MuonDXY                                                         'F'    [2.88513817281e-08,0.0499866940081]
MuonDZ                        MuonDZ                        MuonDZ                        MuonDZ                                                          'F'    [3.09970982215e-09,0.099770411849]
MuonSIP3D                     MuonSIP3D                     MuonSIP3D                     MuonSIP3D                                                       'F'    [0.0030607059598,39.5443954468]
MuonPtRatio                   MuonPtRatio                   MuonPtRatio                   MuonPtRatio                                                     'F'    [-1,1.29660236835]
MuonPtRel                     MuonPtRel                     MuonPtRel                     MuonPtRel                                                       'F'    [-1,50.4258537292]
MuonJetLRM                    MuonJetLRM                    MuonJetLRM                    MuonJetLRM                                                      'F'    [-1,0.334201931953]
MuonJetFD                     MuonJetFD                     MuonJetFD                     MuonJetFD                                                       'F'    [-1,1]
MuonJetInOutRatio             MuonJetInOutRatio             MuonJetInOutRatio             MuonJetInOutRatio                                               'F'    [-9999,1]
MuonJetZest                   MuonJetZest                   MuonJetZest                   MuonJetZest                                                     'F'    [-1,1]
MuonJetNoOfConst              MuonJetNoOfConst              MuonJetNoOfConst              MuonJetNoOfConst                                                'F'    [0,47]
MuonJetCSV                    MuonJetCSV                    MuonJetCSV                    MuonJetCSV                                                      'F'    [0,0.999542355537]
MuonRelPFIsoPUCorr            MuonRelPFIsoPUCorr            MuonRelPFIsoPUCorr            MuonRelPFIsoPUCorr                                              'F'    [0,0.999940693378]
MuonRelTrkIso                 MuonRelTrkIso                 MuonRelTrkIso                 MuonRelTrkIso                                                   'F'    [0,35.437297821]
MuonPFChargedHadronIso        MuonPFChargedHadronIso        MuonPFChargedHadronIso        MuonPFChargedHadronIso                                          'F'    [0,135.236557007]
MuonPFNeutralHadronIso        MuonPFNeutralHadronIso        MuonPFNeutralHadronIso        MuonPFNeutralHadronIso                                          'F'    [0,120.738746643]
MuonPFPhotonIso               MuonPFPhotonIso               MuonPFPhotonIso               MuonPFPhotonIso                                                 'F'    [0,275.301422119]
MuonJetElectronEnergyFraction MuonJetElectronEnergyFraction MuonJetElectronEnergyFraction MuonJetElectronEnergyFraction                                   'F'    [0,0.88647300005]
MuonJetMuonEnergyFraction     MuonJetMuonEnergyFraction     MuonJetMuonEnergyFraction     MuonJetMuonEnergyFraction                                       'F'    [0,1.00000023842]
MuonIsPF                      MuonIsPF                      MuonIsPF                      MuonIsPF                                                        'F'    [1,1]
MuonIsTracker                 MuonIsTracker                 MuonIsTracker                 MuonIsTracker                                                   'F'    [0,1]
MuonTrkValidFractionOfHits    MuonTrkValidFractionOfHits    MuonTrkValidFractionOfHits    MuonTrkValidFractionOfHits                                      'F'    [0,1]
MuonIsGlobal                  MuonIsGlobal                  MuonIsGlobal                  MuonIsGlobal                                                    'F'    [0,1]
MuonGlobalChi2                MuonGlobalChi2                MuonGlobalChi2                MuonGlobalChi2                                                  'F'    [-9999,8375.21386719]
MuonChi2LocalPosition         MuonChi2LocalPosition         MuonChi2LocalPosition         MuonChi2LocalPosition                                           'F'    [-1,91013.5703125]
MuonTrkKink                   MuonTrkKink                   MuonTrkKink                   MuonTrkKink                                                     'F'    [0,3592.9362793]
MuonSegmentCompatibility      MuonSegmentCompatibility      MuonSegmentCompatibility      MuonSegmentCompatibility                                        'F'    [0,1]
MuonPt                        MuonPt                        MuonPt                        MuonPt                                                          'F'    [10.0002336502,469.914337158]
NSpec 0


============================================================================ */

#include <array>
#include <vector>
#include <cmath>
#include <string>
#include <iostream>

#define NN new 50 TreesNode
   
#ifndef 50 TreesNode__def
#define 50 TreesNode__def
   
class 50 TreesNode {
   
public:
   
   // constructor of an essentially "empty" node floating in space
   50 TreesNode ( 50 TreesNode* left,50 TreesNode* right,
                          int selector, double cutValue, bool cutType, 
                          int nodeType, double purity, double response ) :
   fLeft         ( left         ),
   fRight        ( right        ),
   fSelector     ( selector     ),
   fCutValue     ( cutValue     ),
   fCutType      ( cutType      ),
   fNodeType     ( nodeType     ),
   fPurity       ( purity       ),
   fResponse     ( response     ){
   }

   virtual ~50 TreesNode();

   // test event if it descends the tree at this node to the right
   virtual bool GoesRight( const std::vector<double>& inputValues ) const;
   50 TreesNode* GetRight( void )  {return fRight; };

   // test event if it descends the tree at this node to the left 
   virtual bool GoesLeft ( const std::vector<double>& inputValues ) const;
   50 TreesNode* GetLeft( void ) { return fLeft; };   

   // return  S/(S+B) (purity) at this node (from  training)

   double GetPurity( void ) const { return fPurity; } 
   // return the node type
   int    GetNodeType( void ) const { return fNodeType; }
   double GetResponse(void) const {return fResponse;}

private:

   50 TreesNode*   fLeft;     // pointer to the left daughter node
   50 TreesNode*   fRight;    // pointer to the right daughter node
   int                     fSelector; // index of variable used in node selection (decision tree)   
   double                  fCutValue; // cut value applied on this node to discriminate bkg against sig
   bool                    fCutType;  // true: if event variable > cutValue ==> signal , false otherwise
   int                     fNodeType; // Type of node: -1 == Bkg-leaf, 1 == Signal-leaf, 0 = internal 
   double                  fPurity;   // Purity of node from training
   double                  fResponse; // Regression response value of node
}; 
   
//_______________________________________________________________________
   50 TreesNode::~50 TreesNode()
{
   if (fLeft  != NULL) delete fLeft;
   if (fRight != NULL) delete fRight;
}; 
   
//_______________________________________________________________________
bool 50 TreesNode::GoesRight( const std::vector<double>& inputValues ) const
{
   // test event if it descends the tree at this node to the right
   bool result;
     result = (inputValues[fSelector] > fCutValue );
   if (fCutType == true) return result; //the cuts are selecting Signal ;
   else return !result;
}
   
//_______________________________________________________________________
bool 50 TreesNode::GoesLeft( const std::vector<double>& inputValues ) const
{
   // test event if it descends the tree at this node to the left
   if (!this->GoesRight(inputValues)) return true;
   else return false;
}
   
#endif
   
#ifndef IClassifierReader__def
#define IClassifierReader__def

class IClassifierReader {

 public:

   // constructor
   IClassifierReader() : fStatusIsClean( true ) {}
   virtual ~IClassifierReader() {}

   // return classifier response
   virtual double GetMvaValue( const std::vector<double>& inputValues ) const = 0;

   // returns classifier status
   bool IsStatusClean() const { return fStatusIsClean; }

 protected:

   bool fStatusIsClean;
};

#endif

class Read50 Trees : public IClassifierReader {

 public:

   // constructor
   Read50 Trees( std::vector<std::string>& theInputVars )
      : IClassifierReader(),
        fClassName( "Read50 Trees" ),
        fNvars( 29 ),
        fIsNormalised( false )
   {
      // the training input variables
      const char* inputVars[] = { "MuonPt", "abs(MuonEta)", "MuonDXY", "MuonDZ", "MuonSIP3D", "MuonPtRatio", "MuonPtRel", "MuonJetLRM", "MuonJetFD", "MuonJetInOutRatio", "MuonJetZest", "MuonJetNoOfConst", "MuonJetCSV", "MuonRelPFIsoPUCorr", "MuonRelTrkIso", "MuonPFChargedHadronIso", "MuonPFNeutralHadronIso", "MuonPFPhotonIso", "MuonJetElectronEnergyFraction", "MuonJetMuonEnergyFraction", "MuonIsPF", "MuonIsTracker", "MuonTrkValidFractionOfHits", "MuonIsGlobal", "MuonGlobalChi2", "MuonChi2LocalPosition", "MuonTrkKink", "MuonSegmentCompatibility", "MuonPt" };

      // sanity checks
      if (theInputVars.size() <= 0) {
         std::cout << "Problem in class \"" << fClassName << "\": empty input vector" << std::endl;
         fStatusIsClean = false;
      }

      if (theInputVars.size() != fNvars) {
         std::cout << "Problem in class \"" << fClassName << "\": mismatch in number of input values: "
                   << theInputVars.size() << " != " << fNvars << std::endl;
         fStatusIsClean = false;
      }

      // validate input variables
      for (size_t ivar = 0; ivar < theInputVars.size(); ivar++) {
         if (theInputVars[ivar] != inputVars[ivar]) {
            std::cout << "Problem in class \"" << fClassName << "\": mismatch in input variable names" << std::endl
                      << " for variable [" << ivar << "]: " << theInputVars[ivar].c_str() << " != " << inputVars[ivar] << std::endl;
            fStatusIsClean = false;
         }
      }

      // initialize min and max vectors (for normalisation)
      fVmin[0] = 0;
      fVmax[0] = 0;
      fVmin[1] = 0;
      fVmax[1] = 0;
      fVmin[2] = 0;
      fVmax[2] = 0;
      fVmin[3] = 0;
      fVmax[3] = 0;
      fVmin[4] = 0;
      fVmax[4] = 0;
      fVmin[5] = 0;
      fVmax[5] = 0;
      fVmin[6] = 0;
      fVmax[6] = 0;
      fVmin[7] = 0;
      fVmax[7] = 0;
      fVmin[8] = 0;
      fVmax[8] = 0;
      fVmin[9] = 0;
      fVmax[9] = 0;
      fVmin[10] = 0;
      fVmax[10] = 0;
      fVmin[11] = 0;
      fVmax[11] = 0;
      fVmin[12] = 0;
      fVmax[12] = 0;
      fVmin[13] = 0;
      fVmax[13] = 0;
      fVmin[14] = 0;
      fVmax[14] = 0;
      fVmin[15] = 0;
      fVmax[15] = 0;
      fVmin[16] = 0;
      fVmax[16] = 0;
      fVmin[17] = 0;
      fVmax[17] = 0;
      fVmin[18] = 0;
      fVmax[18] = 0;
      fVmin[19] = 0;
      fVmax[19] = 0;
      fVmin[20] = 0;
      fVmax[20] = 0;
      fVmin[21] = 0;
      fVmax[21] = 0;
      fVmin[22] = 0;
      fVmax[22] = 0;
      fVmin[23] = 0;
      fVmax[23] = 0;
      fVmin[24] = 0;
      fVmax[24] = 0;
      fVmin[25] = 0;
      fVmax[25] = 0;
      fVmin[26] = 0;
      fVmax[26] = 0;
      fVmin[27] = 0;
      fVmax[27] = 0;
      fVmin[28] = 0;
      fVmax[28] = 0;

      // initialize input variable types
      fType[0] = 'F';
      fType[1] = 'F';
      fType[2] = 'F';
      fType[3] = 'F';
      fType[4] = 'F';
      fType[5] = 'F';
      fType[6] = 'F';
      fType[7] = 'F';
      fType[8] = 'F';
      fType[9] = 'F';
      fType[10] = 'F';
      fType[11] = 'F';
      fType[12] = 'F';
      fType[13] = 'F';
      fType[14] = 'F';
      fType[15] = 'F';
      fType[16] = 'F';
      fType[17] = 'F';
      fType[18] = 'F';
      fType[19] = 'F';
      fType[20] = 'F';
      fType[21] = 'F';
      fType[22] = 'F';
      fType[23] = 'F';
      fType[24] = 'F';
      fType[25] = 'F';
      fType[26] = 'F';
      fType[27] = 'F';
      fType[28] = 'F';

      // initialize constants
      Initialize();

   }

   // destructor
   virtual ~Read50 Trees() {
      Clear(); // method-specific
   }

   // the classifier response
   // "inputValues" is a vector of input values in the same order as the
   // variables given to the constructor
   double GetMvaValue( const std::vector<double>& inputValues ) const override;

 private:

   // method-specific destructor
   void Clear();

   // common member variables
   const char* fClassName;

   const size_t fNvars;
   size_t GetNvar()           const { return fNvars; }
   char   GetType( int ivar ) const { return fType[ivar]; }

   // normalisation of input variables
   const bool fIsNormalised;
   bool IsNormalised() const { return fIsNormalised; }
   double fVmin[29];
   double fVmax[29];
   double NormVariable( double x, double xmin, double xmax ) const {
      // normalise to output range: [-1, 1]
      return 2*(x - xmin)/(xmax - xmin) - 1.0;
   }

   // type of input variable: 'F' or 'I'
   char   fType[29];

   // initialize internal variables
   void Initialize();
   double GetMvaValue__( const std::vector<double>& inputValues ) const;

   // private members (method specific)
   std::vector<50 TreesNode*> fForest;       // i.e. root nodes of decision trees
   std::vector<double>                fBoostWeights; // the weights applied in the individual boosts
};

double Read50 Trees::GetMvaValue__( const std::vector<double>& inputValues ) const
{
   double myMVA = 0;
   for (unsigned int itree=0; itree<fForest.size(); itree++){
      50 TreesNode *current = fForest[itree];
      while (current->GetNodeType() == 0) { //intermediate node
         if (current->GoesRight(inputValues)) current=(50 TreesNode*)current->GetRight();
         else current=(50 TreesNode*)current->GetLeft();
      }
      myMVA += current->GetResponse();
   }
   return 2.0/(1.0+exp(-2.0*myMVA))-1.0;
};

void Read50 Trees::Initialize()
{
  // itree = 0
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.46953,-0.0609408) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.946475,0.89295) , 
27, 0.571429, 1, 0, 0.916876,0.416876) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.161873,-0.676253) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.612492,0.224984) , 
5, 0.72799, 1, 0, 0.357553,-0.142447) , 
12, 0.475916, 1, 0, 0.853488,0.353488) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.157014,-0.685972) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.560437,0.120874) , 
10, 0.518918, 1, 0, 0.269151,-0.230849) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.0847794,-0.830441) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.00780808,-0.984384) , 
12, 0.600657, 1, 0, 0.0242784,-0.475722) , 
12, 0.237986, 1, 0, 0.0994113,-0.400589) , 
13, 0.190465, 1, 0, 0.5,6.19103e-16)    );
  // itree = 1
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.511828,0.066714) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.100637,-0.500142) , 
2, 0.00475726, 1, 0, 0.372088,-0.0324874) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.0166135,-0.558507) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.119741,-0.175074) , 
7, 0.140343, 1, 0, 0.0253708,-0.132478) , 
15, 6.43984, 1, 0, 0.195038,-0.083547) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.963052,0.513278) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.824586,0.195655) , 
14, 0.0435336, 1, 0, 0.948233,0.128515) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.614201,-0.199736) , 
2, 0.00468453, 1, 0, 0.924208,0.114185) , 
5, 0.749792, 1, 0, 0.5,-0.000849008)    );
  // itree = 2
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.0506814,-0.867814) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.0541388,-0.409674) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.168805,0.0166198) , 
7, 0.108695, 1, 0, 0.0907971,-0.0383883) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.897649,0.320497) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.116612,-0.315699) , 
12, 0.761466, 1, 0, 0.844336,0.0481244) , 
5, 0.64043, 1, 0, 0.519817,0.0108669) , 
27, 0.285714, 1, 0, 0.5,-0.00147726)    );
  // itree = 3
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.962237,0.292767) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.932574,0.0518759) , 
13, 0.0271955, 1, 0, 0.956825,0.022527) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.581758,0.348048) , 
12, 0.475753, 1, 0, 0.928442,0.0283156) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.696206,-0.375331) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.0917933,-0.0945416) , 
13, 0.183669, 1, 0, 0.243432,-0.0236221) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.682268,0.368336) , 
6, 5.54349, 1, 0, 0.270238,-0.0182342) , 
13, 0.0476162, 1, 0, 0.5,-0.00198486)    );
  // itree = 4
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.0916685,-0.396679) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.692459,0.123887) , 
27, 0.380952, 1, 0, 0.659748,0.00933078) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.506202,0.409615) , 
7, 0.143602, 1, 0, 0.65185,0.0141452) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.375289,-0.485126) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.152156,-0.0187589) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.034856,-0.422978) , 
4, 7.1764, 1, 0, 0.0837424,-0.0209237) , 
12, 0.237986, 1, 0, 0.112241,-0.0273517) , 
4, 3.7689, 1, 0, 0.5,0.00246767)    );
  // itree = 5
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.91432,0.139006) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.513467,0.583678) , 
13, 0.190002, 1, 0, 0.887097,0.0219458) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.291798,-0.349604) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.216438,-0.00930976) , 
7, 0.0710745, 1, 0, 0.25258,-0.0238853) , 
15, 2.02554, 1, 0, 0.72365,0.0101401) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.632566,0.288802) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.545833,-0.376986) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.0460632,-0.21078) , 
13, 0.190465, 1, 0, 0.119556,-0.0247456) , 
9, 0.238095, 1, 0, 0.163958,-0.0191194) , 
11, 11.1905, 1, 0, 0.5,-0.00155187)    );
  // itree = 6
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.238467,-0.236077) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.940877,0.0909885) , 
8, 0.809524, 1, 0, 0.706745,-0.00496089) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.0953954,-0.105272) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.602031,0.229119) , 
5, 0.524472, 1, 0, 0.42826,0.0227484) , 
7, 0.0800682, 1, 0, 0.616347,0.00403372) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.00757137,-0.508486) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.0226509,-0.00326824) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.000650627,-0.513829) , 
12, 0.93835, 1, 0, 0.006798,-0.00959074) , 
4, 5.6765, 1, 0, 0.00706468,-0.0182125) , 
12, 0.856751, 1, 0, 0.5,-0.000214361)    );
  // itree = 7
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.0470449,-0.337629) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.786976,0.0118768) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.0687645,-0.328667) , 
12, 0.285555, 1, 0, 0.504596,-0.00785236) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.58839,0.0915571) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.0410302,-0.413422) , 
4, 9.41766, 1, 0, 0.524139,0.00572556) , 
1, 0.713712, 1, 0, 0.516688,0.000548646) , 
27, 0.190476, 1, 0, 0.5,-0.00110422)    );
  // itree = 8
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.173538,0.047896) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.793018,-0.107226) , 
10, 0.52381, 1, 0, 0.455954,-0.00241068) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.780774,0.0828004) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.52055,0.301209) , 
7, 0.12788, 1, 0, 0.747136,0.0112534) , 
6, 3.8977, 1, 0, 0.518977,0.000546743) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.0828926,-0.416887) , 
18, 0.042213, 1, 0, 0.5,-0.000717313)    );
  // itree = 9
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.949565,0.103606) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.826771,-0.324483) , 
17, 2.57057, 1, 0, 0.939689,0.0029369) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.412453,0.295471) , 
12, 0.571077, 1, 0, 0.90876,0.00630922) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.703673,-0.199894) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.107924,0.188802) , 
12, 0.475916, 1, 0, 0.541706,-0.0229761) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.206718,0.0866534) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.0117031,-0.253303) , 
12, 0.428375, 1, 0, 0.0855047,-0.000116049) , 
13, 0.224497, 1, 0, 0.181982,-0.0049505) , 
13, 0.0952324, 1, 0, 0.5,-2.35588e-05)    );
  // itree = 10
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.510638,-0.114242) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.566374,0.00570461) , 
0, 14.1716, 1, 0, 0.559276,-0.00165321) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.0421885,-0.130391) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.539151,0.208544) , 
8, 0.583616, 1, 0, 0.303646,0.0102118) , 
16, 2.01279, 1, 0, 0.500468,0.00107639) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.491099,-0.388473) , 
0, 53.8016, 1, 0, 0.5,1.41139e-05)    );
  // itree = 11
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.975817,0.420471) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.986636,0.225348) , 
10, 0.904762, 1, 0, 0.979718,0.0152271) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.318712,-0.0532798) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.948155,0.094992) , 
5, 0.827315, 1, 0, 0.465142,-0.00261942) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.371958,0.298223) , 
7, 0.167807, 1, 0, 0.462568,-0.00111601) , 
7, 0.0165348, 1, 0, 0.5,6.69199e-05)    );
  // itree = 12
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.973984,0.100176) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.94314,-0.300725) , 
1, 1.41494, 1, 0, 0.965739,-0.000813474) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.736145,-0.26124) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.94984,-0.0548176) , 
8, 0.904762, 1, 0, 0.833086,-0.0194971) , 
3, 0.00473274, 1, 0, 0.928442,-0.0060666) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.797182,0.11633) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.134791,-0.06055) , 
13, 0.138338, 1, 0, 0.270601,-0.00108939) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.0474233,-0.0497155) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.522126,0.307674) , 
8, 0.645013, 1, 0, 0.268655,0.0239892) , 
1, 1.66528, 1, 0, 0.270238,0.00359586) , 
13, 0.0476162, 1, 0, 0.5,0.000222943)    );
  // itree = 13
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.891287,0.126864) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.0618785,-0.223184) , 
14, 0.186236, 1, 0, 0.772431,0.00588033) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.680425,-0.296814) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.267627,-0.0438252) , 
12, 0.0475973, 1, 0, 0.297651,-0.00655514) , 
17, 1.24844, 1, 0, 0.525591,-0.000584922) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.0704198,0.402877) , 
17, 13.1096, 1, 0, 0.5,0.000452679)    );
  // itree = 14
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.723607,0.170761) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.952669,-0.110014) , 
5, 0.749792, 1, 0, 0.910589,0.00118206) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.771102,-0.0780076) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.465424,-0.272637) , 
13, 0.119836, 1, 0, 0.656883,-0.0247423) , 
15, 1.13703, 1, 0, 0.853488,-0.00465264) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.193685,0.519118) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.422853,0.0242147) , 
10, 0.498245, 1, 0, 0.317625,0.0346858) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.042173,-0.0369209) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.211225,0.136335) , 
8, 0.653013, 1, 0, 0.0701663,0.00131747) , 
13, 0.267609, 1, 0, 0.0994113,0.00526098) , 
13, 0.190465, 1, 0, 0.5,-5.44034e-06)    );
  // itree = 15
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.109589,-0.125967) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.599964,0.0401225) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.0719068,-0.108955) , 
11, 17.9048, 1, 0, 0.518501,0.00188619) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.793352,-0.291881) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.331228,0.0241) , 
7, 0.0513787, 1, 0, 0.556771,-0.00872173) , 
1, 2.00449, 1, 0, 0.522427,0.000797832) , 
27, 0.428571, 1, 0, 0.5,4.44026e-05)    );
  // itree = 16
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.228366,0.181408) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.0817725,-0.0114676) , 
12, 0.0951945, 1, 0, 0.0920696,0.000993797) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.567451,-0.247543) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.517862,0.0237347) , 
11, 11, 1, 0, 0.541613,-0.0166278) , 
5, 0.651555, 1, 0, 0.187568,-0.00274963) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.823661,-0.0824811) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.961754,0.0899599) , 
5, 0.801667, 1, 0, 0.926696,0.00045054) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.599125,0.217714) , 
15, 2.4716, 1, 0, 0.900533,0.003754) , 
19, 0.761905, 1, 0, 0.5,0.000100358)    );
  // itree = 17
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.430981,0.0902077) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.925976,-0.0259269) , 
10, 0.52381, 1, 0, 0.798795,0.00220402) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.48593,-0.161419) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.0266816,0.0887604) , 
15, 6.43984, 1, 0, 0.258739,-0.0118227) , 
12, 0.190367, 1, 0, 0.65185,-0.00161254) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.0888509,-0.280316) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.00275642,-0.200913) , 
13, 0.523647, 1, 0, 0.043282,-0.010631) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.175877,0.305705) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.112573,0.0310568) , 
0, 19.9971, 1, 0, 0.131049,0.00920924) , 
1, 0.471524, 1, 0, 0.112241,0.00495753) , 
4, 3.7689, 1, 0, 0.5,0.000236332)    );
  // itree = 18
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.36343,-0.178289) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.056615,0.18236) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.0110367,-0.234735) , 
13, 0.489948, 1, 0, 0.0203648,-0.00379022) , 
13, 0.285697, 1, 0, 0.0730981,-0.00719981) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.10073,-0.109037) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.853935,0.0402528) , 
8, 0.708199, 1, 0, 0.627865,-0.000199194) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.596532,0.193945) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.0912527,-0.048967) , 
14, 0.183241, 1, 0, 0.392515,0.0180644) , 
7, 0.127316, 1, 0, 0.604992,0.0015758) , 
10, 0.333333, 1, 0, 0.5,-0.000156435)    );
  // itree = 19
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.315227,0.347838) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.0171055,-0.0369397) , 
15, 3.32894, 1, 0, 0.085484,0.0130816) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.891539,0.0441055) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.602347,-0.204922) , 
2, 0.00234253, 1, 0, 0.816811,-0.00514421) , 
5, 0.64043, 1, 0, 0.429979,0.00449624) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.718292,0.168179) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.951318,-0.0596646) , 
10, 0.715008, 1, 0, 0.858887,0.00667698) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.60496,-0.135079) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.0543852,0.00908339) , 
12, 0.333181, 1, 0, 0.304171,-0.00783222) , 
9, 0.380952, 1, 0, 0.526907,-0.00200631) , 
6, 1.44885, 1, 0, 0.5,-0.000201204)    );
  // itree = 20
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.0924707,-0.0245219) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.101392,-0.267433) , 
1, 1.39734, 1, 0, 0.0945596,-0.00526257) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.714602,0.0100738) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.450096,0.102372) , 
7, 0.111401, 1, 0, 0.675902,0.00289181) , 
10, 0.333333, 1, 0, 0.574061,0.0014633) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.428874,-0.18717) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.0503573,-0.161706) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.127069,0.200709) , 
1, 1.76796, 1, 0, 0.0700725,-0.00100049) , 
12, 0.475973, 1, 0, 0.150834,-0.0062142) , 
3, 0.0190039, 1, 0, 0.5,0.000119806)    );
  // itree = 21
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.129374,-0.011923) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.793406,-0.208133) , 
19, 0.666667, 1, 0, 0.490482,-0.00893326) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.424778,-0.0856378) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.061044,-0.000193816) , 
13, 0.238081, 1, 0, 0.122281,-0.00228653) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.903144,0.0191166) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.449582,0.0942376) , 
2, 0.00473249, 1, 0, 0.855702,0.00319216) , 
8, 0.714286, 1, 0, 0.500668,0.000540038) , 
1, 0.118979, 1, 0, 0.5,-8.13395e-05)    );
  // itree = 22
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.797564,0.0645481) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.165548,-0.100308) , 
12, 0.28555, 1, 0, 0.695597,0.00321815) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.722999,-0.0970046) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.151444,0.0330507) , 
12, 0.190389, 1, 0, 0.346653,-0.0020977) , 
2, 0.00124651, 1, 0, 0.519863,0.000540993) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.0227533,-0.332743) , 
2, 0.0261835, 1, 0, 0.5,5.35954e-05)    );
  // itree = 23
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.674356,0.0154597) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.467973,-0.101014) , 
3, 0.00678229, 1, 0, 0.645331,-0.000368394) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.0563843,-0.0525229) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.490809,0.111032) , 
10, 0.428571, 1, 0, 0.291351,0.00813601) , 
3, 0.0142529, 1, 0, 0.591215,0.000931729) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.0130002,-0.396525) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.00174488,-0.346814) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.000413259,-0.378103) , 
4, 7.06703, 1, 0, 0.000966392,-0.00205243) , 
13, 0.333169, 1, 0, 0.00358969,-0.00503305) , 
12, 0.904348, 1, 0, 0.5,5.83414e-06)    );
  // itree = 24
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.0787813,-0.106278) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.595084,0.172246) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.504792,-0.00698877) , 
6, 0.399229, 1, 0, 0.507999,-0.000120344) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.964255,0.38679) , 
6, 8.7954, 1, 0, 0.521941,0.000351938) , 
27, 0.380952, 1, 0, 0.5,-0.00015671)    );
  // itree = 25
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.58209,0.112931) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.446528,-0.162339) , 
0, 11.3399, 1, 0, 0.495045,-0.00839023) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.575413,0.0566876) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.0828817,-0.10351) , 
17, 6.33999, 1, 0, 0.501004,0.00315942) , 
0, 13.1275, 1, 0, 0.500277,0.00175161) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.0331392,-0.0236225) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.53573,-0.176448) , 
5, 0.644678, 1, 0, 0.204938,-0.00722213) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.912417,-0.371339) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.977794,0.26531) , 
22, 0.047619, 1, 0, 0.962186,0.00261883) , 
5, 0.817505, 1, 0, 0.499431,-0.00339499) , 
0, 31.9009, 1, 0, 0.5,6.43439e-05)    );
  // itree = 26
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.78062,-0.0107904) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.66505,-0.1315) , 
16, 1.91856, 1, 0, 0.764319,-0.00274693) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.0934652,0.295974) , 
13, 0.618913, 1, 0, 0.72365,-0.00147614) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.590707,-0.149849) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.0578432,0.0466774) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.605171,0.20707) , 
5, 0.680865, 1, 0, 0.110097,0.00523529) , 
9, 0.285714, 1, 0, 0.163958,0.00282817) , 
11, 11.1905, 1, 0, 0.5,0.000243843)    );
  // itree = 27
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.155735,-0.0506153) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.197519,-0.182906) , 
19, 0.508639, 1, 0, 0.175664,-0.0155593) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.0496241,0.187183) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.0154002,-0.174116) , 
9, 0.666667, 1, 0, 0.0279831,0.000120215) , 
12, 0.190389, 1, 0, 0.0595702,-0.00323344) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.252891,0.196003) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.783218,0.0233629) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.227686,-0.140723) , 
17, 5.27813, 1, 0, 0.743653,0.000627659) , 
19, 0.604345, 1, 0, 0.720178,0.00161904) , 
8, 0.619048, 1, 0, 0.5,1.72743e-06)    );
  // itree = 28
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.606952,-0.0165537) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.295646,0.0602217) , 
7, 0.08913, 1, 0, 0.526312,0.00071455) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.165962,0.0253925) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.556447,-0.130399) , 
8, 0.544756, 1, 0, 0.346818,-0.00758694) , 
7, 0.143602, 1, 0, 0.515437,0.000211586) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.113121,-0.145184) , 
3, 0.0570117, 1, 0, 0.5,-0.000188181)    );
  // itree = 29
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.49242,0.156757) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.951079,-0.0541262) , 
27, 0.571429, 1, 0, 0.923757,-0.00139439) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.531093,0.116259) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.200612,0.00365678) , 
11, 8.38095, 1, 0, 0.268195,0.00561177) , 
13, 0.142826, 1, 0, 0.698803,0.00100975) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.32593,-0.155609) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.0127566,-0.13021) , 
13, 0.237978, 1, 0, 0.0697157,-0.00786275) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.184493,0.178573) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.00397114,-0.0957022) , 
13, 0.190465, 1, 0, 0.0313778,0.00241845) , 
4, 5.6577, 1, 0, 0.0489848,-0.00230327) , 
12, 0.571167, 1, 0, 0.5,-3.82146e-06)    );
  // itree = 30
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.0510426,0.282706) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.342876,-0.0726776) , 
27, 0.222214, 1, 0, 0.240866,0.000616675) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.41498,-0.220339) , 
6, 2.93268, 1, 0, 0.303502,-0.00825229) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.519179,0.203223) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.521638,-0.00254319) , 
27, 0.714303, 1, 0, 0.521551,0.000353304) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.236228,-0.0363868) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.934008,0.233399) , 
8, 0.815194, 1, 0, 0.569381,0.00973234) , 
1, 2.10105, 1, 0, 0.525023,0.00103406) , 
27, 0.666667, 1, 0, 0.5,-1.49231e-05)    );
  // itree = 31
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.0839042,-0.126544) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.587935,0.10113) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.689862,-0.0165613) , 
27, 0.587742, 1, 0, 0.685988,-0.000776472) , 
27, 0.333333, 1, 0, 0.660879,-0.00139607) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.197866,0.0859056) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.0235945,-0.0595995) , 
9, 0.465087, 1, 0, 0.0533071,-0.000122282) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.335612,0.101431) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.326608,0.188417) , 
1, 0.797462, 1, 0, 0.331072,0.0150302) , 
10, 0.444375, 1, 0, 0.11732,0.00336968) , 
11, 13.4286, 1, 0, 0.5,1.44617e-05)    );
  // itree = 32
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.422257,-0.0819085) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.558548,0.109861) , 
22, 0.047619, 1, 0, 0.520307,0.00390116) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.399314,-0.199649) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.0505773,0.0981093) , 
12, 0.523503, 1, 0, 0.252614,-0.0145844) , 
7, 0.0800606, 1, 0, 0.415346,-0.00334691) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.519869,0.0219903) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.578144,0.140756) , 
1, 1.86761, 1, 0, 0.529018,0.00344278) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.52652,-0.0019928) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.527932,-0.167139) , 
1, 1.84392, 1, 0, 0.526751,-0.00286593) , 
27, 0.99093, 1, 0, 0.528158,0.00105139) , 
27, 0.809524, 1, 0, 0.5,-4.64455e-05)    );
  // itree = 33
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.652208,-0.104218) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.171039,0.148737) , 
4, 1.55798, 1, 0, 0.480707,-0.00300252) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.476433,0.303238) , 
1, 0.158573, 1, 0, 0.479289,0.00482863) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.919532,0.00661797) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.812839,-0.181724) , 
11, 5.14286, 1, 0, 0.891959,-0.00380522) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.359232,-0.01326) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.317296,0.0906474) , 
7, 0.130365, 1, 0, 0.354143,0.000523898) , 
11, 6.71429, 1, 0, 0.503142,-0.000675461) , 
1, 0.237925, 1, 0, 0.5,4.96481e-05)    );
  // itree = 34
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.655502,0.00366654) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.404773,-0.142699) , 
2, 0.00336725, 1, 0, 0.642449,-0.00052871) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.485043,0.270264) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.0478958,-0.0641337) , 
11, 11.1429, 1, 0, 0.251025,0.0162053) , 
2, 0.00442049, 1, 0, 0.607758,0.000954371) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.0187684,0.113387) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.021412,-0.210931) , 
6, 2.54542, 1, 0, 0.019748,-0.000404161) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.310676,-0.10967) , 
19, 0.714286, 1, 0, 0.0685341,-0.00339332) , 
2, 0.00714098, 1, 0, 0.5,8.55306e-05)    );
  // itree = 35
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.190258,0.0348604) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.00910035,-0.178237) , 
12, 0.571167, 1, 0, 0.0869561,3.43495e-05) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.653527,-0.221) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.132134,0.122903) , 
12, 0.237961, 1, 0, 0.349521,-0.0117069) , 
10, 0.535104, 1, 0, 0.123388,-0.0015948) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.921613,0.00510995) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.67887,-0.295781) , 
11, 9.28571, 1, 0, 0.895969,-0.00261774) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.567423,-0.094888) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.829966,0.122114) , 
8, 0.743728, 1, 0, 0.783093,0.00890555) , 
7, 0.0561955, 1, 0, 0.855505,0.00151311) , 
8, 0.714286, 1, 0, 0.5,3.95148e-06)    );
  // itree = 36
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.0543293,0.0312052) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.0628599,-0.123552) , 
19, 0.514074, 1, 0, 0.0581603,-0.00254616) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.577985,0.00612429) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.542929,0.110704) , 
7, 0.0961404, 1, 0, 0.569272,0.00496893) , 
5, 0.576864, 1, 0, 0.321148,0.00132065) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.850966,-0.248899) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.907803,-0.00525359) , 
16, 0.693584, 1, 0, 0.874216,-0.0133604) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.970447,-0.0493321) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.942191,0.23461) , 
13, 0.0428284, 1, 0, 0.966138,0.00160704) , 
19, 0.870825, 1, 0, 0.938883,-0.00283087) , 
10, 0.714286, 1, 0, 0.5,0.000118663)    );
  // itree = 37
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.881016,-0.00739943) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.460276,0.219385) , 
13, 0.236579, 1, 0, 0.847639,0.00280451) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.173365,-0.0863629) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.171267,0.0773766) , 
1, 1.64995, 1, 0, 0.172964,-0.0050431) , 
15, 1.41025, 1, 0, 0.500277,-0.00123589) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.44552,0.0606114) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.473121,0.316292) , 
1, 0.81229, 1, 0, 0.46004,0.0118561) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.945694,0.136818) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.106961,-0.0953981) , 
13, 0.0951635, 1, 0, 0.512471,0.000145996) , 
22, 0.047619, 1, 0, 0.499431,0.00305834) , 
0, 31.9009, 1, 0, 0.5,0.000171931)    );
  // itree = 38
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.297889,-0.204485) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.485014,0.0242288) , 
27, 0.761905, 1, 0, 0.440386,-0.00263158) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.709931,0.0674373) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.0153206,-0.171322) , 
14, 0.26817, 1, 0, 0.51071,0.00282857) , 
22, 0.047619, 1, 0, 0.492975,0.00145161) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.882432,-0.026432) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.542167,-0.126543) , 
12, 0.142766, 1, 0, 0.709729,-0.00923655) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.101327,-0.0703166) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.163553,0.258523) , 
7, 0.0922981, 1, 0, 0.12402,0.00650993) , 
11, 10.5714, 1, 0, 0.52104,-0.00416374) , 
1, 1.54634, 1, 0, 0.5,4.60644e-05)    );
  // itree = 39
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.614074,0.14808) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.896259,-0.081614) , 
27, 0.714286, 1, 0, 0.857724,-0.00224936) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.596244,-0.195154) , 
16, 2.01279, 1, 0, 0.81979,-0.00464185) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.649734,0.135321) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.964057,-0.181304) , 
10, 0.743051, 1, 0, 0.76898,0.00699997) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.133073,-0.0286964) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.786924,0.0406354) , 
10, 0.603519, 1, 0, 0.313867,-0.000214622) , 
12, 0.138284, 1, 0, 0.406728,0.00125745) , 
12, 0.0951945, 1, 0, 0.5,-7.46498e-05)    );
  // itree = 40
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.773842,-0.00412515) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.159324,-0.156837) , 
13, 0.203977, 1, 0, 0.616443,-0.0047745) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.0831965,0.142598) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.00184041,-0.313117) , 
12, 0.713858, 1, 0, 0.0449685,0.00391659) , 
13, 0.476043, 1, 0, 0.438073,-0.00206183) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.343355,0.0183816) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.970268,-0.0726417) , 
19, 0.857143, 1, 0, 0.525347,0.000350009) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.577966,0.0244324) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.587517,0.175779) , 
27, 0.979604, 1, 0, 0.582653,0.0105417) , 
1, 2.09875, 1, 0, 0.529947,0.00116816) , 
27, 0.857143, 1, 0, 0.5,0.000115312)    );
  // itree = 41
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.84514,0.0681787) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.0849183,-0.216827) , 
14, 0.137556, 1, 0, 0.780337,0.00309473) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.0231627,-0.419639) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.00242751,-0.272503) , 
11, 10.2857, 1, 0, 0.00706653,-0.00606008) , 
14, 0.262695, 1, 0, 0.624751,0.00125273) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.65253,-0.290925) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.675191,-0.035776) , 
16, 0.662742, 1, 0, 0.665212,-0.0186303) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.186689,-0.0346621) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.284755,0.0560729) , 
7, 0.116374, 1, 0, 0.227124,0.00104724) , 
9, 0.285714, 1, 0, 0.297498,-0.00211374) , 
7, 0.0800682, 1, 0, 0.5,-3.05933e-05)    );
  // itree = 42
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.913586,-0.0240055) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.184924,0.0437646) , 
13, 0.0952324, 1, 0, 0.536239,0.00120051) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.0948928,-0.177127) , 
16, 5.74946, 1, 0, 0.510676,0.00070028) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.567072,-0.144078) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.0572267,0.197321) , 
12, 0.618703, 1, 0, 0.335301,-0.0120274) , 
7, 0.143602, 1, 0, 0.5,-7.45289e-05)    );
  // itree = 43
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.672989,0.122969) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.955385,0.0302985) , 
5, 0.749792, 1, 0, 0.89569,0.00507478) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.668978,-0.0234766) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.153724,-0.16674) , 
17, 4.22666, 1, 0, 0.551286,-0.00635185) , 
15, 0.306607, 1, 0, 0.700955,-0.00138615) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.0945889,0.22807) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.00686156,0.0135168) , 
12, 0.666284, 1, 0, 0.0632614,0.0100174) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.0184844,-0.259748) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.00176059,-0.130704) , 
4, 3.79495, 1, 0, 0.00523185,-0.00229446) , 
2, 0.00238124, 1, 0, 0.0307138,0.00311192) , 
15, 6.43984, 1, 0, 0.5,-3.75187e-05)    );
  // itree = 44
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.282322,-0.0214185) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.64052,-0.142293) , 
10, 0.52381, 1, 0, 0.398173,-0.0105532) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.963006,-0.0695303) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.909863,0.112511) , 
17, 1.42731, 1, 0, 0.952828,-0.00015389) , 
5, 0.749792, 1, 0, 0.795882,-0.00309649) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.363846,0.234173) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.696547,0.038341) , 
27, 0.666667, 1, 0, 0.652549,0.00702791) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.0597939,0.0168692) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.712632,-0.145926) , 
19, 0.824153, 1, 0, 0.10694,-0.000896256) , 
12, 0.305987, 1, 0, 0.293746,0.00181683) , 
12, 0.142792, 1, 0, 0.5,-0.000201329)    );
  // itree = 45
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.0742094,0.0150544) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.410153,-0.106272) , 
19, 0.714286, 1, 0, 0.212421,-0.00583204) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.574905,-0.124546) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.0800415,0.00645385) , 
13, 0.142849, 1, 0, 0.128915,-0.00144208) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.939553,0.014218) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.403192,0.106813) , 
12, 0.475748, 1, 0, 0.887815,0.00249653) , 
8, 0.714286, 1, 0, 0.524517,0.000611057) , 
27, 0.571429, 1, 0, 0.5,0.000104905)    );
  // itree = 46
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.0924554,-0.143413) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.00986311,0.0944772) , 
4, 3.45766, 1, 0, 0.0465084,-0.00490073) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.161376,0.0618275) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.729774,-0.013583) , 
10, 0.444647, 1, 0, 0.574785,0.000312208) , 
8, 0.52381, 1, 0, 0.513572,-0.000291838) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.0804843,0.215357) , 
18, 0.084426, 1, 0, 0.5,1.58208e-05)    );
  // itree = 47
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.347803,0.0477752) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.518712,-0.0112845) , 
27, 0.714286, 1, 0, 0.493062,-7.42509e-05) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.169373,-0.0578906) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.902325,0.229729) , 
19, 0.769103, 1, 0, 0.536548,0.00720694) , 
1, 1.82946, 1, 0, 0.49575,0.000375837) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.0882512,-0.153893) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.801264,0.0875317) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.786064,-0.062203) , 
1, 2.18089, 1, 0, 0.792632,0.000573604) , 
8, 0.688349, 1, 0, 0.539874,-0.00412422) , 
1, 2.02212, 1, 0, 0.5,-5.75785e-05)    );
  // itree = 48
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.0866915,-0.132594) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.0451269,0.0249387) , 
11, 11.1905, 1, 0, 0.0520053,-0.000733769) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.217132,0.227481) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.188592,-0.00734548) , 
6, 1.59944, 1, 0, 0.199455,0.00908394) , 
8, 0.618037, 1, 0, 0.0882118,0.00167698) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.363659,-0.109017) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.892004,-0.00820443) , 
5, 0.702932, 1, 0, 0.822703,-0.00265143) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.623367,0.105802) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.887704,0.155985) , 
8, 0.788352, 1, 0, 0.744837,0.0122838) , 
16, 2.48513, 1, 0, 0.815153,-0.00120325) , 
5, 0.64043, 1, 0, 0.5,4.54262e-05)    );
  // itree = 49
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.22653,-0.105455) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.0589457,0.0340129) , 
17, 2.38006, 1, 0, 0.135287,-0.00545467) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.700958,0.107899) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.142191,-0.0721357) , 
17, 3.10118, 1, 0, 0.493795,0.00355621) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.822362,-0.0249773) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.0714063,0.0285102) , 
13, 0.285697, 1, 0, 0.532031,-0.000659439) , 
22, 0.047619, 1, 0, 0.523031,0.000332896) , 
27, 0.47619, 1, 0, 0.5,-1.08696e-05)    );
   return;
};
 
// Clean up
inline void Read50 Trees::Clear() 
{
   for (unsigned int itree=0; itree<fForest.size(); itree++) { 
      delete fForest[itree]; 
   }
}
   inline double Read50 Trees::GetMvaValue( const std::vector<double>& inputValues ) const
   {
      // classifier response value
      double retval = 0;

      // classifier response, sanity check first
      if (!IsStatusClean()) {
         std::cout << "Problem in class \"" << fClassName << "\": cannot return classifier response"
                   << " because status is dirty" << std::endl;
         retval = 0;
      }
      else {
         if (IsNormalised()) {
            // normalise variables
            std::vector<double> iV;
            iV.reserve(inputValues.size());
            int ivar = 0;
            for (std::vector<double>::const_iterator varIt = inputValues.begin();
                 varIt != inputValues.end(); varIt++, ivar++) {
               iV.push_back(NormVariable( *varIt, fVmin[ivar], fVmax[ivar] ));
            }
            retval = GetMvaValue__( iV );
         }
         else {
            retval = GetMvaValue__( inputValues );
         }
      }

      return retval;
   }
