// Class: ReadDepth 3
// Automatically generated by MethodBase::MakeClass
//

/* configuration options =====================================================

#GEN -*-*-*-*-*-*-*-*-*-*-*- general info -*-*-*-*-*-*-*-*-*-*-*-

Method         : BDT::Depth 3
TMVA Release   : 4.2.1         [262657]
ROOT Release   : 6.14/07       [396807]
Creator        : mchristos
Date           : Wed Nov 21 11:11:22 2018
Host           : Linux cmsbuild02.cern.ch 2.6.32-754.3.5.el6.x86_64 #1 SMP Wed Aug 15 08:57:36 CEST 2018 x86_64 x86_64 x86_64 GNU/Linux
Dir            : /cms/mchristos/ANN/FireMVA/2016
Training events: 72046
Analysis type  : [Classification]


#OPT -*-*-*-*-*-*-*-*-*-*-*-*- options -*-*-*-*-*-*-*-*-*-*-*-*-

# Set by User:
V: "False" [Verbose output (short form of "VerbosityLevel" below - overrides the latter one)]
H: "False" [Print method-specific help message]
NTrees: "50" [Number of trees in the forest]
MaxDepth: "3" [Max depth of the decision tree allowed]
MinNodeSize: "2.5%" [Minimum percentage of training events required in a leaf node (default: Classification: 5%, Regression: 0.2%)]
nCuts: "20" [Number of grid points in variable range used in finding optimal cut in node splitting]
BoostType: "Grad" [Boosting type for the trees in the forest (note: AdaCost is still experimental)]
Shrinkage: "1.000000e+00" [Learning rate for GradBoost algorithm]
# Default:
VerbosityLevel: "Default" [Verbosity level]
VarTransform: "None" [List of variable transformations performed before training, e.g., "D_Background,P_Signal,G,N_AllClasses" for: "Decorrelation, PCA-transformation, Gaussianisation, Normalisation, each for the given class of events ('AllClasses' denotes all events of all classes, if no class indication is given, 'All' is assumed)"]
CreateMVAPdfs: "False" [Create PDFs for classifier outputs (signal and background)]
IgnoreNegWeightsInTraining: "False" [Events with negative weights are ignored in the training (but are included for testing and performance evaluation)]
AdaBoostR2Loss: "quadratic" [Type of Loss function in AdaBoostR2]
UseBaggedBoost: "False" [Use only a random subsample of all events for growing the trees in each boost iteration.]
AdaBoostBeta: "5.000000e-01" [Learning rate  for AdaBoost algorithm]
UseRandomisedTrees: "False" [Determine at each node splitting the cut variable only as the best out of a random subset of variables (like in RandomForests)]
UseNvars: "5" [Size of the subset of variables used with RandomisedTree option]
UsePoissonNvars: "True" [Interpret "UseNvars" not as fixed number but as mean of a Poisson distribution in each split with RandomisedTree option]
BaggedSampleFraction: "6.000000e-01" [Relative size of bagged event sample to original size of the data sample (used whenever bagging is used (i.e. UseBaggedBoost, Bagging,)]
UseYesNoLeaf: "True" [Use Sig or Bkg categories, or the purity=S/(S+B) as classification of the leaf node -> Real-AdaBoost]
NegWeightTreatment: "pray" [How to treat events with negative weights in the BDT training (particular the boosting) : IgnoreInTraining;  Boost With inverse boostweight; Pair events with negative and positive weights in training sample and *annihilate* them (experimental!)]
Css: "1.000000e+00" [AdaCost: cost of true signal selected signal]
Cts_sb: "1.000000e+00" [AdaCost: cost of true signal selected bkg]
Ctb_ss: "1.000000e+00" [AdaCost: cost of true bkg    selected signal]
Cbb: "1.000000e+00" [AdaCost: cost of true bkg    selected bkg ]
NodePurityLimit: "5.000000e-01" [In boosting/pruning, nodes with purity > NodePurityLimit are signal; background otherwise.]
SeparationType: "giniindex" [Separation criterion for node splitting]
RegressionLossFunctionBDTG: "huber" [Loss function for BDTG regression.]
HuberQuantile: "7.000000e-01" [In the Huber loss function this is the quantile that separates the core from the tails in the residuals distribution.]
DoBoostMonitor: "False" [Create control plot with ROC integral vs tree number]
UseFisherCuts: "False" [Use multivariate splits using the Fisher criterion]
MinLinCorrForFisher: "8.000000e-01" [The minimum linear correlation between two variables demanded for use in Fisher criterion in node splitting]
UseExclusiveVars: "False" [Variables already used in fisher criterion are not anymore analysed individually for node splitting]
DoPreselection: "False" [and and apply automatic pre-selection for 100% efficient signal (bkg) cuts prior to training]
SigToBkgFraction: "1.000000e+00" [Sig to Bkg ratio used in Training (similar to NodePurityLimit, which cannot be used in real adaboost]
PruneMethod: "nopruning" [Note: for BDTs use small trees (e.g.MaxDepth=3) and NoPruning:  Pruning: Method used for pruning (removal) of statistically insignificant branches ]
PruneStrength: "0.000000e+00" [Pruning strength]
PruningValFraction: "5.000000e-01" [Fraction of events to use for optimizing automatic pruning.]
SkipNormalization: "False" [Skip normalization at initialization, to keep expectation value of BDT output according to the fraction of events]
nEventsMin: "0" [deprecated: Use MinNodeSize (in % of training events) instead]
UseBaggedGrad: "False" [deprecated: Use *UseBaggedBoost* instead:  Use only a random subsample of all events for growing the trees in each iteration.]
GradBaggingFraction: "6.000000e-01" [deprecated: Use *BaggedSampleFraction* instead: Defines the fraction of events to be used in each iteration, e.g. when UseBaggedGrad=kTRUE. ]
UseNTrainEvents: "0" [deprecated: Use *BaggedSampleFraction* instead: Number of randomly picked training events used in randomised (and bagged) trees]
NNodesMax: "0" [deprecated: Use MaxDepth instead to limit the tree size]
##


#VAR -*-*-*-*-*-*-*-*-*-*-*-* variables *-*-*-*-*-*-*-*-*-*-*-*-

NVar 28
MuonPt                        MuonPt                        MuonPt                        MuonPt                                                          'F'    [10.000333786,469.914337158]
abs(MuonEta)                  abs_MuonEta_                  abs(MuonEta)                  abs(MuonEta)                                                    'F'    [8.2571305029e-06,2.4979095459]
MuonDXY                       MuonDXY                       MuonDXY                       MuonDXY                                                         'F'    [6.66114701176e-08,0.0499957837164]
MuonDZ                        MuonDZ                        MuonDZ                        MuonDZ                                                          'F'    [3.09970982215e-09,0.0999844223261]
MuonSIP3D                     MuonSIP3D                     MuonSIP3D                     MuonSIP3D                                                       'F'    [0.00253649544902,54.8985595703]
MuonPtRatio                   MuonPtRatio                   MuonPtRatio                   MuonPtRatio                                                     'F'    [-1,1.54068648815]
MuonPtRel                     MuonPtRel                     MuonPtRel                     MuonPtRel                                                       'F'    [-1,32.2454376221]
MuonJetLRM                    MuonJetLRM                    MuonJetLRM                    MuonJetLRM                                                      'F'    [-1,0.334201931953]
MuonJetFD                     MuonJetFD                     MuonJetFD                     MuonJetFD                                                       'F'    [-1,1]
MuonJetInOutRatio             MuonJetInOutRatio             MuonJetInOutRatio             MuonJetInOutRatio                                               'F'    [-9999,1]
MuonJetZest                   MuonJetZest                   MuonJetZest                   MuonJetZest                                                     'F'    [-1,1]
MuonJetNoOfConst              MuonJetNoOfConst              MuonJetNoOfConst              MuonJetNoOfConst                                                'F'    [0,51]
MuonJetCSV                    MuonJetCSV                    MuonJetCSV                    MuonJetCSV                                                      'F'    [0,0.999599099159]
MuonRelPFIsoPUCorr            MuonRelPFIsoPUCorr            MuonRelPFIsoPUCorr            MuonRelPFIsoPUCorr                                              'F'    [0,0.999972999096]
MuonRelTrkIso                 MuonRelTrkIso                 MuonRelTrkIso                 MuonRelTrkIso                                                   'F'    [0,148.893722534]
MuonPFChargedHadronIso        MuonPFChargedHadronIso        MuonPFChargedHadronIso        MuonPFChargedHadronIso                                          'F'    [0,137.792205811]
MuonPFNeutralHadronIso        MuonPFNeutralHadronIso        MuonPFNeutralHadronIso        MuonPFNeutralHadronIso                                          'F'    [0,120.738746643]
MuonPFPhotonIso               MuonPFPhotonIso               MuonPFPhotonIso               MuonPFPhotonIso                                                 'F'    [0,275.301422119]
MuonJetMuonEnergyFraction     MuonJetMuonEnergyFraction     MuonJetMuonEnergyFraction     MuonJetMuonEnergyFraction                                       'F'    [0,1.00000011921]
MuonJetElectronEnergyFraction MuonJetElectronEnergyFraction MuonJetElectronEnergyFraction MuonJetElectronEnergyFraction                                   'F'    [0,0.813720464706]
MuonIsPF                      MuonIsPF                      MuonIsPF                      MuonIsPF                                                        'F'    [1,1]
MuonIsTracker                 MuonIsTracker                 MuonIsTracker                 MuonIsTracker                                                   'F'    [0,1]
MuonTrkValidFractionOfHits    MuonTrkValidFractionOfHits    MuonTrkValidFractionOfHits    MuonTrkValidFractionOfHits                                      'F'    [0,1]
MuonIsGlobal                  MuonIsGlobal                  MuonIsGlobal                  MuonIsGlobal                                                    'F'    [0,1]
MuonGlobalChi2                MuonGlobalChi2                MuonGlobalChi2                MuonGlobalChi2                                                  'F'    [-9999,8375.21386719]
MuonChi2LocalPosition         MuonChi2LocalPosition         MuonChi2LocalPosition         MuonChi2LocalPosition                                           'F'    [-1,91013.5703125]
MuonTrkKink                   MuonTrkKink                   MuonTrkKink                   MuonTrkKink                                                     'F'    [0,4058.10375977]
MuonSegmentCompatibility      MuonSegmentCompatibility      MuonSegmentCompatibility      MuonSegmentCompatibility                                        'F'    [0,1]
NSpec 0


============================================================================ */

#include <array>
#include <vector>
#include <cmath>
#include <string>
#include <iostream>

#define NN new Depth 3Node
   
#ifndef Depth 3Node__def
#define Depth 3Node__def
   
class Depth 3Node {
   
public:
   
   // constructor of an essentially "empty" node floating in space
   Depth 3Node ( Depth 3Node* left,Depth 3Node* right,
                          int selector, double cutValue, bool cutType, 
                          int nodeType, double purity, double response ) :
   fLeft         ( left         ),
   fRight        ( right        ),
   fSelector     ( selector     ),
   fCutValue     ( cutValue     ),
   fCutType      ( cutType      ),
   fNodeType     ( nodeType     ),
   fPurity       ( purity       ),
   fResponse     ( response     ){
   }

   virtual ~Depth 3Node();

   // test event if it descends the tree at this node to the right
   virtual bool GoesRight( const std::vector<double>& inputValues ) const;
   Depth 3Node* GetRight( void )  {return fRight; };

   // test event if it descends the tree at this node to the left 
   virtual bool GoesLeft ( const std::vector<double>& inputValues ) const;
   Depth 3Node* GetLeft( void ) { return fLeft; };   

   // return  S/(S+B) (purity) at this node (from  training)

   double GetPurity( void ) const { return fPurity; } 
   // return the node type
   int    GetNodeType( void ) const { return fNodeType; }
   double GetResponse(void) const {return fResponse;}

private:

   Depth 3Node*   fLeft;     // pointer to the left daughter node
   Depth 3Node*   fRight;    // pointer to the right daughter node
   int                     fSelector; // index of variable used in node selection (decision tree)   
   double                  fCutValue; // cut value applied on this node to discriminate bkg against sig
   bool                    fCutType;  // true: if event variable > cutValue ==> signal , false otherwise
   int                     fNodeType; // Type of node: -1 == Bkg-leaf, 1 == Signal-leaf, 0 = internal 
   double                  fPurity;   // Purity of node from training
   double                  fResponse; // Regression response value of node
}; 
   
//_______________________________________________________________________
   Depth 3Node::~Depth 3Node()
{
   if (fLeft  != NULL) delete fLeft;
   if (fRight != NULL) delete fRight;
}; 
   
//_______________________________________________________________________
bool Depth 3Node::GoesRight( const std::vector<double>& inputValues ) const
{
   // test event if it descends the tree at this node to the right
   bool result;
     result = (inputValues[fSelector] > fCutValue );
   if (fCutType == true) return result; //the cuts are selecting Signal ;
   else return !result;
}
   
//_______________________________________________________________________
bool Depth 3Node::GoesLeft( const std::vector<double>& inputValues ) const
{
   // test event if it descends the tree at this node to the left
   if (!this->GoesRight(inputValues)) return true;
   else return false;
}
   
#endif
   
#ifndef IClassifierReader__def
#define IClassifierReader__def

class IClassifierReader {

 public:

   // constructor
   IClassifierReader() : fStatusIsClean( true ) {}
   virtual ~IClassifierReader() {}

   // return classifier response
   virtual double GetMvaValue( const std::vector<double>& inputValues ) const = 0;

   // returns classifier status
   bool IsStatusClean() const { return fStatusIsClean; }

 protected:

   bool fStatusIsClean;
};

#endif

class ReadDepth 3 : public IClassifierReader {

 public:

   // constructor
   ReadDepth 3( std::vector<std::string>& theInputVars )
      : IClassifierReader(),
        fClassName( "ReadDepth 3" ),
        fNvars( 28 ),
        fIsNormalised( false )
   {
      // the training input variables
      const char* inputVars[] = { "MuonPt", "abs(MuonEta)", "MuonDXY", "MuonDZ", "MuonSIP3D", "MuonPtRatio", "MuonPtRel", "MuonJetLRM", "MuonJetFD", "MuonJetInOutRatio", "MuonJetZest", "MuonJetNoOfConst", "MuonJetCSV", "MuonRelPFIsoPUCorr", "MuonRelTrkIso", "MuonPFChargedHadronIso", "MuonPFNeutralHadronIso", "MuonPFPhotonIso", "MuonJetMuonEnergyFraction", "MuonJetElectronEnergyFraction", "MuonIsPF", "MuonIsTracker", "MuonTrkValidFractionOfHits", "MuonIsGlobal", "MuonGlobalChi2", "MuonChi2LocalPosition", "MuonTrkKink", "MuonSegmentCompatibility" };

      // sanity checks
      if (theInputVars.size() <= 0) {
         std::cout << "Problem in class \"" << fClassName << "\": empty input vector" << std::endl;
         fStatusIsClean = false;
      }

      if (theInputVars.size() != fNvars) {
         std::cout << "Problem in class \"" << fClassName << "\": mismatch in number of input values: "
                   << theInputVars.size() << " != " << fNvars << std::endl;
         fStatusIsClean = false;
      }

      // validate input variables
      for (size_t ivar = 0; ivar < theInputVars.size(); ivar++) {
         if (theInputVars[ivar] != inputVars[ivar]) {
            std::cout << "Problem in class \"" << fClassName << "\": mismatch in input variable names" << std::endl
                      << " for variable [" << ivar << "]: " << theInputVars[ivar].c_str() << " != " << inputVars[ivar] << std::endl;
            fStatusIsClean = false;
         }
      }

      // initialize min and max vectors (for normalisation)
      fVmin[0] = 0;
      fVmax[0] = 0;
      fVmin[1] = 0;
      fVmax[1] = 0;
      fVmin[2] = 0;
      fVmax[2] = 0;
      fVmin[3] = 0;
      fVmax[3] = 0;
      fVmin[4] = 0;
      fVmax[4] = 0;
      fVmin[5] = 0;
      fVmax[5] = 0;
      fVmin[6] = 0;
      fVmax[6] = 0;
      fVmin[7] = 0;
      fVmax[7] = 0;
      fVmin[8] = 0;
      fVmax[8] = 0;
      fVmin[9] = 0;
      fVmax[9] = 0;
      fVmin[10] = 0;
      fVmax[10] = 0;
      fVmin[11] = 0;
      fVmax[11] = 0;
      fVmin[12] = 0;
      fVmax[12] = 0;
      fVmin[13] = 0;
      fVmax[13] = 0;
      fVmin[14] = 0;
      fVmax[14] = 0;
      fVmin[15] = 0;
      fVmax[15] = 0;
      fVmin[16] = 0;
      fVmax[16] = 0;
      fVmin[17] = 0;
      fVmax[17] = 0;
      fVmin[18] = 0;
      fVmax[18] = 0;
      fVmin[19] = 0;
      fVmax[19] = 0;
      fVmin[20] = 0;
      fVmax[20] = 0;
      fVmin[21] = 0;
      fVmax[21] = 0;
      fVmin[22] = 0;
      fVmax[22] = 0;
      fVmin[23] = 0;
      fVmax[23] = 0;
      fVmin[24] = 0;
      fVmax[24] = 0;
      fVmin[25] = 0;
      fVmax[25] = 0;
      fVmin[26] = 0;
      fVmax[26] = 0;
      fVmin[27] = 0;
      fVmax[27] = 0;

      // initialize input variable types
      fType[0] = 'F';
      fType[1] = 'F';
      fType[2] = 'F';
      fType[3] = 'F';
      fType[4] = 'F';
      fType[5] = 'F';
      fType[6] = 'F';
      fType[7] = 'F';
      fType[8] = 'F';
      fType[9] = 'F';
      fType[10] = 'F';
      fType[11] = 'F';
      fType[12] = 'F';
      fType[13] = 'F';
      fType[14] = 'F';
      fType[15] = 'F';
      fType[16] = 'F';
      fType[17] = 'F';
      fType[18] = 'F';
      fType[19] = 'F';
      fType[20] = 'F';
      fType[21] = 'F';
      fType[22] = 'F';
      fType[23] = 'F';
      fType[24] = 'F';
      fType[25] = 'F';
      fType[26] = 'F';
      fType[27] = 'F';

      // initialize constants
      Initialize();

   }

   // destructor
   virtual ~ReadDepth 3() {
      Clear(); // method-specific
   }

   // the classifier response
   // "inputValues" is a vector of input values in the same order as the
   // variables given to the constructor
   double GetMvaValue( const std::vector<double>& inputValues ) const override;

 private:

   // method-specific destructor
   void Clear();

   // common member variables
   const char* fClassName;

   const size_t fNvars;
   size_t GetNvar()           const { return fNvars; }
   char   GetType( int ivar ) const { return fType[ivar]; }

   // normalisation of input variables
   const bool fIsNormalised;
   bool IsNormalised() const { return fIsNormalised; }
   double fVmin[28];
   double fVmax[28];
   double NormVariable( double x, double xmin, double xmax ) const {
      // normalise to output range: [-1, 1]
      return 2*(x - xmin)/(xmax - xmin) - 1.0;
   }

   // type of input variable: 'F' or 'I'
   char   fType[28];

   // initialize internal variables
   void Initialize();
   double GetMvaValue__( const std::vector<double>& inputValues ) const;

   // private members (method specific)
   std::vector<Depth 3Node*> fForest;       // i.e. root nodes of decision trees
   std::vector<double>                fBoostWeights; // the weights applied in the individual boosts
};

double ReadDepth 3::GetMvaValue__( const std::vector<double>& inputValues ) const
{
   double myMVA = 0;
   for (unsigned int itree=0; itree<fForest.size(); itree++){
      Depth 3Node *current = fForest[itree];
      while (current->GetNodeType() == 0) { //intermediate node
         if (current->GoesRight(inputValues)) current=(Depth 3Node*)current->GetRight();
         else current=(Depth 3Node*)current->GetLeft();
      }
      myMVA += current->GetResponse();
   }
   return 2.0/(1.0+exp(-2.0*myMVA))-1.0;
};

void ReadDepth 3::Initialize()
{
  // itree = 0
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.239596,-0.520809) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.426497,-0.147006) , 
12, 0.809092, 1, 0, 0.314843,-0.185157) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.40186,-0.19628) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.615764,0.231529) , 
12, 0.571199, 1, 0, 0.549063,0.0490632) , 
0, 16.2576, 1, 0, 0.427254,-0.0727463) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.551051,0.102102) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.757158,0.514315) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.839615,0.679229) , 
0, 50.7493, 1, 0, 0.78606,0.28606) , 
12, 0.23799, 1, 0, 0.751448,0.251448) , 
0, 31.901, 1, 0, 0.5,3.14261e-15)    );
  // itree = 1
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.100337,-0.662308) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.372401,-0.129422) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.56859,0.182795) , 
19, 0.0387486, 1, 0, 0.385618,-0.0473917) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.600413,0.306757) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.615798,0.115915) , 
5, 0.338481, 1, 0, 0.614293,0.0587908) , 
11, 12.1429, 1, 0, 0.520107,0.0150565) , 
27, 0.380952, 1, 0, 0.5,0.000683141)    );
  // itree = 2
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.398658,-0.088452) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.266508,-0.217221) , 
10, 0.52381, 1, 0, 0.336423,-0.0578957) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.524239,0.00307194) , 
4, 10.4589, 1, 0, 0.373924,-0.0460774) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.393535,-0.106415) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.519753,0.0124707) , 
4, 0.887276, 1, 0, 0.496127,-0.00380398) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.719049,0.171125) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.530991,0.0270068) , 
7, 0.110573, 1, 0, 0.644098,0.0461792) , 
4, 9.23135, 1, 0, 0.536687,0.00989685) , 
13, 0.285707, 1, 0, 0.5,-0.0027198)    );
  // itree = 3
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.304278,0.00283433) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.499655,-0.0812497) , 
0, 16.3157, 1, 0, 0.381529,-0.013683) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.624302,-0.0279306) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.732634,0.0882862) , 
9, 0.666667, 1, 0, 0.69294,0.0171587) , 
0, 26.5797, 1, 0, 0.458813,-0.00602885) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.548762,0.161663) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.699002,0.0309302) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.799924,0.148501) , 
9, 0.790155, 1, 0, 0.721285,0.0206328) , 
12, 0.285586, 1, 0, 0.695703,0.0282448) , 
11, 19.4286, 1, 0, 0.5,-6.98662e-05)    );
  // itree = 4
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.192956,-0.148518) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.336848,-0.00578215) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.486327,0.181737) , 
6, 2.16623, 1, 0, 0.38521,0.0218748) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.564988,-0.0371026) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.649229,0.04748) , 
13, 0.761884, 1, 0, 0.58811,-0.00582276) , 
12, 0.571199, 1, 0, 0.521835,0.0032244) , 
27, 0.52381, 1, 0, 0.5,0.000323186)    );
  // itree = 5
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.278884,-0.176482) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.175043,-0.155234) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.338016,-0.00445303) , 
27, 0.809524, 1, 0, 0.278388,-0.0170303) , 
18, 0.476191, 1, 0, 0.278499,-0.0288313) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.38459,0.0363853) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.514398,0.127256) , 
17, 3.76301, 1, 0, 0.417393,0.0248909) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.623149,-0.0285187) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.697899,0.124433) , 
19, 0.0773327, 1, 0, 0.629703,-0.00596025) , 
11, 12.9048, 1, 0, 0.547894,0.00592755) , 
12, 0.1904, 1, 0, 0.5,-0.000251988)    );
  // itree = 6
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.363575,-0.0378002) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.519521,0.018752) , 
4, 1.12135, 1, 0, 0.482436,0.00242992) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.492285,-0.0743665) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.768128,0.0750303) , 
17, 10.1194, 1, 0, 0.535809,-0.0225253) , 
2, 0.0166653, 1, 0, 0.492034,-0.00205756) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.746687,0.152429) , 
4, 23.5294, 1, 0, 0.5,-0.000210156)    );
  // itree = 7
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.317134,0.00158299) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.472653,-0.0881284) , 
0, 16.4557, 1, 0, 0.356372,-0.00938526) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.44613,0.165599) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.665182,0.0590687) , 
12, 0.571199, 1, 0, 0.600558,0.0391766) , 
0, 20.4291, 1, 0, 0.427254,0.00471117) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.751532,0.00320383) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.79391,-0.106403) , 
3, 0.0190346, 1, 0, 0.762777,-0.00699631) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.684886,-0.201037) , 
1, 1.63214, 1, 0, 0.751448,-0.015815) , 
0, 31.901, 1, 0, 0.5,0.000105289)    );
  // itree = 8
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.496258,-0.045845) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.543769,0.0261538) , 
22, 0.047619, 1, 0, 0.530893,0.00290976) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.686269,0.197258) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.563472,0.0506611) , 
1, 1.04955, 1, 0, 0.626594,0.0504) , 
18, 0.477584, 1, 0, 0.547771,0.0112855) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.517659,-0.0132588) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.312939,-0.100411) , 
7, 0.144773, 1, 0, 0.498307,-0.00859879) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.272915,-0.0149293) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.532016,0.134377) , 
17, 1.93668, 1, 0, 0.357053,0.0133726) , 
18, 0.714286, 1, 0, 0.476389,-0.00518956) , 
8, 0.52381, 1, 0, 0.5,0.000259824)    );
  // itree = 9
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.328732,-0.0966715) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.469503,0.0193494) , 
6, 0.583116, 1, 0, 0.457514,0.00380156) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.331643,-0.189787) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.530474,-0.0159888) , 
4, 4.36383, 1, 0, 0.504415,-0.0154915) , 
2, 0.00711131, 1, 0, 0.473385,-0.0027271) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.667017,0.0822678) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.604007,-0.0141533) , 
3, 0.0666591, 1, 0, 0.651967,0.0228886) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.593316,-0.0479728) , 
2, 0.0380921, 1, 0, 0.64043,0.0147214) , 
4, 13.073, 1, 0, 0.5,5.29639e-05)    );
  // itree = 10
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.580942,0.0897021) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.564737,0.0363886) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.418212,-0.00981593) , 
10, 0.478207, 1, 0, 0.514992,0.00793538) , 
5, 0.445111, 1, 0, 0.527318,0.013245) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.384787,-0.0344808) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.48217,0.0246689) , 
27, 0.857143, 1, 0, 0.451673,0.00301328) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.306982,-0.0975777) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.594629,-0.0233766) , 
11, 9, 1, 0, 0.556849,-0.0129301) , 
6, 2.16623, 1, 0, 0.493345,-0.00330364) , 
1, 0.356851, 1, 0, 0.5,-6.18774e-05)    );
  // itree = 11
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.329346,0.0198908) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.389098,-0.0201286) , 
3, 0.0285635, 1, 0, 0.343505,0.00356795) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.463086,0.0307431) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.45832,0.093143) , 
1, 0.815924, 1, 0, 0.460502,0.0266749) , 
11, 11.4286, 1, 0, 0.363247,0.00746696) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.444933,-0.0891445) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.564791,-0.00841022) , 
9, 0.714286, 1, 0, 0.504209,-0.0205857) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.544884,-0.0242061) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.712489,0.0214837) , 
12, 0.856759, 1, 0, 0.63046,-0.00056524) , 
11, 14.8095, 1, 0, 0.599501,-0.00547463) , 
11, 12.1429, 1, 0, 0.5,-2.41489e-05)    );
  // itree = 12
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.262912,-0.077352) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.531551,-0.000318309) , 
0, 11.8947, 1, 0, 0.487014,-0.00485688) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.701161,-0.0412358) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.874688,0.118542) , 
12, 0.761347, 1, 0, 0.812638,0.0147201) , 
0, 49.7803, 1, 0, 0.516981,-0.00305522) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.420944,0.0554687) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.490511,-0.00386723) , 
13, 0.761873, 1, 0, 0.435188,0.0167377) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.485522,-0.105495) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.471054,0.0295945) , 
7, 0.0899159, 1, 0, 0.478229,-0.0139687) , 
3, 0.0476151, 1, 0, 0.444832,0.00985761) , 
1, 1.54633, 1, 0, 0.5,-1.60442e-05)    );
  // itree = 13
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.411564,-0.0482511) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.359544,0.0512627) , 
7, 0.0800682, 1, 0, 0.378083,0.00602297) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.568206,0.191188) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.598775,-0.0210788) , 
27, 0.619048, 1, 0, 0.59706,-0.00392992) , 
12, 0.809199, 1, 0, 0.48503,0.00116205) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.79695,-0.0845318) , 
15, 26.2461, 1, 0, 0.5,4.46977e-06)    );
  // itree = 14
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.38005,-0.0285664) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.724534,0.0676858) , 
0, 39.2, 1, 0, 0.407264,-0.00827458) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.771227,0.0932729) , 
0, 53.8017, 1, 0, 0.430393,-0.00584839) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.369921,0.0299207) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.57179,0.0948779) , 
15, 2.03395, 1, 0, 0.463632,0.0244619) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.637468,0.0319762) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.593317,-0.0179079) , 
3, 0.0238074, 1, 0, 0.614523,0.00222513) , 
13, 0.285702, 1, 0, 0.582617,0.00692713) , 
4, 5.23073, 1, 0, 0.5,-6.57814e-06)    );
  // itree = 15
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.233932,-0.0747681) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.519496,-0.0599053) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.496147,0.020966) , 
5, 0.330836, 1, 0, 0.497315,0.00662722) , 
27, 0.619048, 1, 0, 0.468789,0.0038889) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.534301,-0.0208208) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.407656,-0.111705) , 
2, 0.0248587, 1, 0, 0.51518,-0.0138825) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.54217,0.0820682) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.774409,-0.0426637) , 
0, 21.4224, 1, 0, 0.664921,0.0102703) , 
4, 15.6922, 1, 0, 0.557821,-0.00700459) , 
2, 0.00952306, 1, 0, 0.5,7.00657e-05)    );
  // itree = 16
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.449577,-0.00848927) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.599296,0.0187306) , 
4, 7.84483, 1, 0, 0.493817,-9.28961e-05) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.550698,-0.0670036) , 
2, 0.038092, 1, 0, 0.495709,-0.000956652) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.631028,0.0737147) , 
19, 0.193743, 1, 0, 0.5,-2.01298e-05)    );
  // itree = 17
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.208796,-0.00661239) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.387308,-0.0511242) , 
12, 0.809072, 1, 0, 0.274237,-0.00987815) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.384528,0.0709576) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.554454,-0.00486972) , 
0, 16.7045, 1, 0, 0.498354,0.00810663) , 
0, 13.129, 1, 0, 0.427254,0.00240101) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.551051,0.0515151) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.714062,-0.188806) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.79936,-0.0163164) , 
12, 0.600749, 1, 0, 0.78606,-0.0133433) , 
12, 0.23799, 1, 0, 0.751448,-0.00819854) , 
0, 31.901, 1, 0, 0.5,2.25634e-05)    );
  // itree = 18
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.495055,-0.0847979) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.438033,0.0251695) , 
18, 0.52381, 1, 0, 0.452673,-0.00154035) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.7005,0.0918059) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.805848,0.021474) , 
15, 12.3723, 1, 0, 0.757952,0.019794) , 
12, 0.856689, 1, 0, 0.574024,0.00694024) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.474547,0.0151911) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.519888,-0.0268639) , 
16, 1.97282, 1, 0, 0.48962,0.000634795) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.258815,-0.0324099) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.420621,-0.10571) , 
12, 0.809066, 1, 0, 0.319295,-0.0242026) , 
5, 0.60358, 1, 0, 0.461096,-0.00352462) , 
7, 0.0800682, 1, 0, 0.5,8.0545e-05)    );
  // itree = 19
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.263363,-0.0434419) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.320365,0.0143434) , 
4, 1.98794, 1, 0, 0.278528,-0.00933925) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.417431,0.055986) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.558904,-0.00604018) , 
12, 0.591627, 1, 0, 0.536165,0.00150572) , 
12, 0.2856, 1, 0, 0.472671,-0.00116701) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.654491,0.088595) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.76478,-0.0430527) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.840186,0.0538844) , 
12, 0.936006, 1, 0, 0.801068,-3.91932e-05) , 
12, 0.666288, 1, 0, 0.753575,0.0113001) , 
17, 13.1096, 1, 0, 0.5,4.59184e-05)    );
  // itree = 20
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.383904,-0.0299903) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.498644,0.00489808) , 
13, 0.523795, 1, 0, 0.444295,-0.00407861) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.542996,0.0960339) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.536707,0.0111886) , 
3, 0.00763274, 1, 0, 0.537327,0.00757695) , 
3, 0.0063479, 1, 0, 0.491113,0.00178706) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.559748,0.00899581) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.456954,-0.0680276) , 
18, 0.476191, 1, 0, 0.494759,-0.0158959) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.676182,0.052574) , 
4, 18.3061, 1, 0, 0.536972,-0.00747584) , 
3, 0.0333281, 1, 0, 0.5,-7.96727e-06)    );
  // itree = 21
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.456033,0.049164) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.544039,-0.0399724) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.525941,0.000122211) , 
10, 0.294318, 1, 0, 0.533329,-0.00634226) , 
13, 0.285707, 1, 0, 0.527337,-0.00434279) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.499646,-0.0173008) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.423877,0.015745) , 
18, 0.614518, 1, 0, 0.458066,7.21237e-05) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.648306,0.120358) , 
13, 0.714199, 1, 0, 0.47479,0.00401573) , 
18, 0.52381, 1, 0, 0.5,5.61202e-06)    );
  // itree = 22
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.344247,0.00142841) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.568482,-0.0542637) , 
12, 0.76136, 1, 0, 0.387318,-0.00385528) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.606927,0.132453) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.534452,0.0129778) , 
3, 0.00950958, 1, 0, 0.552836,0.0168006) , 
4, 1.85963, 1, 0, 0.449322,0.00388256) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.55757,0.106463) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.597427,-0.00776636) , 
6, 0.855821, 1, 0, 0.590782,0.00457858) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.547468,-0.0245328) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.34497,0.0337042) , 
10, 0.606876, 1, 0, 0.524889,-0.00714255) , 
5, 0.445111, 1, 0, 0.545827,-0.00341814) , 
2, 0.00476156, 1, 0, 0.5,4.87205e-05)    );
  // itree = 23
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.449791,0.00143069) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.427341,-0.0459481) , 
3, 0.018137, 1, 0, 0.446427,-0.00232391) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.625064,0.0441249) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.584572,-0.000837243) , 
2, 0.0142848, 1, 0, 0.599879,0.00644027) , 
4, 6.92025, 1, 0, 0.499256,0.000693357) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.520783,-0.0450006) , 
3, 0.0761786, 1, 0, 0.5,5.05438e-05)    );
  // itree = 24
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.214495,0.0632875) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.462361,-0.0280188) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.567176,-0.000698549) , 
6, 1.28252, 1, 0, 0.539399,-0.0031239) , 
27, 0.52381, 1, 0, 0.516981,-0.00195393) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.522501,0.0557489) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.434518,-0.0116396) , 
1, 1.99706, 1, 0, 0.491181,0.013018) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.317974,-0.055439) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.369708,0.0187564) , 
3, 0.0238002, 1, 0, 0.340093,-0.00855063) , 
10, 0.473573, 1, 0, 0.444832,0.00640142) , 
1, 1.54633, 1, 0, 0.5,1.25965e-05)    );
  // itree = 25
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.243507,-0.0698925) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.402597,0.00631182) , 
15, 0.492425, 1, 0, 0.384426,-0.000296396) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.471633,-0.0242282) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.646428,0.0431434) , 
0, 18.5877, 1, 0, 0.594391,0.00950219) , 
15, 10.3411, 1, 0, 0.427254,0.00170226) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.69951,-0.0626268) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.701401,0.0561433) , 
5, 0.492459, 1, 0, 0.700788,0.00659953) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.772061,-0.10272) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.784426,-0.0112397) , 
3, 0.00952119, 1, 0, 0.779894,-0.0130869) , 
2, 0.00238079, 1, 0, 0.751448,-0.00600772) , 
0, 31.901, 1, 0, 0.5,-2.7788e-05)    );
  // itree = 26
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.300513,0.0321386) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.464656,-0.00769529) , 
13, 0.170061, 1, 0, 0.434487,-0.00055398) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.574242,0.015354) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.709614,0.10584) , 
16, 3.01746, 1, 0, 0.601985,0.012826) , 
4, 10.4589, 1, 0, 0.470574,0.00232871) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.541039,0.00735564) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.587253,-0.0653988) , 
3, 0.0380894, 1, 0, 0.548268,-0.00164449) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.68197,-0.0742039) , 
6, 3.26013, 1, 0, 0.566017,-0.0048791) , 
13, 0.714266, 1, 0, 0.5,0.000106478)    );
  // itree = 27
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.449063,-0.00205404) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.675533,-0.0589383) , 
15, 16.8722, 1, 0, 0.458628,-0.00170805) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.772679,0.0640262) , 
17, 17.9659, 1, 0, 0.46972,-0.000914195) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.755018,0.0247686) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.80609,0.099235) , 
9, 0.809524, 1, 0, 0.775344,0.0176395) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.794095,-0.0238396) , 
11, 21.9048, 1, 0, 0.781768,0.00918242) , 
15, 19.6846, 1, 0, 0.5,6.5532e-05)    );
  // itree = 28
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.52046,0.0336196) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.49633,-0.00546628) , 
1, 0.101962, 1, 0, 0.497789,-0.00119408) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.379396,0.0320404) , 
1, 2.14107, 1, 0, 0.491397,-0.000481412) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.752421,0.0486821) , 
11, 26.7143, 1, 0, 0.5,8.0693e-05)    );
  // itree = 29
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.295717,-0.0751859) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.25443,0.00855577) , 
12, 0.108778, 1, 0, 0.275043,-0.0113402) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.46435,0.03407) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.516822,-0.00658981) , 
9, 0.761905, 1, 0, 0.483404,0.00743519) , 
12, 0.142777, 1, 0, 0.438055,0.00334884) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.305474,0.0589542) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.347321,-0.0557097) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.570888,-0.00120085) , 
12, 0.346825, 1, 0, 0.54439,-0.00290573) , 
12, 0.1428, 1, 0, 0.531249,-0.00167725) , 
3, 0.00476117, 1, 0, 0.5,8.05936e-06)    );
  // itree = 30
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.425814,-0.00674932) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.586775,0.0219953) , 
4, 4.64056, 1, 0, 0.487821,0.00181565) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.502989,-0.0379294) , 
3, 0.0618876, 1, 0, 0.488606,0.000937195) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.550564,-0.0146116) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.614866,-0.0852916) , 
13, 0.80949, 1, 0, 0.565068,-0.0116239) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.584929,0.0478192) , 
3, 0.0571387, 1, 0, 0.568721,-0.00600564) , 
2, 0.0214268, 1, 0, 0.5,-5.0217e-05)    );
  // itree = 31
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.442141,0.0268332) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.464548,-0.00679674) , 
2, 0.000647874, 1, 0, 0.459434,0.000259641) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.527317,0.0903376) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.525365,-0.00628029) , 
27, 0.904762, 1, 0, 0.526132,0.0119039) , 
2, 0.00680216, 1, 0, 0.468789,0.00189274) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.546277,0.0169646) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.45781,-0.0399538) , 
1, 0.351411, 1, 0, 0.477298,-0.010894) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.638564,0.0203402) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.589306,-0.0212095) , 
3, 0.0476161, 1, 0, 0.623295,0.00263271) , 
4, 10.4646, 1, 0, 0.557821,-0.00343349) , 
2, 0.00952306, 1, 0, 0.5,2.55675e-05)    );
  // itree = 32
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.595329,-0.0271908) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.69213,0.0449938) , 
3, 0.0428278, 1, 0, 0.604484,-0.00684651) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.398946,-0.00661624) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.63432,0.028232) , 
15, 9.48793, 1, 0, 0.468912,0.00153514) , 
7, 0.0800682, 1, 0, 0.513195,-0.00120264) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.276609,0.0689259) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.491138,-0.0121991) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.431524,0.0384013) , 
7, 0.105128, 1, 0, 0.472133,0.0018265) , 
12, 0.237978, 1, 0, 0.424702,0.00688458) , 
1, 1.78422, 1, 0, 0.5,3.26067e-06)    );
  // itree = 33
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.263481,-0.0237527) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.587444,0.0919816) , 
12, 0.713844, 1, 0, 0.391006,0.0101635) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.491474,-0.00114107) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.575123,-0.0682394) , 
16, 4.88527, 1, 0, 0.496792,-0.00202971) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.677676,0.0968947) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.706912,0.0153592) , 
27, 0.904762, 1, 0, 0.694136,0.0172331) , 
16, 7.32977, 1, 0, 0.509017,-0.000836363) , 
6, 0.583116, 1, 0, 0.5,4.14168e-06)    );
  // itree = 34
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.374239,-0.00915107) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.538901,0.0287911) , 
4, 2.13707, 1, 0, 0.463913,0.00460232) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.494003,-0.0505304) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.592036,0.0119971) , 
18, 0.452014, 1, 0, 0.548663,-0.00646358) , 
13, 0.761884, 1, 0, 0.485818,0.00174219) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.436762,0.0103806) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.576955,-0.0578276) , 
12, 0.904399, 1, 0, 0.509456,-0.0102347) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.480827,0.0721536) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.726375,0.00293744) , 
0, 16.5783, 1, 0, 0.62424,0.013899) , 
13, 0.761873, 1, 0, 0.537166,-0.00440863) , 
3, 0.0238058, 1, 0, 0.5,4.33659e-05)    );
  // itree = 35
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.412131,0.0153574) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.48732,0.0822691) , 
13, 0.85712, 1, 0, 0.423366,0.00933175) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.310503,-0.0518046) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.391527,0.00931054) , 
4, 0.998639, 1, 0, 0.356084,-0.00596483) , 
1, 1.30844, 1, 0, 0.400953,0.00423618) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.573061,-0.023052) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.608462,0.0365226) , 
2, 0.0357101, 1, 0, 0.575625,-0.00724199) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.539663,0.000476364) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.451924,0.0681252) , 
7, 0.141118, 1, 0, 0.528716,0.00382087) , 
1, 1.06837, 1, 0, 0.554693,-0.00230541) , 
4, 2.61663, 1, 0, 0.5,2.17557e-05)    );
  // itree = 36
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.478203,0.006082) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.727209,-0.0380023) , 
11, 25.6667, 1, 0, 0.487938,0.00174649) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.495608,-0.0687866) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.584911,0.00280094) , 
27, 0.857143, 1, 0, 0.554789,-0.00793842) , 
13, 0.904737, 1, 0, 0.494691,0.00076823) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.55721,-0.0786694) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.589786,0.0242977) , 
3, 0.028572, 1, 0, 0.572813,-0.0107486) , 
2, 0.0309498, 1, 0, 0.5,-1.44903e-05)    );
  // itree = 37
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.531395,-0.0235831) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.575102,0.081803) , 
18, 0.341248, 1, 0, 0.550884,0.00974745) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.601178,-0.00905236) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.620331,0.0906782) , 
1, 0.816174, 1, 0, 0.611725,0.0175458) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.420124,-0.0134285) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.570698,0.00415073) , 
4, 5.23073, 1, 0, 0.487889,-0.00199796) , 
10, 0.210344, 1, 0, 0.496805,-0.000590931) , 
8, 0.428571, 1, 0, 0.5,1.99494e-05)    );
  // itree = 38
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.586845,0.0629148) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.67015,-0.068431) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.51442,-0.0042583) , 
7, 0.0561774, 1, 0, 0.526633,-0.00325163) , 
18, 0.299317, 1, 0, 0.529106,-0.00207596) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.482052,0.0483433) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.619584,-0.0394017) , 
12, 0.951999, 1, 0, 0.515786,0.0100538) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.408569,-0.0576301) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.316622,0.0117236) , 
5, 0.695634, 1, 0, 0.353331,-0.00617854) , 
5, 0.645922, 1, 0, 0.450863,0.00356677) , 
18, 0.571429, 1, 0, 0.5,2.30998e-05)    );
  // itree = 39
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.550666,0.0109763) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.59018,-0.111782) , 
3, 0.0285514, 1, 0, 0.567033,-0.015673) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.445534,-0.0171767) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.363757,0.0397542) , 
7, 0.127316, 1, 0, 0.426823,-0.00140983) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.735033,0.0462101) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.521436,-0.0106863) , 
7, 0.0983529, 1, 0, 0.626682,0.00570219) , 
12, 0.904399, 1, 0, 0.495647,0.00103929) , 
5, 0.330836, 1, 0, 0.5,2.01567e-05)    );
  // itree = 40
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.484956,0.00747487) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.582413,-0.0139685) , 
13, 0.680229, 1, 0, 0.514878,0.000314375) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.596337,0.0446916) , 
13, 0.952355, 1, 0, 0.518766,0.00111467) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.395793,-0.0701483) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.31078,-0.00431387) , 
8, 0.508284, 1, 0, 0.349182,-0.0148164) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.423411,-0.0410165) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.530946,0.076951) , 
13, 0.666638, 1, 0, 0.478264,0.00842817) , 
17, 3.92161, 1, 0, 0.40013,-0.00564191) , 
7, 0.143602, 1, 0, 0.5,4.59056e-05)    );
  // itree = 41
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.406279,-0.00258106) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.472814,-0.0704268) , 
3, 0.0190404, 1, 0, 0.421781,-0.00721849) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.564426,0.0111472) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.621741,0.0758354) , 
18, 0.590561, 1, 0, 0.571656,0.00725127) , 
13, 0.42856, 1, 0, 0.523488,0.00260081) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.308391,-0.00724488) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.555082,0.0382691) , 
12, 0.809199, 1, 0, 0.404375,0.00464995) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.535456,0.00367796) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.501733,-0.0491622) , 
5, 0.483761, 1, 0, 0.523466,-0.00585246) , 
13, 0.380936, 1, 0, 0.481035,-0.00211051) , 
1, 0.832642, 1, 0, 0.5,-5.79849e-06)    );
  // itree = 42
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.113146,-0.0811237) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.390245,0.00527184) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.322031,0.077334) , 
18, 0.666667, 1, 0, 0.374255,0.00783259) , 
27, 0.619048, 1, 0, 0.328424,0.00392591) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.579993,-0.0133972) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.594459,0.0131987) , 
3, 0.00952233, 1, 0, 0.589025,0.00129491) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.582748,-0.033867) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.400211,0.0214407) , 
7, 0.105477, 1, 0, 0.537917,-0.00747937) , 
18, 0.571429, 1, 0, 0.572032,-0.0016224) , 
12, 0.4284, 1, 0, 0.5,1.81682e-05)    );
  // itree = 43
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.192956,0.0426956) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.559702,0.0383381) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.629109,-0.0005431) , 
3, 0.0047606, 1, 0, 0.605623,0.00462821) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.34588,-0.0473799) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.501035,-0.00193459) , 
13, 0.238085, 1, 0, 0.478132,-0.0034367) , 
7, 0.0800682, 1, 0, 0.521835,-0.00067211) , 
27, 0.52381, 1, 0, 0.5,-5.74367e-05)    );
  // itree = 44
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.310506,-0.0743961) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.231149,0.0306942) , 
1, 0.714374, 1, 0, 0.269117,-0.00631561) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.541065,0.0117614) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.475303,-0.0086425) , 
1, 1.28818, 1, 0, 0.517219,0.00165601) , 
27, 0.619048, 1, 0, 0.493002,0.000877917) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.519932,-0.0648228) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.485812,-0.0353288) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.675173,0.0367149) , 
4, 4.56914, 1, 0, 0.58112,0.0002671) , 
18, 0.408993, 1, 0, 0.561973,-0.00798503) , 
13, 0.904737, 1, 0, 0.5,-2.13335e-05)    );
  // itree = 45
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.274644,0.0349795) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.411031,-0.0445484) , 
13, 0.471549, 1, 0, 0.329957,-0.000611886) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.47181,0.0694631) , 
13, 0.761861, 1, 0, 0.363065,0.004982) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.538983,-0.0229927) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.617423,0.0373626) , 
2, 0.0238065, 1, 0, 0.548973,-0.00600307) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.50022,0.00721805) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.63803,-0.0339179) , 
19, 0.0387486, 1, 0, 0.512969,0.00139731) , 
1, 0.593541, 1, 0, 0.524041,-0.000878471) , 
27, 0.714286, 1, 0, 0.5,-3.2307e-06)    );
  // itree = 46
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.489879,-0.0018494) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.517507,0.0291) , 
3, 0.0666563, 1, 0, 0.491215,-0.000104524) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.557812,-0.0351852) , 
2, 0.0357113, 1, 0, 0.494065,-0.000676744) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.632341,0.0398537) , 
19, 0.154994, 1, 0, 0.5,4.16519e-06)    );
  // itree = 47
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.362146,0.0425803) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.59397,-0.030689) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.522465,0.00170908) , 
10, 0.177933, 1, 0, 0.526077,5.24092e-05) , 
13, 0.0952355, 1, 0, 0.519904,0.000625165) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.253122,-0.0555276) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.427292,0.0326207) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.369459,-0.0170792) , 
3, 0.0190397, 1, 0, 0.399064,0.00296319) , 
4, 2.05134, 1, 0, 0.338908,-0.00499348) , 
8, 0.714286, 1, 0, 0.5,7.28265e-06)    );
  // itree = 48
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.414057,-0.0297663) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.439729,0.00705945) , 
18, 0.428571, 1, 0, 0.43637,0.000688502) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.595662,0.0486488) , 
19, 0.0387486, 1, 0, 0.449322,0.00219671) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.415949,0.00560062) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.649442,-0.0181636) , 
11, 12.1429, 1, 0, 0.553779,-0.00314569) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.424114,0.0358265) , 
7, 0.173829, 1, 0, 0.545827,-0.00201896) , 
2, 0.00476156, 1, 0, 0.5,-1.70795e-05)    );
  // itree = 49
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.440516,-0.0386146) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.546707,0.0360303) , 
9, 0.714286, 1, 0, 0.492625,-0.000853742) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.710902,0.106252) , 
4, 15.2469, 1, 0, 0.524836,0.00526487) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.557953,0.0105418) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.436349,-0.00867473) , 
10, 0.386556, 1, 0, 0.490134,-5.44047e-05) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.610376,-0.0767973) , 
19, 0.0995458, 1, 0, 0.494628,-0.0011287) , 
18, 0.428571, 1, 0, 0.5,8.32321e-06)    );
   return;
};
 
// Clean up
inline void ReadDepth 3::Clear() 
{
   for (unsigned int itree=0; itree<fForest.size(); itree++) { 
      delete fForest[itree]; 
   }
}
   inline double ReadDepth 3::GetMvaValue( const std::vector<double>& inputValues ) const
   {
      // classifier response value
      double retval = 0;

      // classifier response, sanity check first
      if (!IsStatusClean()) {
         std::cout << "Problem in class \"" << fClassName << "\": cannot return classifier response"
                   << " because status is dirty" << std::endl;
         retval = 0;
      }
      else {
         if (IsNormalised()) {
            // normalise variables
            std::vector<double> iV;
            iV.reserve(inputValues.size());
            int ivar = 0;
            for (std::vector<double>::const_iterator varIt = inputValues.begin();
                 varIt != inputValues.end(); varIt++, ivar++) {
               iV.push_back(NormVariable( *varIt, fVmin[ivar], fVmax[ivar] ));
            }
            retval = GetMvaValue__( iV );
         }
         else {
            retval = GetMvaValue__( inputValues );
         }
      }

      return retval;
   }
